{VERSION 6 0 "IBM INTEL LINUX" "6.0" }
{USTYLETAB {CSTYLE "Maple Input" -1 0 "Courier" 1 12 255 0 0 1 2 1 2 
2 1 2 0 0 0 1 }{CSTYLE "2D Output" -1 20 "Times" 1 12 0 0 255 1 2 2 2 
2 2 1 0 0 0 1 }{CSTYLE "_cstyle69" -1 206 "Courier" 1 12 255 0 0 1 2 
1 2 2 1 2 0 0 0 1 }{CSTYLE "_cstyle67" -1 207 "Courier" 1 12 255 0 0 
1 2 1 2 2 1 2 0 0 0 1 }{CSTYLE "_cstyle66" -1 208 "Courier" 1 12 255 
0 0 1 2 1 2 2 1 2 0 0 0 1 }{PSTYLE "Normal" -1 0 1 {CSTYLE "" -1 -1 "T
imes" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }
{PSTYLE "Line Printed Output" -1 6 1 {CSTYLE "" -1 -1 "Courier" 1 12 
0 0 255 1 2 2 2 2 2 1 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "
Maple Output" -1 11 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 
2 1 0 0 1 }3 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Left Justified Maple
 Output" -1 12 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 
0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "_pstyle138" -1 227 1 
{CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 0 
0 2 0 2 0 2 2 -1 1 }{PSTYLE "_pstyle135" -1 233 1 {CSTYLE "" -1 -1 "Co
urier" 1 12 255 0 0 1 2 1 2 2 1 2 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 
1 }{PSTYLE "_pstyle134" -1 234 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 
1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }}
{SECT 0 {EXCHG {PARA 234 "> " 0 "" {MPLTEXT 1 208 3766 "#\n# This is t
he source code file of the \"SchurFkt\" package\n# SchurFkt Version 1.
0.4 (2 xi 2009) file SchurFkt-code-ver.1.0.4-2xi09_M10.mws\n# date:   \+
Nov 2, 2009\n#\n# copyright (c) Bertfried Fauser, & Rafal Ablamowicz\n
#               June 2003-September 2009, all rights reserved.\n#\n###
######################################################################
####\n#                                                               \+
            #\n#  DISCLAIMER:                                         \+
                     #\n#                                             \+
                              #\n#  THERE IS NO WARRANTY FOR THE SCHUR
FKT PACKAGE TO THE EXTENT PERMITTED    #\n#  BY APPLICABLE LAW. EXCEPT
 WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT #\n#  HOLDERS AND/OR O
THER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT         #\n#  WARRA
NTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT    #
\n#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 FOR    #\n#  A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY \+
AND PERFORMANCE  #\n#  OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM \+
PROVE DEFECTIVE, YOU      #\n#  ASSUME THE COST OF ALL NECESSARY SERVI
CING, REPAIR OR CORRECTION.        #\n#                               \+
                                            #\n#######################
######################################################\n#\n#  If you w
ant to use this code or parts of it under a GPL LICENCE, please\n#  co
ntact the authors:\n#  rablamowicz <at> tntech.edu                 or \+
\n#  Bertfried.Fauser <at> uni-konstanz.de\n#\n#\n# +++ The package co
mputes some products and coproducts for Schur functions\n# --- \n# ---
 Remember: elementary symmetric functions are s[1^r] \n# ---          \+
 complete symmetric functions are s[r]\n# ---           m[r] equals p[
r]\n# ---           m[1,...,1] equals e[r]  (r-ones)\n#\n# +++ Main fu
nctions are:\n# --- outer      : the outer product of Schur functions \+
outer(s[3,2],s[1],...)\n# --- inner      : the inner product of Schur \+
functions inner(s[2,2],s[3,1],...)\n# --- skew       : the (outer) ske
w product of two Schur functions skew(s[3,2,1],s[2])\n# --- couter    \+
 : the outer coproduct of a Schur function couter(s[4,2])\n# --- cinne
r     : the inner coproduct of a Schur function cinner(s[4,2,2])\n# --
- antipS     : the antipode of a Schur function AntipS(s[lambda])= (-1
)^|lambda|*s[lambda']\n#                  w.r.t. the outer(!) Hopf alg
ebra\n# --- plethS     : the plethysm of two Schur function polynomial
s over a ring extension\n#                  i.e. one can compute pleth
ysms of the form \n#                  plethS(a*s[3]+s[1],q*s[2,1]+s[2]
)\n#\n# --- KostkaTable: computes the Kostka matrix of rank n\n# --- i
sLattice  : returns true is a Young tableau filled with letters (0) 1.
.n is a \n#                  lattice permutation\n#                  t
he tableau has to be given as [[row1 list ,...],[row2 list, ...],...] \+
\n#                  (mainly internal use)\n#\n# +++ TYPES:\n#        \+
   Are exposed globally to Maple via the init routine of the package, \+
any\n#           new basis requires an own type. Later versions of Sch
ur may allow the \n#           user to create own types!\n#\n# --- s-f
unctions come in monoms, terms and polynoms\n# --- m-functions come in
 monoms, terms and polynoms\n# --- p-functions come in monoms, terms a
nd polynoms\n# --- e-functions come in monoms, terms and polynoms\n# -
-- h-functions come in monoms, terms and polynoms\n# --- f-functions c
ome in monoms, terms and polynoms\n# \n#     There is a need to introd
uce orthogonal and symplectic Schur functions and other bases\n#     c
urrently these are dealt with using the _same_ names but _different_ a
lgebraic maps!!\n#\n# ===> some symmetric function bases and or operat
ions in several bases are not yet available \n#" }}{PARA 233 "> " 0 "
" {MPLTEXT 1 0 9 "restart:\n" }{MPLTEXT 1 207 128452 "SchurFkt:=module
()\n   export MLIN,FLAT,\n          fallingFactorial,risingFactorial,
\n          lehmerCodeToPermutation,permutationToLehmerCode,\n        \+
  lehmerCodeToSchurFkt,schurToLehmerCode,schurToLehmerCode1,\n        \+
  skewToLehmerCode,\n          transition,\n          Descents,\n     \+
     isLattice,\n          concatM,LaplaceM,LaplaceM2,LP_mon,LaplaceM_
mon,LaplaceTable,\n          outer,outerLS,outerS,outerM,outerH,outerE
,outerP,\n          skew,skewLR,skewLS,\n          couter,couterM,cout
erH,couterE,couterP,\n          antipS,antipP,antipH,antipE,antipM,ant
ipMC,\n          KostkaTable,KostkaPC,Scalar,ScalarP,ScalarMH,ScalarHM
,\n          AlexComp,grAlexComp,PartNM,partitionsInShape,CompNM,zee,
\n          truncWT,truncLEN,collect_sfkt,sfkt_terms,\n          part2
mset,mset2part,conjpart,cmp2prtMult,cmp2part,Frob2part,part2Frob,\n   \+
       MurNak,MurNak2,CharHook,sq_coeff,\n          dimSN,dimSNP,dimSN
M,dimSNH,dimSNE,\n          dimGL,dimGLP,dimGLM,dimGLH,dimGLE,\n      \+
    GesselThetaP,GesselThetaS,\n          inner,innerP,innerH,innerM,
\n          cinner,counitInnerS,cinnerP,counitInnerP,\n          cdiag
,\n          plethP,cplethP,plethSAxNB,plethS,plethSnm,cplethS,\n     \+
     p_to_m,p_to_s,\n          m_to_p,m_to_pMat,m_to_e,m_to_h,m_to_s,
\n          s_to_p,s_to_x,s_to_h,s_to_hMat,s_to_hJT,s_to_e,s_to_hmat,s
_to_m,\n          h_to_s,h_to_m,h_to_p,\n          e_to_h,e_to_s,e_to_
m,\n          x_to_s,\n          evalJacobiTrudiMatrix,maxlengthSymFkt
,\n          outerON,couterON,getSfktSeries,branch;\n   global `type/c
liscalar`, `type/mydomain`,\n          `type/hfktmonom`, `type/hfktter
m`, `type/hfktpolynom`,\n          `type/efktmonom`, `type/efktterm`, \+
`type/efktpolynom`,\n          `type/sfktmonom`, `type/sfktterm`, `typ
e/sfktpolynom`,\n          `type/pfktmonom`, `type/pfktterm`, `type/pf
ktpolynom`,\n          `type/ffktmonom`, `type/ffktterm`, `type/ffktpo
lynom`,\n          `type/mfktmonom`, `type/mfktterm`, `type/mfktpolyno
m`,\n          `type/symfktmonom`, `type/symfktterm`, `type/symfktpoly
nom`;\n   local init,exit,ADD,LRR,getPart,makeRimRep,removeRimHook,Mur
NakRim,\n         partitionsInShape_gen,\n         dimSN_mon,dimGL_mon
,dimGLP_mon,\n         LaplaceMset,couterMproper1n,LP_l1,concatM_mon,c
oncat_mon,\n         inner_mon,cinner_mon,innerP_mon,cinnerP_mon,inner
H_mon,\n         couter_mon,couterM_mon,couterH_mon,couterE_mon,couter
P_mon,\n         antipS_mon,antipP_mon,antipH_mon,antipE_mon,antipM_mo
n,\n         p_to_mM,m_to_pM,\n         list_divisors,truncLEN_mon,Ges
selThetaP_mon,GesselThetaS_mon,\n         plethPsingleP,\n         x_t
o_sM,\n         s_to_xM,s_to_hM,s_to_eM,s_to_mM,\n         h_to_sM,h_t
o_mM,h_to_pM,\n         m_to_hM,m_to_sM,\n         etoh,e_to_hM,e_to_s
M,e_to_mM,\n         plethP_mon,plethsp,plethSP,plethS_mon,cplethS_mon
,\n         sfktmon_to_hmatrix,\n         outerON_monom,couterON_monom
,branch_monom;  \n   option package,\n          load=init,\n          \+
unload=exit;\n########################################################
#########################\n#\n#  init exposes several types in the glo
bal name space, it greets the user\n#       and initialized the tensor
 product.\n#\ninit:=proc()\n  global FIELD;\n#\n#\n#\nprintf(\"SchurFk
t Version 1.0.4 (2 xi 2009) at your service\\n(c) 2003-2009 BF&RA, no \+
warranty, no fitness for anything!\\n\",%s);\n#\n# set the global vari
able FIELD to specify the ground field of the ring /\\ and \n#     sep
cify the linearity of the tensor product &t in use\n#\n# overwirte a p
ossibly set type cliscalar, which is to radical in its linearity\n  `t
ype/cliscalar`:=proc(x)\n         type(x,'rational');\n  end proc:\n#
\n  FIELD := radalgfun(rational,[q,t,u,v]);\n  `type/mydomain`:=proc(x
) \n         type(x,radalgfun(rational,[q,t,u,v]));\n  end proc:\n  if
 assigned(`&t`) then unassign(`&t`) end if;\n  define(`&t`,multilinear
,flat,domain='mydomain');\n#\n# type:   SYM-Fkt (general symmetric fun
ction type)\n#\n  `type/symfktmonom`:=proc(a)\n     option `Copyright \+
(c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;  \n   \+
  member(op(0,a),\{s,p,h,m,e,f\});\n  end proc:\n#\n  `type/symfktterm
`:=proc(a)\n     option `Copyright (c) B. Fauser & R. Ablamowicz 2004-
2009. All rights reserved.`;  \n     if type(a,`symfktmonom`) then ret
urn true fi; \n     if type(a,`*`) and 1<>select(type,a,`symfktmonom`)
 then\n       true;\n     else\n       false; \n     fi;\n  end proc:
\n#\n  `type/symfktpolynom`:=proc(a) \n     option `Copyright (c) B. F
auser & R. Ablamowicz 2004-2009. All rights reserved.`;  \n     if typ
e(a,`symfktterm`) then return true fi:\n     if type(a,`+`) then \n   \+
    return evalb(map(type,\{op(a)\},symfktterm)=\{true\})\n     else\n
       return false;\n     fi\n  end proc:\n#\n# type:   S-Fkt\{monom,
term,polynom\}\n#\n  `type/sfktmonom`:=proc(a)\n     option `Copyright
 (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;  \n  \+
   evalb(`s`=op(0,a));\n  end proc:\n#\n  `type/sfktterm`:=proc(a)\n  \+
   option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All righ
ts reserved.`;  \n     if type(a,`sfktmonom`) then return true fi; \n \+
    if type(a,`*`) and 1<>select(type,a,`sfktmonom`) then\n       true
;\n     else\n       false; \n     fi;\n  end proc:\n#\n  `type/sfktpo
lynom`:=proc(a) \n     option `Copyright (c) B. Fauser & R. Ablamowicz
 2004-2009. All rights reserved.`;  \n     if type(a,`sfktterm`) then \+
return true fi:\n     if type(a,`+`) then \n       return evalb(map(ty
pe,\{op(a)\},sfktterm)=\{true\})\n     else\n       return false;\n   \+
  fi\n  end proc:\n#\n# type:   p-Fkt\{monom,term,polynom\}\n#\n  `typ
e/pfktmonom`:=proc(a)\n     option `Copyright (c) B. Fauser & R. Ablam
owicz 2004-2009. All rights reserved.`;  \n     evalb(`p`=op(0,a));\n \+
 end proc:\n#\n  `type/pfktterm`:=proc(a)\n     option `Copyright (c) \+
B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;  \n     if
 type(a,`pfktmonom`) then return true fi; \n     if type(a,`*`) and 1<
>select(type,a,`pfktmonom`) then\n       true;\n     else\n       fals
e; \n     fi;\n  end proc:\n#\n  `type/pfktpolynom`:=proc(a) \n     op
tion `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights re
served.`;  \n     if type(a,`pfktterm`) then return true fi:\n     if \+
type(a,`+`) then \n       return evalb(map(type,\{op(a)\},pfktterm)=\{
true\})\n     else\n       return false;\n     fi\n  end proc:\n#\n# t
ype:   m-Fkt\{monom,term,polynom\}\n#\n  `type/mfktmonom`:=proc(a)\n  \+
   option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All righ
ts reserved.`;  \n     evalb(`m`=op(0,a));\n  end proc:\n#\n  `type/mf
ktterm`:=proc(a)\n     option `Copyright (c) B. Fauser & R. Ablamowicz
 2004-2009. All rights reserved.`;  \n     if type(a,`mfktmonom`) then
 return true fi; \n     if type(a,`*`) and 1<>select(type,a,`mfktmonom
`) then\n       true;\n     else\n       false; \n     fi;\n  end proc
:\n#\n  `type/mfktpolynom`:=proc(a) \n     option `Copyright (c) B. Fa
user & R. Ablamowicz 2004-2009. All rights reserved.`;  \n     if type
(a,`mfktterm`) then return true fi:\n     if type(a,`+`) then \n      \+
 return evalb(map(type,\{op(a)\},mfktterm)=\{true\})\n     else\n     \+
  return false;\n     fi\n  end proc:\n#\n# type:   h-Fkt\{monom,term,
polynom\}\n#\n  `type/hfktmonom`:=proc(a)\n     option `Copyright (c) \+
B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;  \n     ev
alb(`h`=op(0,a));\n  end proc:\n#\n  `type/hfktterm`:=proc(a)\n     op
tion `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights re
served.`;  \n     if type(a,`hfktmonom`) then return true fi; \n     i
f type(a,`*`) and 1<>select(type,a,`hfktmonom`) then\n       true;\n  \+
   else\n       false; \n     fi;\n  end proc:\n#\n  `type/hfktpolynom
`:=proc(a) \n     option `Copyright (c) B. Fauser & R. Ablamowicz 2004
-2009. All rights reserved.`;  \n     if type(a,`hfktterm`) then retur
n true fi:\n     if type(a,`+`) then \n       return evalb(map(type,\{
op(a)\},hfktterm)=\{true\})\n     else\n       return false;\n     fi
\n  end proc:\n#\n# type:   e-Fkt\{monom,term,polynom\}\n#\n  `type/ef
ktmonom`:=proc(a)\n     option `Copyright (c) B. Fauser & R. Ablamowic
z 2004-2009. All rights reserved.`;  \n     evalb(`e`=op(0,a));\n  end
 proc:\n#\n  `type/efktterm`:=proc(a)\n     option `Copyright (c) B. F
auser & R. Ablamowicz 2004-2009. All rights reserved.`;  \n     if typ
e(a,`efktmonom`) then return true fi; \n     if type(a,`*`) and 1<>sel
ect(type,a,`efktmonom`) then\n       true;\n     else\n       false; \+
\n     fi;\n  end proc:\n#\n  `type/efktpolynom`:=proc(a) \n     optio
n `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reser
ved.`;  \n     if type(a,`efktterm`) then return true fi:\n     if typ
e(a,`+`) then \n       return evalb(map(type,\{op(a)\},efktterm)=\{tru
e\})\n     else\n       return false;\n     fi\n  end proc:\n#\n#\n# t
ype:   f-Fkt\{monom,term,polynom\}\n#\n  `type/ffktmonom`:=proc(a)\n  \+
   option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All righ
ts reserved.`;  \n     evalb(`f`=op(0,a));\n  end proc:\n#\n  `type/ff
ktterm`:=proc(a)\n     option `Copyright (c) B. Fauser & R. Ablamowicz
 2004-2009. All rights reserved.`;  \n     if type(a,`ffktmonom`) then
 return true fi; \n     if type(a,`*`) and 1<>select(type,a,`ffktmonom
`) then\n       true;\n     else\n       false; \n     fi;\n  end proc
:\n#\n  `type/ffktpolynom`:=proc(a) \n     option `Copyright (c) B. Fa
user & R. Ablamowicz 2004-2009. All rights reserved.`;  \n     if type
(a,`ffktterm`) then return true fi:\n     if type(a,`+`) then \n      \+
 return evalb(map(type,\{op(a)\},ffktterm)=\{true\})\n     else\n     \+
  return false;\n     fi\n  end proc:\n#\n# -- we protect the labesl f
or the various Schur function bases, so that no\n# -- mischieve can ha
ppen\n#\n# protect the names of basis elements\n  protect('h','m','e',
'f','s','p');\n#\n#\nend proc: # init \n#\n#\n#\nexit:=proc()\n  optio
n `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reser
ved.`;  \n  printf(\"SchurFkt Version 1.0.4 says 'Good bye...'\\n\",%s
);\nend proc:\n#######################################################
###########################\n#\n# Actual package starts here with some
 helper and internal functions \n#\n##################################
################################################\n####################
##############################################################\n#\n# H
elper functions\n#\n##################################################
################################\n#\n# MLIN is a function which allows
 to make a procedure multilinear w.r.t. the integers\n#      or any gr
ound field specified in the global variable FIELD\n#      Mostly inter
nal use!\n# +++ (warning may be replaced in future releases, don't use
 it in own code!)\n#\nMLIN:=proc()\n  option `Copyright (c) B. Fauser \+
& R. Ablamowicz 2004-2009. All rights reserved.`;  \n  local i,P,pt,re
s,sg;\n  for i from 1 to nargs do\n    lst||i:=args[i];\n    if type(l
st||i,`+`) then lst||i:=[op(lst||i)] else lst||i:=[lst||i] end if;\n  \+
end do:\n  sg:=proc(x)\n    local cf,tm;\n    if type(x,symfktmonom) t
hen \n      return 1 \n    elif type(x,symfktterm) then \n      tm,cf:
=selectremove(type,x,symfktmonom);\n      return cf; \n    else \n    \+
  error \"this should not happen\"; \n    end if; \n  end proc:\n  res
:=0:\n  P:=combinat[cartprod]([seq(lst||i,i=1..nargs)]):\n  while not \+
P[finished] do \n    pt:=P[nextvalue]();\n    res:=res+mul(sg(pt[i]),i
=1..nops(pt))*_T(seq(pt[i]/sg(pt[i]),i=1..nops(pt)));\n  end do;\n  ev
al(subs(_T=`&t`, res ));\nend proc:\n#\n# FLAT is a function which all
ows to impose the associativity of functions \n#      (flaten expressi
ons) Mostly internal use.\n# +++  (warning may be replaced in future r
eleases, don't use it in own code!)\n#\nFLAT:=proc()\n  option `Copyri
ght (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;  \+
\n  local x,lst,drp,cf,term;\n  x:=eval(subs(T=MLIN,args));\n  drp:=pr
oc() args end proc:\n  if type(x,`+`) then \n    return eval(subs(T=ML
IN,map(procname,x)))\n  elif type(x,`*`) then \n    cf,term:=selectrem
ove(type,x,'integer');\n    return cf*eval(subs(T=MLIN,T(eval(subs(T=d
rp,term)))));\n  else\n    return eval(subs(T=MLIN,T(eval(subs(T=drp,x
)))));\n  end if;\nend proc:\n########################################
########################################\n#\n# fallingFactorial is the
 polynomial Pochhammer symbol (for nonnegative integral N)\n# risingFa
ctorial  seems not to be implemented in Maple\n#\nfallingFactorial:=(x
,N)->mul((x-k),k=0..N-1):\nrisingFactorial:=(x,N)->mul((x+k),k=0..N-1)
:\n#\n#\n##########################\n#\n# Combinatorial functions\n#\n
##########################\n#\n# KostkaPC computes the Kostka coeffici
ent between a partition and a composition.\n#          Every compositi
on lies in a symmetric group orbit of a particular \n#          partit
ion, on which the Kostka coefficient is actually constant.\n#         \+
 KostkaPC is defined as the Schur-Hall scalar product of the h[comp[i]
]\n#          (=s[comp[i]) and the Schur function with partition part.
 Since the outer\n#          product is commutative and since zero par
ts of the composition turn into\n#          the multiplicative unit, w
e compute just the outer product of the one\n#          part Schurfunc
tions and then the scalar product. \n#\nKostkaPC:=proc(part1,part2)\n \+
 option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights
 reserved.`;\n  local mks;\n  mks:=(lst)->map(i->s[op(i)],lst);\n  sub
s(s[0]=1,\n      Scalar(outer(op(map(i->mks(i),part2))),s[op(part1)])
\n      );\nend proc:\n#\n# grAlexcomp establishes the graded (by part
s) anti lexicographical ordering on integer \n#            partitions \+
or compositions.\n#\ngrAlexComp:=proc(x,y)\n  option `Copyright (c) B.
 Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;  \n  if nops
(x)<nops(y) then \n    true\n  else\n     AlexComp(x,y)\n  end if;\nen
d proc:\n#\n# AlexComp  establishes the anti lexicographical ordering \+
on integer partitions or\n#           compositions.\n#\nAlexComp:=proc
(x,y)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. Al
l rights reserved.`;\n  local i,bool;\n  i:=1;\n  while i <= min(nops(
x),nops(y)) do\n    if x[i]>y[i] then return true elif x[i]<y[i] then \+
return false end if;\n    i:=i+1;\n  end do;\n  true;   \nend proc:\n#
\n# isLattice checks if a tableaux (Young diagram or shape filled with
 (non negative) \n#           integers is a Lattice permutation (ballo
t sequence)\n#\nisLattice:=proc(tbl)\n  option `Copyright (c) B. Fause
r & R. Ablamowicz 2004-2009. All rights reserved.`\n         ,remember
;  \n  local cl,lst,i,nl,T;\n  cl:=nops(tbl);\n  lst:=map(x->if x=0 th
en NULL else x end if,[seq(op(tbl[cl+1-i]),i=1..cl)]);\n  nl:=max(op(l
st));\n  for i from 1 to nl do\n    T[i]:=0:\n  end do:\n  for i from \+
nops(lst) by -1 to 1 do\n    T[lst[i]]:=T[lst[i]]+1;\n    if member(fa
lse,\{seq(evalb(T[i]>=T[i+1]),i=1..nl-1)\}) then \n      return false;
\n    end if;\n  end do;\n  true; \nend proc:\n#\n# ADD (internal use)
 adds a single letter named 'let' (integer) to a tableau in such\n#   \+
  a way, that the resulting word is a lattice permutation (i.e. in a w
ay which is\n#     allowed by the Littlewood Richardson rule). This is
 the function which actually\n#     implements the Littlewood Richards
on rule. It tries to be clever about summation\n#     but might be gre
atly improved on speed still, but uses option remember.\n#     \nADD:=
proc(tbl,let)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-
2009. All rights reserved.`\n         ,remember;\n  local cl,rl,ad,min
,res,i;\n#####\n# +++ preliminary stuff\n  cl:=nops(tbl); \n  rl:=map(
x->nops(x),tbl);\n  ad:=(x,y)->[op(x),y]:\n  res:=[]:\n# ---  \n#####
\n# +++ find first row with letter 'let'\n# --- descending search\n  m
in:=cl+1:\n  if member(let,\{op(map(x->op(x),tbl))\}) then\n    for i \+
from cl by -1 to 1 do\n      if member(let,\{op(tbl[i])\}) then min:=i
: break; end if;\n    end do:\n  else # -- no let 'let'\n    min:=1;\n
  end if;\n#####\n# +++ find first row with more letters let-1 than le
tters 'let'\n# +++ but start at row 'min'\n# --- ascending search\n  i
f let>1 then \n    for i from max(1,min-1) to cl do\n      if `+`(op( \+
map(x->op(x),[seq( map( x->if x=let-1 then -1 elif x=let then 1 else N
ULL end if,\n                       tbl[k]), k=1..i)]) )) < 0 then min
:=i+1: break; \n      end if;\n    end do:\n  end if;\n##### \n  #\n  \+
# +++ now start to put the letter in any possible place\n  # --- begin
ning with row 'min'\n  #\n  for i from min to cl do\n  #\n  # +++ case
 i=1 is different\n  #\n    if i=1 then \n      if (tbl[i][-1]<=let or
 tbl[i][-1]=0) then  \n        if isLattice(subsop(i=ad(tbl[i],let),tb
l)) then \n          res:=[op(res),subsop(i=ad(tbl[i],let),tbl)];\n   \+
     end if; \n      end if;\n    else\n  # +++ cases i=2..cl\n      i
f (rl[i-1]>rl[i]) then \n        if (tbl[i][-1]<=let or tbl[i][-1]=0) \+
then\n          if (tbl[i-1][rl[i]+1]<let or tbl[i-1][rl[i]+1]=0) then
\n            if isLattice(subsop(i=ad(tbl[i],let),tbl)) then \n      \+
        res:=[op(res),subsop(i=ad(tbl[i],let),tbl)];\n            end \+
if;      \n          end if;\n        end if;\n      end if;\n    end \+
if;\n  end do:\n  # +++ last row\n  if (tbl[cl][1]<let or tbl[cl][1]=0
) then\n    if isLattice([op(tbl),[let]]) then \n          res:=[op(re
s), [op(tbl),[let]] ];\n    end if;      \n  end if;\n  op(res);\nend \+
proc:\n#\n# LLR (internal use) is the Littlewood Richardson rule. This
 function is based on \n#     the functionality of ADD adding one lett
er at a time. LLR evacuates one tableau \n#     by adding its letters \+
successively to the (list of) tableaux emerging from \n#     previous \+
adds. \n#\nLRR:=proc(lst1,lst2)\n  option `Copyright (c) B. Fauser & R
. Ablamowicz 2004-2009. All rights reserved.`\n         ,remember;\n  \+
local i,j,k,TT,srt;\n  #\n  if lst1=[0] then return s[op(lst2)] end if
;\n  if lst2=[0] then return s[op(lst1)] end if;\n  #\n  TT:=[[seq([0$
lst1[j]],j=1..nops(lst1))]]:\n  for i from 1 to nops(lst2) do\n  for j
 from 1 to lst2[i] do\n    TT:=map(ADD,TT,i);    end do;\n  end do;\n \+
 `+`(op(map(x->s[op(x)],[seq(map(x->nops(x),TT[k]),k=1..nops(TT))])));
 \nend proc:\n#\n# (obsolete function, internal use only)\n#\n# getPar
t strips of the name of a symmetric function n[a,b,c] returning the in
dexing list.\n# +++     no longer used, inline use in code as [op(x)] \+
directly. \ngetPart:=proc(x)\n  option `Copyright (c) B. Fauser & R. A
blamowicz 2004-2009. All rights reserved.`;  \n  [op(x)];\nend proc:\n
#\n# PartNM returns a list of partitions of N with M parts.\n#        \+
PartNM returns a list ordered inversely to teh standard Maple\n#      \+
  combinat package! \n#\nPartNM := proc(n, m)\n  option `Copyright (c)
 B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n        \+
 remember;\n  local i, p, s, t;\n  if n = 0 then\n    return [[]]\n  e
lif m = 1 then\n    return [[`$`(1,n)]]\n  else\n    for i to m do\n  \+
    t := procname(n-i,min(n-i,i));\n      p[i] := seq([i, op(s)],s = t
)\n    end do;\n    [seq](p[m+1-i],i = 1 .. m);\n  end if;\nend proc:
\n#\n#\n# partitionsInShape_gen(par) produces a _set_ of all partition
s which fit into the shape par\n#         these are partitions of all \+
weights wt, 0 <= wt <= weight(par). These partitions\n#         form t
he set of possibly non-trivial skews, and generate a minimal number of
\n#         partitions for the Schur outer coproduct. This routine is \+
not optimal as it internally\n#         produces some partitions with \+
a multiplicity, this is removed by the set data structure.\n#         \+
(internal use only)\n#\npartitionsInShape_gen:=proc(par)\n   local res
,i,newpar,min,k;\n   if par=[] then return [[0]] end if;\n   if nops(p
ar)=1 then return [seq([par[1]-i],i=0..par[1])] end if; \n   res:=\{pa
r\};\n   #-- for all descents delete a box\n   for i from 1 to nops(pa
r)-1 do\n      if par[i]>par[i+1] then\n         newpar:=par;\n       \+
  newpar[i]:=newpar[i]-1;\n         res:=\{op(res),op(procname(newpar)
)\};\n      end if;\n   end do;\n   #-- last index, i points already t
o last index\n   if par[i]>1 then\n      newpar:=par;\n      newpar[i]
:=newpar[i]-1;\n      res:=\{op(res),op(procname(newpar))\};\n   else
\n      newpar:=par[1..-2];\n      res:=\{op(res),op(procname(newpar))
\};\n   end if;\n   res; \nend proc:\n#\n# partitionsInShape(par) retu
rns a sorted (wrt AlexComp) list of all partitions, including\n#      \+
   the emty one and the input partition par of partitions mu such that
 mu in par. These\n#         are the pertitions which potentially occu
re in the skew (and hence in the outer\n#         coproduct).\n#\npart
itionsInShape:=(par)->sort(ListTools:-Reverse([op(partitionsInShape_ge
n(par))]),AlexComp):\n#\n#\n#\n# CompNM returns a list of compositions
 of N with M parts\n#\nCompNM:=proc(N,M)\n   option `Copyright (c) B. \+
Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n          re
member;\n   local res,i;\n   if M<1 then return [] end if;\n   if M=1 \+
then return [N] end if;\n   if M=2 then return [seq([N-i,i],i=0..N)] e
nd if;\n   res:=[];\n   for i from N to 0 by -1 do\n     res:=[op(res)
,op(map(x->[i,op(x)],procname(N-i,M-1)))];\n   end do;\n   res;\nend p
roc:\n#\n# part2mset transforms a partition into multiset format, that
 is a composition\n#           which gives the multiplicities of parts
 [4,4,2,1,1] -> [2,1,0,2]\n#\npart2mset:=proc(part)\n  option `Copyrig
ht (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n  \+
        remember;\n  local m,mset,i;\n  if part=[0] then return [] end
 if;\n  m:=max(op(part));\n  mset:=[seq(0,i=1..m)];\n  for i from 1 to
 nops(part) do\n    mset[part[i]]:=mset[part[i]]+1;\n  end do;\n  mset
; \nend proc:\n#\n# mset2part transforms a partition in multi set repr
esentation into an ordinary partition\n#           represented by nonn
egative integer parts\n#\nmset2part:=proc(mset)\n  option `Copyright (
c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n      \+
    remember;\n  local prt,i;\n  prt:=[];\n  for i from 1 to nops(mset
) do\n    prt:=[i$mset[i],op(prt)]\n  end do;\n  if prt=[] then return
 [0] end if;\n  prt;\nend proc:\n#\n# conjpart gives the conjugated pa
rtition of the partition part\n#\nconjpart:=proc(part)\n  option `Copy
right (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`\n
         ,remember;\n  local len,res,ppart;\n  if part=[] or part=[0] \+
then return [0] end if;\n  len:=nops(part);\n  ppart:=part;\n  res:=[]
;\n  while ppart<>[] do\n    res:=[op(res),len$ppart[-1]];\n    ppart:
=map(x->if x=ppart[-1] then NULL else x-ppart[-1] end if,ppart);\n    \+
len:=nops(ppart);\n  end do;\n  res;\nend proc:\n#\n# zee gives the fa
ctor z(lambda) in the schur scalar product of power sums.\n#\n#\nzee:=
proc(part)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-200
9. All rights reserved.`\n         ,remember;\n  local mset;\n  mset:=
part2mset(part);\n  mul(i^mset[i]*mset[i]!,i=1..nops(mset));\nend proc
:\n#\n#  cmp2prtMult gives the multiplicity of the orbit of a composit
ion\n#              of its associated partition under the S_n\n#\ncmp2
prtMult:=proc(comp)\n  option `Copyright (c) B. Fauser & R. Ablamowicz
 2004-2009. All rights reserved.`,\n          remember;\n  local nc,pa
rt,f,cnt0;\n  nc:=nops(comp);\n  cnt0:=0;\n  part:=map(x->if x=0 then \+
cnt0:=cnt0+1; NULL else x end if,\n            sort(comp,(i,j)->if i>=
j then true else false end if) );\n  part:=map(x->if x=0 then NULL els
e x end if,part2mset(part));\n  if cnt0=0 then part:=part[1..-2] end i
f;\n  #################\n  f:=(ri,N)->mul(N-k,k=0..ri-1)/ri!;\n  #####
############\n  mul(f(part[k],nc+part[1]-add(part[m],m=1..k)),k=1..nop
s(part));\nend proc:\n#\n# cmp2part takes a composition and transforms
 it into a partition.\n#          This is a projection and a 'base poi
nt projection'.\n#\ncmp2part:=proc(comp)\n   option `Copyright (c) B. \+
Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n          re
member;\n   map(x->if x=0 then NULL else x end if,\n   sort(comp,(i,j)
->if i>=j then true else false end if) );\nend proc:\n#\n# part2Frob (
internal usage) maps a partition into Frobenius notation.\n#\npart2Fro
b:=proc(Part)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-
2009. All rights reserved.`,\n          remember;\n  local res,part;\n
  if Part=[0] or Part=[] then return [[],[]] end if;\n  part,res:=Part
,[[],[]];\n  while part<>[] do\n    res[1]:=[op(res[1]),part[1]-1];\n \+
   res[2]:=[op(res[2]),nops(part)-1];\n    part:=map(x->if x>1 then x-
1 else NULL end if,part[2..-1]);\n  end do;\n  res;\nend proc:\n#\n# F
rob2part (internal use) maps a partition in Frobenius notation into a \+
\n#           standard partition\n#\nFrob2part:=proc(LList)\n  option \+
`Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserve
d.`,\n          remember;\n  local res,llist,row;\n  if LList=[[],[]] \+
then return [0] end if;\n  res:=[LList[1][-1]+1,1$LList[2][-1]];\n  if
 nops(LList[1])=1 then return res end if;\n  llist:=[LList[1][1..-2],L
List[2][1..-2]];\n  while llist<>[[],[]] do\n     row:=[1$llist[2][-1]
];\n     res:=[llist[1][-1]+1,op(zip((i,j)->i+j,row,res,0))];\n     ll
ist:=[llist[1][1..-2],llist[2][1..-2]];  \n  end do;\n  res;\nend proc
:\n###################################################################
################\n#\n# T R U N C functions\n#\n#######################
############################################################\n#\n# tru
ncWT truncates the input to partitions of weight less or equal to the \+
seond \n#         argument N\n#\ntruncWT:=proc(x,N)\n  option `Copyrig
ht (c) B. Fauser & R. Ablamowicz 2004-2006. All rights reserved.`,\n  \+
remember;\n  local cf,tm,n1,plst1,plst2,i;\n  if type(x,`+`) then \n  \+
  return map(procname,x,N);\n  elif type(x,`*`) then \n    tm,cf:=sele
ctremove(type,x,symfktmonom);\n    return cf*procname(tm,N)\n  else\n \+
   if `+`(op(x))>N then return 0 else return x end if;\n  end if;\nend
 proc:\n#\n# truncLEN_mon truncates partitions of any type of symmetri
c function monoms\n#       to length less or equal to L\n#\ntruncLEN_m
on:=proc(sfkt,L)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 20
04-2006. All rights reserved.`;\n   if nops([op(sfkt)])<=L then\n     \+
return sfkt\n   else\n     return 0\n   end if;\nend proc:\n#\n# trunc
LEN truncates the partitions of a symmetric function polynom\n#       \+
to length smaller or euqlt to L, it is a linear function\n#\n#\ntruncL
EN:=proc(symfkt,L)\n  option `Copyright (c) B. Fauser & R. Ablamowicz \+
2004-2006. All rights reserved.`;\n  local cf,term;\nif symfkt=0 then \+
return 0 end if;\n  if type(symfkt,symfktmonom) then\n    truncLEN_mon
(symfkt,L)\n  elif type(symfkt,`*`) then\n    term,cf:=selectremove(ty
pe,symfkt,symfktmonom);\n    return cf*truncLEN_mon(term,L);\n  else\n
    map(procname,symfkt,L);\n  end if;\nend proc:\n###################
##############################################\n#\n# collect_sfkt coll
ects a polynomial with respect to an sfunction \n#      basis 's,p,m,h
,f,e' and returns the prefactors factorized.\n#      The basis is by d
efault the Schur function basis and may be\n#      altered by giving a
 letter from the set 's,p,m,h,f,e' as\n#      second argument.\n#\n###
##############################################################\ncollec
t_sfkt:=proc(X)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 200
4-2006. All rights reserved.`;\n  local x,lst,i,term,terms,termTbl,TYP
E;\n  if nargs=2 then\n    TYPE:=args[2];\n    if not member(TYPE,\{s,
p,m,h,f,e\}) then\n      error \"You picked a type '%1' which is not i
n my list of known types\\n\n             's,p,m,h,f,e' !\",TYPE;\n   \+
 end if;\n  else \n    TYPE:='s';\n  end if;\n  if x=0 then return 0 e
nd if;\n  x:=expand(X);\n  terms:=\{\}; \n  if type(x,cat(TYPE,fktmono
m)) then \n     return x;\n  elif type(x,cat(TYPE,fktterm)) then\n    \+
  return x;\n  elif type(x,`+`) then\n      lst:=[op(x)];\n      for i
 from 1 to nops(lst) do\n        if type(lst[i],cat(TYPE,fktmonom)) th
en\n          termTbl:=(lst[i])=1;\n        else\n          term:=sele
ct(type,lst[i],cat(TYPE,fktmonom));\n          terms:=\{op(terms),term
\};\n        end if;\n      end do;\n      if terms=\{1\} then\n      \+
  error \"I didn't find a basis element, provide a correct basis!\";\n
      end if;\n      return map(factor,collect(x,terms));\n  end if;\n
end proc:\n###########################################################
######\n#\n#  sfkt_terms returns a set of basis monoms of an input exp
ression. \n#      The basis is by default the Schur function basis and
 may be\n#      altered by giving a letter from the set 's,p,m,h,f,e' \+
as\n#      second argument.\n#\n######################################
###########################\nsfkt_terms:=proc(X)\n  option `Copyright \+
(c) B. Fauser & R. Ablamowicz 2004-2006. All rights reserved.`;\n  loc
al cf,x,lst,i,term,terms,termTbl,TYPE;\n  if nargs=2 then\n    TYPE:=a
rgs[2];\n    if not member(TYPE,\{s,p,m,h,f,e\}) then\n      error \"Y
ou picked a type '%1' which is not in my list of known types\\n 's,p,m
,h,f,e' !\",TYPE;\n    end if;\n  else \n    TYPE:='s';\n  end if;\n  \+
x:=expand(X);\n  terms:=\{\}; \n  if type(x,cat(TYPE,fktmonom)) then \+
\n     return \{x\};\n  elif type(x,cat(TYPE,fktterm)) then\n      ter
m,cf:=selectremove(type,x,cat(TYPE,fktterm));\n      return \{term\};
\n  elif type(x,`+`) then\n      lst:=[op(x)];\n      for i from 1 to \+
nops(lst) do\n        if type(lst[i],cat(TYPE,fktmonom)) then\n       \+
   terms:=\{op(terms),lst[i]\};\n        else\n          term:=select(
type,lst[i],cat(TYPE,fktmonom));\n          terms:=\{op(terms),term\};
\n        end if;\n      end do;\n      if terms=\{1\} then error \"Co
uldn't find a basis monom!\\nyou can provide a second argument with th
e name of the basis like 's', 'p', 'h', 'f', 'e' \\n\";\n      end if;
\n      return terms;\n  end if;\nend proc:\n#########################
########################################\n#\n# Functions related to th
e Lascoux Schuetzenberger algorithm \n#\n#          to multiply and sk
ew Schur functions\n#\n###############################################
##################\n#\n#\n# lehmerCodeToPermutation transform a Lehmer
 code of a permutation\n#           into the list representation of th
at permutation, that\n#           is the list of the image of the perm
utaion of of the\n#           standatd list [1..n]\n#\n#     Note: we \+
prune trailing fixed points, it the second variable is set to \"prune
\"\n#           including quotes\n#\n#   -- The algorithm use is the f
ollowing recursion:\n#   -- let ordLst be the orderd list [1..n]\n#   \+
-- \\pi_1 is the lement ordLst_\{code[1]+1\}\n#   -- remove the elemen
t ordLst_\{code[1]+1\} from the list ordList\n#   -- \\pi_2 is the lem
ent ordLst_\{code[2]+1\}\n#   -- remove the element ordLst_\{code[2]+1
\} from the list ordList\n#   -- repeat unless ordLst is empty\n#   --
 if \"prune\" is set, we skip trailing fixed points, that is\n#   -- w
e reduce the permutation from S_n (n=card(ordLst)) to a smaller\n#   -
- S_k which acts on the first [1..k] entries, in this way S_k is\n#   \+
-- canonically embedded into S_n for n>k.\n#\nlehmerCodeToPermutation:
=proc(code)\n  option remember;\n  local ordLst,i,idx,per,prune;\n  if
 nargs=2 and args[2]=\"prune\" then prune:=true; print(\"prune is true
 now\"); else prune:=false; end if;\n  ordLst:=[seq(i,i in 1..nops(cod
e))];\n  per:=[];\n  for i from 1 to nops(code) do\n     idx:=ordLst[c
ode[i]+1];\n     per:=[op(per),idx];\n     ordLst:=subs(idx=NULL,ordLs
t);\n  end do;\n  if prune=true then\n     i:=nops(per);\n     while p
er[i]=i and i>1 do\n        i:=i-1;\n        per:=per[1..-2];\n     en
d do;\n   end if;\n  per;\nend proc:\n#\n# permutationToLehmerCode tra
nsforms a permutation \\pi in list representation (image\n#           \+
  of \\pi acting on the standard set [1..n]) into the Lehmer code of t
he\n#             permutation\n#\n#     -- The Lehmer code of a permut
ation is given by code:=[l1,..,ln] with\n#     -- lk :=Card \{ j>k, \\
pi[k]>\\pi[j] \}\n#     -- The Lehmer code is a factorial number syste
m adapted to permutations\n#     -- since card S_n = n! This allows a \+
one-one relation between such codes\n#     -- and permutations.\n#    \+
 -- If S_k is embedded into S_n in such a way that S_k permuste the fi
rst [1..k]\n#     -- entries of the standard set while S_n permutes [1
..n], then the Lehmer code\n#     -- of a permutation S_k transforms u
nder this injection into the Lehmer code of\n#     -- \\pi in S_n by a
dding appropriatly many trailing zeros.\n#\npermutationToLehmerCode:=p
roc(per)\n  option remember;\n  local idx,lehmer,res,k,j;\n  if per=[]
 then return [] end if;\n  if \{op(per)\}<>\{seq(i,i in 1..nops(per))
\} then error \"input was not a permutation of the form (i1,i2,...in) \+
with entries ik in [1..n]\" end if;\n  if per=[] then return [0] end i
f;\n  lehmer:=[];\n  for k from 1 to nops(per)-1 do\n     idx:=0;\n   \+
  for j from k+1 to nops(per) do\n        if per[j]<per[k] then idx:=i
dx+1 end if;\n     end do;\n     lehmer:=[op(lehmer),idx];\n   end do;
\n  [op(lehmer),0];\nend proc:\n#\n# Descents takes a permutation pi a
nd returns the the list of descents of pi\n#         ++ the list of de
scents is in decreasing order\n#         ++ Descents describe importan
t facts about the structure of\n#         ++ reduced words representin
g permutations when written as\n#         ++ product of elementary tra
nspositions (i,i+1)\n#\nDescents:=proc(per)\n   option remember;\n   l
ocal des,i;\n   des:=[];\n   for i from 1 to nops(per)-1 do\n      if \+
per[i]>per[i+1] then des:=[i,op(des)]; end if;\n   end do;\n   des;\ne
nd proc:\n#\n# lehmerCodeToSchurFkt transforms a Lehmer code of a Gras
smannian permutation\n#         ++ that is a permutation which respres
ents a Schur function into\n#         ++ the Schurfunction with the co
rresponding partition lable\n#         ++ NOTE: No check is performed \+
if the input is a Lehmer code of a Grassmanian\n#         ++       per
mutation. This routine is meant for internal use mainly.\n#\nlehmerCod
eToSchurFkt:=proc(code)\n   option remember;\n   local i,prt;\n   ## +
+ no check included, user or algorithm must make sure\n   ## ++ input \+
represents a Schur function, otherwise return value is invalid_operati
on\n   prt:=[];\n   for i from 1 to nops(code) do\n     if code[i]<>0 \+
then\n       prt:=[code[i],op(prt)];\n     end if;\n   end do;\n   ## \+
-- possibly needs to be sorted, if vexillary permutations are used, if
 the\n   ## -- transition algorithm runs through, till the permutation
 has only one\n   ## -- descent, it seems to be unnecessary to sort he
re.\n   s[op(prt)]\nend proc:\n#\n# schurToLehmerCode implements the r
elation between a Schurfunction \{\\lambda\}^m\n#     \{\\lambda\}^m=s
_\\lambda(x1,...xm) in exactly m-variables and a Grassmannian\n#     L
ehmer code of a permutation (that is a permutation with exactly one de
scent.\n#     The parameter m gived the muner of variables. Caution, i
f m is too small,\n#     the Schur function may be unrepresentable (=0
) in that Z[x1,..,xm]\n#     An optimal embedding is reached by settin
g m=length(\\lambda), resulting in\n#     no leading zerors on teh Leh
mer code.\n#     We don't add trailing zeros, but keep the minimal num
ber of _required_\n#     trailing zeros\n#\nschurToLehmerCode:=proc(sf
kt,m)\n   option remember;\n   local code,i,par,wt;\n   par:=[op(sfkt)
];\n   wt:=`+`(op(sfkt));\n   code:=[];\n   for i from 1 to nops(par) \+
do\n      code:=[par[i],op(code)];\n   end do;\n   code:=[op(code),0$p
ar[1]];\n   [0$(m-nops(par)),op(code)];\nend proc:\n#\n# schurToLehmer
Code1 computes automatically the minimal embedding of the Schur functi
on\n#     in terms of Lehmer codes\n#\nschurToLehmerCode1:=proc(x) sch
urToLehmerCode(x,nops([op(x)])) end proc:\n#\n# skewToLehmerCode trans
forms two partitions of two schur functions\n#      which are to be sk
ewed into the Lehmer code representing the\n#      skew partitions sch
ur function.\n#\nskewToLehmerCode:=proc(sf1,sf2)\n   option remember;
\n   local prt,i,code,k,elem;\n   prt:=[op(sf1)];\n   code:=[];\n   fo
r i from 1 to nops(prt) do\n      code:=[prt[i],op(code)];\n   end do;
\n   code:=[op(code),0$code[-1]];\n   if sf2=s[0] then return code end
 if;\n   k:=nops(prt);\n   prt:=[op(sf2)];\n   for i from 1 to nops(pr
t) do\n      code[k+prt[i]]:=code[k]-prt[i];\n      code[k]:=0;\n     \+
 k:=k-1;\n   end do;\n   [op(code)];\nend proc:\n#\n# transition imple
ments an algorithmy by Lascoux and Schuetzernberger Lett. Math. Phys. \+
10 (1985) 111-124\n#      this paper does not give a full description \+
of the implemented code, but uses vexillary permutations.\n#      We u
se a variant of the algorithm described by Axel Konhner, who was also \+
helpful in proding\n#      details and further information, see:\n#   \+
   A. Kohner, Schubert polynomials and skew Schur functions, 1991\n#  \+
    A. Kohner, The use of Schubert polynomials in SYMCHAR (later SYMME
TRICA), 1991\n#      A further usefull resource is\n#      R. Winkel, \+
Recursive and combinatorial properties of Schubert polynomials, \n#   \+
              Sem. Lotharigien de Comb. Vol38 1996 B38c 29pp \n#\n#   \+
   The algorithms is as follows:\n#      input a permutation pi, not o
f Grassmanian type (two or more descents)\n#      1) compute the right
 most descent k\n#      2) swap the element pi[k] and the largest pi[l
] to the right smaller than pi[k]\n#      3) find all elements to the \+
left of k such that\n#         -- pi[l] is smaller than pi[k]\n#      \+
   -- there is no pi[j] with pi[l]<pi[j]<pi[k] for l<j<k\n#         pr
oduce all permutationes obtained by swapping the pi[l] with pi[k]\n#  \+
       Note: We had to add the following rule:\n#         -- If the se
arch for pi[l] returns no element, then return the partition\n#       \+
     which is obtained by shifting the Lehmer code of the _input_ part
ition\n#            by one to the right inserting a 0 at place 1\n#   \+
         [On the partition this means add a 1 to each part and concate
nate\n#              1 |_| 1+[pi]\n#      4) output the list of the pr
oduced permutations\n#\n#\ntransition:=proc(perIN)\n   option remember
;\n   local max,per,k,l,i,elem,res,sp_min,newper,code;\n   # -- per ne
eds to have nops(per)>2 check?\n   max:=nops(perIN);\n   per:=perIN;\n
   # -- ingone final fixed points\n   while per[max]=max do max:=max-1
; end do;\n   # -- find last descent\n   k:=max-1;\n   while per[k]<pe
r[k+1] do k:=k-1; end do;\n   # find largest per[l] to the right of pe
r[k] with per[l]<per[k]\n   l:=k+1;\n   elem:=per[l];\n   for i from k
+2 to max do\n      if per[i]<per[k] and elem<per[i] then elem:=per[i]
; l:=i end if;\n   end do;\n   ## -- switch places k,l, note elem:=per
[l]\n   per[l]:=per[k];\n   per[k]:=elem;\n   # -- find all elements l
eft to k which fulfill\n   # -- per[l]<per[k] and no element exists wi
th\n   # -- per[l\}<per[i]<per[k] for l<i<k\n   # -- switch these elem
ents and return the list or permutations\n   res:=[];\n   # -- find el
ements smaller per[k] to the left\n   # -- special case k=1\n   if k=1
 then return [per] end if;\n   l:=k-1;\n   sp_min:=0;  \n   while l>0 \+
do\n        if sp_min<per[l] and per[l]<per[k] then\n        # -- make
 new permutation with (l,k) switched\n        sp_min:=per[l];\n       \+
 newper:=per;\n        newper[l]:=per[k];\n        newper[k]:=per[l];
\n        res:=[op(res),newper];\n      end if;\n      # -- else proce
ed\n      l:=l-1; \n   end do;\n   ## A. Kohnert says keep this:\n   i
f l=0 and res=[] then\n   # -- However, we need to add a prefix 0 to t
he Lehmer code of perIN\n   # -- otherwise the algorithm cannot find a
n element in the left search\n      if perIN[nops(perIN)]=nops(perIN) \+
then\n        res:=[[1,seq(perIN[i]+1,i in 1..nops(perIN)-1)]];\n     \+
 else\n        res:=[[1,seq(perIN[i]+1,i in 1..nops(perIN))]];\n      \+
end if;\n   end if;\n   res;\nend proc:\n#\n##########################
#######################################\n#\n# basis transformations\n#
\n#################################################################\n#
\n# s_to_xM transforms an S-function into a polynom of x-monomials in
\n#         N variables (x1,x2,...,xn) (N should be greater or equal\n
#         to the weight of the partition.\n#\n#         <internal use;
 users use the linear version s_to_x>\n#\ns_to_xM:=proc(sfkt,N)\n  opt
ion `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights res
erved.`\n         ,remember;\n  local cmp;\n  cmp:=CompNM(`+`(op(sfkt)
),N);\n  add(KostkaPC([op(sfkt)],k)*x[op(k)],k=cmp);\nend proc:\n#\n# \+
x_to_sM gets a monomial and transforms it back into an S-function.\n# \+
        This transformation is critical, since the transformation matr
ix\n#         K is rectangular! The inverse is computes on the maximal
 rank\n#         subspace, and suitably normalized, so that the collex
tion of\n#         *all* x monomials which give rise to the same S-fun
ctions\n#         adds up to the integral result\n#\n#         <intern
al use; users use the linear version x_to_s>\n#\nx_to_sM:=proc(xfkt)\n
  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All right
s reserved.`\n         ,remember;\n  local wgt,prt,KMat,tab,tabc,cmp,m
atT;\n  wgt:=`+`(op(xfkt));\n  prt:=PartNM(wgt,wgt);\n  KMat :=evalm(l
inalg[matrix](nops(prt),nops(prt),(i,j)->KostkaPC(prt[i],prt[j]))^(-1)
);\n  tab:=table([seq((prt[k])=k,k=1..nops(prt))]);\n  cmp:=CompNM(wgt
,nops([op(xfkt)]));\n  matT:=linalg[matrix](nops(cmp),nops(prt),\n    \+
   (i,j)->1/cmp2prtMult(cmp[i])*KMat[tab[cmp2part(cmp[i])],tab[prt[j]]
]);\n  ## new index  \n  tabc:=1; while [op(xfkt)]<>cmp[tabc] do tabc:
=tabc+1; end do;\n  add(matT[tabc,k]*s[op(prt[k])],k=1..nops(prt));\ne
nd proc:\n#\n# s_to_x linear version of the transformation of S functi
ons to x monomials\n#\ns_to_x:=proc(sfkt,weight)\n  option `Copyright \+
(c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n     \+
     remember;\n  local cf,term,lst;\n  if weight=0 then return 1 end \+
if;\n  if sfkt=0 then \n    return 0;\n  elif type(sfkt,`+`) then \n  \+
  return map(procname,sfkt,weight)\n  elif type(sfkt,`*`) then\n    te
rm,cf:=selectremove(type,sfkt,sfktmonom);\n    return cf*procname(term
,weight)\n  else\n    s_to_xM(sfkt,weight);\n  end if; \nend proc:\n#
\n# x_to_s linear version of the transformation of x monomials to S fu
nctions\n#\nx_to_s:=proc(xfkt)\n  option `Copyright (c) B. Fauser & R.
 Ablamowicz 2004-2009. All rights reserved.`,\n          remember;\n  \+
local cf,term,lst;\n  if type(xfkt,`+`) then \n    return map(procname
,xfkt)\n  elif type(xfkt,`*`) then\n    cf,term:=selectremove(type,xfk
t,\{'integer','fraction'\});\n    return cf*procname(term)\n  else\n  \+
  x_to_sM(xfkt);\n  end if; \nend proc:\n#############################
##################################################\n#\n# h_to_s transf
ormes a complete symmetric function into an s-function polynomial.\n# \+
       \nh_to_sM:=proc(hfkt)\n  option `Copyright (c) B. Fauser & R. A
blamowicz 2004-2009. All rights reserved.`,\n          remember;\n  if
 hfkt=0 then return 0 end if;\n  outer(op(map(i->s[i],[op(hfkt)])));\n
end proc:\nh_to_s:=proc(hfkt)\n  option `Copyright (c) B. Fauser & R. \+
Ablamowicz 2004-2009. All rights reserved.`;\n  local n1,prt,cf,term,l
st;\n  if hfkt=0 then return 0 end if;\n  if not type(hfkt,hfktpolynom
) then \n     error(\"wrong basis as input, need complete symmetric fu
nctions\"); \n  end if;\n  if hfkt=h[0] then return s[0] end if;\n  if
 type(hfkt,`+`) then \n    return map(procname,hfkt)\n  elif type(hfkt
,`*`) then\n    term,cf:=selectremove(type,hfkt,hfktmonom);\n    retur
n cf*procname(term)\n  else\n    return h_to_sM(hfkt)\n  end if; \nend
 proc:\n##############################################################
#################\n#\n# s_to_h transformes a s-function polynomial int
o complete symmetric functions.\n#\n# WARNING: SLOW!! Uses the inverse
 Kostka Matrix\n#          better use the Jacobi-Trudi formula!\n#    \+
    \ns_to_hM:=proc(sfkt)\n  option `Copyright (c) B. Fauser & R. Abla
mowicz 2004-2009. All rights reserved.`,\n          remember;\n  local
 prt,N,KI,i;\n  KI:=evalm(rhs(KostkaTable(`+`(op(sfkt))))^(-1));\n  N:
=`+`(op(sfkt));\n  prt:=PartNM(N,N);\n  i:=1: while prt[i]<>[op(sfkt)]
 do i:=i+1 end do;\n  add(KI[j,i]*h[op(prt[j])],j=1..nops(prt));\nend \+
proc:\ns_to_hMat:=proc(sfkt)\n  option `Copyright (c) B. Fauser & R. A
blamowicz 2004-2009. All rights reserved.`;\n  local n1,prt,cf,term,ls
t;\n  if sfkt=0 then return 0 end if;\n  if sfkt=s[0] then return h[0]
 end if;\n  if type(sfkt,`+`) then \n    return map(procname,sfkt)\n  \+
elif type(sfkt,`*`) then\n    term,cf:=selectremove(type,sfkt,sfktmono
m);\n    return cf*procname(term)\n  else\n    return s_to_hM(sfkt)\n \+
 end if; \nend proc:\n################################################
###############################\n#\n# s_to_h recursive faster version
\n#\ns_to_h:=proc(x)\n  option `Copyright (c) B. Fauser & R. Ablamowic
z 2004-2009. All rights reserved.`,\n  remember;\n  local term,cf;\n  \+
if x=0 then return 0 end if;\n  if x=s[0] then return h[0] end if;\n  \+
if type(x,`+`) then\n     map(procname,x)\n  elif type(x,`*`) then\n  \+
  term,cf:=selectremove(type,x,sfktmonom);\n    return cf*procname(ter
m);\n  else\n    return h[op(x)] + procname(x-h_to_s(h[op(x)]));\n  en
d;\nend proc:\n#\n####################################################
###########################\n#\n# sfktmon_to_hmatrix transforms a sfkt
monom (Schur basis function) into\n#   -- a matrix in such a way, that
 the determinant of the matrix w.r.t\n#   -- the outer product yields \+
back the Schur function monom.\n#   -- the entries of the matrix are o
ne part Schur functions, and hence\n#   -- can be multiplies by teh ou
ter product in teh complete symmetric function\n#   -- basis, this giv
es teh Jacobi-Trudi formula for Schur functions\n#   -- s_\\lambda = d
et( h_[\\lambda_i-i+j]) \n#   -- (there is a similar formula for the e
lementray symetric functions)\n#\nsfktmon_to_hmatrix:=proc(x)\n  local
 l,f,dim,lst;\n  l,dim:=nops([op(x)]),0;\n  if nargs=2 then l:=max(l,a
rgs[2]) end if;\n  lst:=[op(x),0$(l-nops([op(x)]))];\n  f:=(x)->if x<0
 then 0 else h[x] end if;\n  evalm(linalg[matrix](l,l,(i,j)->f(lst[i]-
i+j)));\nend proc:\n#\n# s_to_hmat transforms an sfunction into a Toep
litz matrix of complete one part\n#    -- symmetric functions. It take
s as a second argument a dimension, which can\n#    -- be taken to be \+
the largest length of all involved partitions in teh sfktpolynom\n#   \+
 -- see : \"maxlengthSymFkt()\" below\n#\ns_to_hmat:=proc(x)\n  option
 `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserv
ed.`,\n  remember;\n  local cf,tm,dim;\n  if nargs=2 then dim:=args[2]
 else dim:=NULL end if;\n  if type(x,`+`) then \n    return map(procna
me,x,dim);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,s
fktmonom);\n    return cf*procname(tm,dim)\n  else\n    sfktmon_to_hma
trix(x,dim);  \n  end if;\nend proc:\n#\n# evalJacobiTrudiMatrix given
 an Jacobi-Trudin matrix (say from sfktmon_to_hmatrix)\n#    -- this f
unction evaluates the determinant w.r.t. the outer product in the \n# \+
   -- complete symmetric function basis.\n#    -- NOTE: one can give a
 multiplication as second argument! \n#\nevalJacobiTrudiMatrix:=proc(m
atrix)\n  local mdim,lst,i,k,l,fun;\n  if nargs=2 then fun:=args[2] el
se fun:=outerH end if;\n  mdim:=linalg[rowdim](matrix);\n  if mdim=1 t
hen return matrix[1,1] end if;\n  lst:=[seq(i,i=1..mdim)];\n  add((-1)
^(i-1)*expand(fun(matrix[i,1],\n       procname(linalg[submatrix](\n  \+
   matrix,map(x->if x=i then NULL else x end if,lst),[seq(k,k=2..mdim)
]))))\n     ,i=1..mdim);\nend proc:\n#\n# s_to_hJT linear version of t
he transition from the s-basis into the h-basis\n#   -- useing the Jac
obi-Trudi formula\n#\ns_to_hJT:=proc(x)\n  option `Copyright (c) B. Fa
user & R. Ablamowicz 2004-2009. All rights reserved.`,\n  remember;\n \+
 local cf,tm,fun;\n  if nargs=2 then fun:=args[2] else fun:=outerH end
 if;\n  if type(x,`+`) then \n    return map(procname,x);\n  elif type
(x,`*`) then \n    tm,cf:=selectremove(type,x,sfktmonom);\n    return \+
cf*procname(tm)\n  else\n    evalJacobiTrudiMatrix(sfktmon_to_hmatrix(
x),fun);  \n  end if;\nend proc:\n#\n# maxlengthSymFkt gives the maxim
al length of a partition index in a\n#  -- symfktpolynom of type \{s,p
,m,h,f,e\}\n#\n#\nmaxlengthSymFkt:=proc(x)\n  option `Copyright (c) B.
 Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n  remember;
\n  local cf,tm;\n  if type(x,`+`) then \n    return max(op(map(procna
me,[op(x)])));\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type
,x,symfktmonom);\n    return nops([op(tm)])\n  else\n    return nops([
op(x)])  \n  end if;\nend proc:\n#####################################
##########################################\n#\n# etoh is the transitio
n from elementary to complete symmetric functions for\n#     -- one pa
rt elementary symmetric functions e_n. It is done using the fact\n#   \+
  -- that the generating functions H_t=\\sum_n \{n]t^n and E_-t = \\su
m_m (-1)^m \{1^m\}t^m\n#     -- are inverse series under the pointwise
 product of functions\n#     -- Note: H_t = M_t and E_-t = M_t[-s_1] =
 \\sum_n S(\{n\})t^n\n#\netoh:=proc(x)\n  local n;\n  n:=op(x);\n  if \+
n=1 then return h[1] elif n=0 then return h[0] end if;\n  add((-1)^(n-
r-1)*outerH(h[n-r],procname(e[r])),r=0..n-1);\nend proc:\n#\n# e_to_hM
 is the basis change e_to_h on a single efktmonom, it uses the fact th
at the '\n#     -- elementary symmetric functions for a multiplicative
 basis and employs `etoh'\n#\ne_to_hM:=proc(x)\n  local prt;\n  prt:=[
op(x)];\n  outerH(op(map(etoh,map(x->[x],prt))));\nend proc:\n#\n# e_t
o_h linear version of the transformation of elementary functions into \+
complete functions\n#\ne_to_h:=proc(efkt)\n  local cf,term,lst;\n  if \+
efkt=0 then return 0 end if;\n  if efkt=e[0] then return h[0] end if;
\n  if type(efkt,`+`) then \n    return map(procname,efkt)\n  elif typ
e(efkt,`*`) then\n    term,cf:=selectremove(type,efkt,efktmonom);\n   \+
 return cf*procname(term)\n  else\n    e_to_hM(efkt);\n  end if; \nend
 proc:\n#\n# e_to_sM is the transition from elementary symmetric funct
ion monoms to Schur functions\n#    -- it uses the fact that e_k=s[1,1
,...,1] (k ones) \n#\ne_to_sM:=proc(x)\n  outerS(op(map((x)->s[1$x],[o
p(x)])));\nend proc:\n#\n# e_to_s linear version of the transformation
 of elementary functions into Schur functions\n#\ne_to_s:=proc(efkt)\n
  local cf,term,lst;\n  if type(efkt,`+`) then \n    return map(procna
me,efkt)\n  elif type(efkt,`*`) then\n    term,cf:=selectremove(type,e
fkt,efktmonom);\n    return cf*procname(term)\n  else\n    e_to_sM(efk
t);\n  end if; \nend proc:\n#\n# e_to_mM ist the basis change from e-f
kt to m-fkt on monomials\n#\ne_to_mM:=proc(x)\n  option `Copyright (c)
 B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;\n  local \+
lst;\n  lst:=[op(x)];\n  outerM(op(map(x->m[1$x],lst)));\nend proc:\n#
\n# e_to_m is the linear basis change from elementary symmetric functi
ons to\n#        monomial symmetric functions\n#\ne_to_m:=proc(x)\n   \+
option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights \+
reserved.`,\n          remember;\n   local cf,tm;\n   if x=0 then retu
rn 0 end if;\n   if x=e[0] then return m[0] end if;\n   if type(x,`+`)
 then \n     return map(procname,x);\n   elif type(x,`*`) then \n     \+
tm,cf:=selectremove(type,x,efktmonom);\n     return cf*procname(tm,x)
\n   else\n     e_to_mM(x);  \n   end if;\n end proc:\n###############
################################################################\n#\n#
 h_to_mM is the basis transformation from complete to monomials ymmetr
ic functions\n#   -- it is computed along the lines of Rota-Stein usin
g the multiplicativity of \n#   -- the complete basis. The coproduct i
s used in disguise in the formula\n#   -- h_(n) = \\sum_\{\\mu|-n\} m_
\\mu, and the multiplicativity is translated into\n#   -- the nonmulti
plicative outerM product.\n#\nh_to_mM:=proc(x)\n  option `Copyright (c
) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n       \+
   remember;\n  local lst,f;\n  if x=0 then \n    return 0\n  elif x=h
[0] then\n    return m[0]\n  end if;\n  #  -- h(n) = \\sum_rho p[rho] \+
= \\sum_\\rho \\prod_i p[rho_i]\n  #  -- and use p(n)==m(n)\n  f:=(x)-
>add(m[op(i)],i=PartNM(x,x));\n  lst:=[op(x)];\n  outerM(op(map(f,lst)
));\nend proc:\n#\n# h_to_m linear version of the transformation of co
mplete functions into monomial functions\n#\nh_to_m:=proc(hfkt)\n   op
tion `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights re
served.`;\n  local cf,term,lst;\n  if type(hfkt,`+`) then \n    return
 map(procname,hfkt)\n  elif type(hfkt,`*`) then\n    term,cf:=selectre
move(type,hfkt,hfktmonom);\n    return cf*procname(term)\n  else\n    \+
h_to_mM(hfkt);\n  end if; \nend proc:\n#\n# h_to_pM is the transformat
ion from h-basis monomials to p-bases\n#\nh_to_pM:=proc(x)\n  option `
Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved
.`,\n         remember;\n  local lst,f;\n  f:=(x)->add(p[op(i)],i=Part
NM(x,x));\n  if x=0 then \n    return 0\n  elif x=h[0] then\n    retur
n m[0]\n  end if;\n  lst:=[op(x)];\n  outerP(op(map(f,lst))); \nend pr
oc:\n#\n# h_to_p linear version of the transformation of complete func
tions into power sums\n#\nh_to_p:=proc(hfkt)\n   option `Copyright (c)
 B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;\n  local \+
cf,term,lst;\n  if type(hfkt,`+`) then \n    return map(procname,hfkt)
\n  elif type(hfkt,`*`) then\n    term,cf:=selectremove(type,hfkt,hfkt
monom);\n    return cf*procname(term)\n  else\n    h_to_pM(hfkt);\n  e
nd if; \nend proc:\n##################################################
#############################\n#\n# p_to_s transformes a power sum pol
ynomial into an s-function polynomial.\n#        This version was chec
ked against SCHUR\n#\np_to_s:=proc(pfkt)\n  option `Copyright (c) B. F
auser & R. Ablamowicz 2004-2009. All rights reserved.`;\n  local n1,pr
t,cf,term,lst;\n  if pfkt=0 then return 0 end if;\n  if pfkt=p[0] or p
fkt=p[] then return s[0] end if;\n  if type(pfkt,`+`) then \n    retur
n map(procname,pfkt)\n  elif type(pfkt,`*`) then\n    term,cf:=selectr
emove(type,pfkt,pfktmonom);\n    return cf*procname(term)\n  else\n   \+
 n1:=`+`(op(pfkt));   \n    prt:=PartNM(n1,n1);\n    add(s[op(i)]*MurN
ak([op(pfkt)],i),i=prt);\n  end if; \nend proc:\n#####################
##########################################################\n#\n# p_to_
s recursive version INACTIVE about 10 times slower than the combinator
ial\n#        version using the Murnaghan Nakayama rule\n#\n##########
#####################################################################
\n#p_to_sM:=proc(x)\n#  option remember;\n#  local k,lst;\n#  if x=0 t
hen return 0 end if;\n#  if nops([op(x)])=1 then\n#    return s[op(x)]
+add((-1)^k*s[op(x)-k,1$k],k=1..op(x)-1);\n#  else\n#    lst:=[op(x)];
\n#    return outer(op(map((a)->s[op(a)]+add((-1)^k*s[op(a)-k,1$k],k=1
..op(a)-1) ,lst)));\n#  end if;\n#end proc:\n#\n#p_to_s2:=proc(x)\n#  \+
local cf,term;\n#  if x=0 then return 0 end if;\n#  if type(x,`+`) the
n\n#    return map(procname,x);\n#  elif type(x,`*`) then\n#    term,c
f:=selectremove(type,x,pfktmonom);\n#    return expand(cf*procname(ter
m));\n#  else\n#    return p_to_sM(x);\n#  end if;\n#end proc:\n######
######################################################################
####\n#\n# s_to_p transformes an s-function into power sums.\n#       \+
 This version was checked against SCHUR, but *differs*\n#        in th
at effect, that it does not introduce an artificial \n#        factor \+
n! to avaoid fractional coefficients\n#\n#\ns_to_p:=proc(xfkt)\n  opti
on `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights rese
rved.`;\n  local cf,term,lst,mat,np,prt,i;\n  if xfkt=0 then return 0 \+
end if;\n  if xfkt=s[0] then return p[0] end if;\n  if type(xfkt,`+`) \+
then \n    return map(procname,xfkt)\n  elif type(xfkt,`*`) then\n    \+
term,cf:=selectremove(type,xfkt,sfktmonom);\n    return cf*procname(te
rm)\n  else\n    np:=`+`(op(xfkt));\n    prt:=PartNM(np,np);   \n    i
:=1:\n    while prt[i]<>[op(xfkt)] do i:=i+1 end do;\n    #\n    #+++ \+
use the Murnaghan-Nakayama rules directly without the matrix inversion
\n    #\n    add(1/zee(prt[k])*MurNak(prt[k],prt[i])*p[op(prt[k])],k=1
..nops(prt));\n  end if; \nend proc:\n################################
###############################################\n#\n# s_to_e transform
es a s-function polynomial into elementary symmetric functions.\n#\n# \+
WARNING: SLOW!! Uses the inverse Kostka Matrix\n#          better use \+
the Jacobi-Trudi formula!\n#        \ns_to_eM:=proc(sfkt)\n  option `C
opyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.
`,\n          remember;\n  local prt,N,KI,J,i;\n  N:=`+`(op(sfkt));\n \+
 prt:=PartNM(N,N);\n  J:=linalg[matrix](nops(prt),nops(prt),(i,j)->if \+
nops(prt)+1-i=j then 1 else 0 end if);\n  KI:=evalm(evalm(J &* rhs(Kos
tkaTable(`+`(op(sfkt)))))^(-1));\n  i:=1: while prt[i]<>[op(sfkt)] do \+
i:=i+1 end do;\n  add(KI[j,i]*e[op(prt[j])],j=1..nops(prt));\nend proc
:\ns_to_e:=proc(sfkt)\n  option `Copyright (c) B. Fauser & R. Ablamowi
cz 2004-2009. All rights reserved.`;\n  local n1,prt,cf,term,lst;\n  i
f sfkt=0 then return 0 end if;\n  if sfkt=s[0] then return e[0] end if
;\n  if type(sfkt,`+`) then \n    return map(procname,sfkt)\n  elif ty
pe(sfkt,`*`) then\n    term,cf:=selectremove(type,sfkt,sfktmonom);\n  \+
  return cf*procname(term)\n  else\n    return s_to_eM(sfkt)\n  end if
; \nend proc:\n#\n# s_to_mM basis change from Schur functions to monom
ial symmetric functions\n#\ns_to_mM:=proc(sfkt)\n  option `Copyright (
c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n      \+
   remember;\n  local prt,pt,k;\n  if sfkt=0 then \n    return 0\n  el
if sfkt=s[0] then \n    return m[0];\n  else\n    prt:=PartNM(`+`(op(s
fkt)),`+`(op(sfkt)));\n    add(subs(s[0]=1,Scalar(sfkt,outer(op(map(k-
>s[k],pt)))))*m[op(pt)], pt in prt)\n  end if;\nend proc:\n#\n# s_to_m
 linear basis change from Schur functions to monomial symmetric functi
ons\n#\ns_to_m:=proc(x)\n  option `Copyright (c) B. Fauser & R. Ablamo
wicz 2004-2009. All rights reserved.`;\n  local cf,tm;\n  if type(x,`+
`) then \n    return map(procname,x);\n  elif type(x,`*`) then \n    t
m,cf:=selectremove(type,x,sfktmonom);\n    return expand(cf*procname(t
m))\n  else\n    s_to_mM(x,N);  \n  end if;\nend proc:\n#\n# m_to_sM b
asis change from monomial to Schur functions\n#\nm_to_sM:=proc(mfkt)\n
  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All right
s reserved.`,\n         remember;\n  local prt,pt,k;\n  if mfkt=0 then
 \n    return 0\n  elif mfkt=m[0] then \n    return s[0];\n  else\n   \+
 prt:=PartNM(`+`(op(mfkt)),`+`(op(mfkt)));\n    add(subs(s[0]=1,Scalar
MH(mfkt,s_to_h(s[op(pt)])))*s[op(pt)], pt in prt)\n  end if;\nend proc
:\n#\n# m_to_s linear basis change from monomial to Schur functions\n#
\nm_to_s:=proc(x)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2
004-2009. All rights reserved.`;\n  local cf,tm;\n  if type(x,`+`) the
n \n    return map(procname,x);\n  elif type(x,`*`) then \n    tm,cf:=
selectremove(type,x,mfktmonom);\n    return expand(cf*procname(tm))\n \+
 else\n    m_to_sM(x,N);  \n  end if;\nend proc:\n#\n# p_to_mM is an i
nternal function computing the transition from a power sum monomial\n#
         into a monomial symmetric function. Internal use only.\n#\np_
to_mM:=proc(x)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004
-2009. All rights reserved.`,\n          remember;\n  if x=0 then retu
rn 0 end if;\n  if nops([op(x)])<1 then return m[0] end if;\n  outerM(
seq(m[op([op(x)][k])],k=1..nops([op(x)])))\nend proc:\n#\n# p_to_m lin
ear version of the transformation of power sums into monomial function
s\n#\np_to_m:=proc(pfkt)\n  option `Copyright (c) B. Fauser & R. Ablam
owicz 2004-2009. All rights reserved.`;\n  local cf,term,lst;\n  if ty
pe(pfkt,`+`) then \n    return map(procname,pfkt)\n  elif type(pfkt,`*
`) then\n    term,cf:=selectremove(type,pfkt,pfktmonom);\n    return c
f*procname(term)\n  else\n    p_to_mM(pfkt);\n  end if; \nend proc:\n#
\n# m_to_pM transferes monomial symmetric function basis monoms into p
ower sum symmetric\n#         functions. Internal use only. \n#\n# SLO
W!! This routine uses matrix inversion and not a direct combinatorial \+
algorithm !!! \n#\nm_to_pM:=proc(mfkt)\n  option `Copyright (c) B. Fau
ser & R. Ablamowicz 2004-2009. All rights reserved.`,\n          remem
ber;\n  local nm,np,mat,prt,k;\n  if mfkt=0 then return 0 end if;\n  i
f mfkt=m[0] then return p[0] end if;\n  nm:=`+`(op(mfkt));\n  prt:=Par
tNM(nm,nm);\n  np:=nops(prt);\n  mat:=linalg[matrix](np,np,(i,j)->coef
f(p_to_mM(prt[i]),m[op(prt[j])]));\n  mat:=evalm(mat^(-1));\n  k:=1: w
hile prt[k]<>[op(mfkt)] do k:=k+1; end do:\n  add(mat[k,i]*p[op(prt[i]
)],i=1..nops(prt));\nend proc:\n#\n# m_to_p linear version of the tran
sformation of monomial functions into power sums\n#\nm_to_pMat:=proc(m
fkt)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All
 rights reserved.`;\n  local cf,term,lst;\n  if type(mfkt,`+`) then \n
    return map(procname,mfkt)\n  elif type(mfkt,`*`) then\n    term,cf
:=selectremove(type,mfkt,mfktmonom);\n    return cf*procname(term)\n  \+
else\n    m_to_pM(mfkt);\n  end if; \nend proc:\n#####################
##########################################\n#\n# m_to_p recursive fast
er version\n#\n#######################################################
########\nm_to_p:=proc(x)\n  option `Copyright (c) B. Fauser & R. Abla
mowicz 2004-2009. All rights reserved.`,\n  remember;\n  local term,cf
,y,const;\n  if x=0 then return 0 end if;\n  if x=m[0] then return p[0
] end if;\n  if type(x,`+`) then\n     map(procname,x)\n  elif type(x,
`*`) then\n    term,cf:=selectremove(type,x,mfktmonom);\n    return cf
*procname(term);\n  else\n    y:=p_to_m(x);\n    const:=subs(s[0]=1, S
calarMH(y,h[op(x)]));\n    return p[op(x)]/const+ procname(x-y/const);
\n  end;\nend proc:\n#################################################
################################\n#\n# m_to_hM is the basis change fro
m monomial to complete symmetric functions\n#         it uses the m_to
_p function to evaluate the Scalar product in terms\n#         of poer
 sum symmetric functions\n#\n#########################################
########################################\nm_to_hM:=proc(x)\n  local pr
t,pt;\n  if x=0 then return 0 end if;\n  if x=m[0] then return h[0] en
d if;\n  prt:=[op(PartNM(`+`(op(x)),`+`(op(x))))];\n  add( subs(s[0]=1
, ScalarP( m_to_p(x), m_to_p(m[op(pt)]) ))*h[op(pt)] ,pt in prt);\nend
 proc:\n##############################################################
###################\n#\n# m_to_h is the linear version of m_to_pM basi
s change from monomial to\n#        complete symmetrc functions\n#\n##
######################################################################
#########\nm_to_h:=proc(x)\n  local cf,term;\n  if type(x,`+`) then\n \+
   return map(procname,x);\n  elif type(x,`*`) then\n    term,cf:=sele
ctremove(type,x,mfktmonom);\n    return expand(cf*procname(term));\n  \+
else\n    return m_to_hM(x);\n  end if; \nend proc:\n#\n##############
#################################################\n#\n# m_to_e transfo
rmation from m-bases to p-bases\n#\n##################################
#############################\nm_to_e:=proc(x)\n  option `Copyright (c
) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n  remem
ber;\n  local term,cf,y,const,len,mred;\n  if x=0 then return 0 end if
;\n  if x=m[0] then return e[0] end if;\n  if type(x,`+`) then\n     m
ap(procname,x)\n  elif type(x,`*`) then\n    term,cf:=selectremove(typ
e,x,mfktmonom);\n    return cf*procname(term);\n  else\n    len:=nops(
[op(x)]);\n    mred:=subs(0=NULL,m[ op([op(x)]-[1$len]) ]);\n    if mr
ed=m[] then mred:=m[0] end if;\n    #const:=coeff(outerM(op(map(z->m[o
p(z)],[op(x)]))),m[1$`+`(op(x))]);\n    return outerE( e[len] , procna
me( mred ))\n          - procname( outerM(m[1$len],  mred ) - x);\n  e
nd;\nend proc:\n######################################################
#########\n###########################################################
####\n#\n# makeRimRep is a cast from a partition into a representation
 of a \n#            partition by noting its E-N directions by 1-0 sym
bols\n#            This sequence is infinite having infinit many leadi
ng 0\n#            and traling 1s (which are of course not stored)\n#
\nmakeRimRep:=proc(part)\n   option `Copyright (c) B. Fauser & R. Abla
mowicz 2004-2009. All rights reserved.`\n          ,remember;\n   loca
l n1,diff,res,i;\n   n1:=nops(part);\n   diff:=[part[-1],seq(-part[n1+
1-i]+part[n1-i],i=1..n1-1)];\n   res:=[];\n   for i from 1 to nops(dif
f) do\n      res:=[op(res),seq(1,j=1..diff[i]),0];\n   end do;\n   res
;\nend proc:\n#\n#  removeRimHook removes a rim hook (edgewise conecte
d boundary strip)\n#                of length hocklength in all possib
le ways. It returns \n#                a list with the rimrepresented \+
partitions of the remaining\n#                part of the partition an
d a list with the rimheight attached to\n#                the removed \+
hoocks.\n#\nremoveRimHook:=proc(rimrep,hooklength)\n   option `Copyrig
ht (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n  \+
        remember;\n   local i,j,mult,redrimrep,rimhieght,nrr,tmprim,de
l0,del1;\n   redrimrep:=[];\n   rimhieght:=[];\n   nrr:=nops(rimrep);
\n   for i from 1 to nrr-1 do\n     if rimrep[i]=1 then\n       for j \+
from i+1 to nrr do\n         if rimrep[j]=0 then\n           if j-i=ho
oklength then\n             tmprim:=rimrep;\n             tmprim[i]:=0
;\n             tmprim[j]:=1; \n             redrimrep:=[op(redrimrep)
,tmprim];\n             rimhieght  :=[op(rimhieght),\n                \+
         `+`(op(map(x->if x=0 then 1 else 0 end if,[seq(tmprim[k],k=i+
1..j-1)])))] \n           end if;              \n         end if;  \n \+
      end do;   \n     end if;\n   end do;\n###############\n      del
0:=proc(lst)\n        local flag;\n        flag:=false;\n        map(x
->if x=0 and flag=false then return NULL else flag:=true; return x end
 if,lst); \n      end proc:\n      del1:=proc(lst)\n        local flag
,f,res,i;\n        flag:=false;\n        f:=x->if x=1 and flag=false t
hen return NULL else flag:=true; return x end if;\n        res:=[];\n \+
       for i from nops(lst) to 1 by -1 do\n          res:=[f(lst[i]),o
p(res)];\n        end do; \n      end proc:\n################    \n   \+
map(del0,map(del1,redrimrep)),rimhieght;\nend proc:\n#\n# MurNakRim Th
is is the function which computes the Murnaghan Nakayama rule\n#      \+
     in terms of the rim representation of a shape. It is internal,\n#
           since rim representations of shapes are not supported on th
e user \n#           side of the package.\n#\nMurNakRim:=proc(rimRep,p
art2)\n   option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. A
ll rights reserved.`,\n          remember;\n   local pt1,pt2,lst,sign;
\n   if nops(part2)=1 then\n      lst,sign:=removeRimHook(rimRep,part2
[1]);\n      return add((-1)^i,i=sign);\n   else\n      pt1:=part2[1];
\n      pt2:=part2[2..-1];\n      lst,sign:=removeRimHook(rimRep,pt1);
\n      return add((-1)^sign[i]*procname(lst[i],pt2),i=1..nops(lst));
\n   end if;\nend proc:\n#\n# MurNak This function provides the interf
ace for the function MurNakRim to\n#        compute the Murnaghan-Naka
yama rule. This function returns the character\n#        value of an S
_n character with cycletype part1 on an element of S_n\n#        with \+
cycletype part2.\n#\n# NOTE:  MurNak should be defined as scalar(s[par
t1],p[part2]) which is the\n#        _transpodes_ of the present MurNa
k!\n#\nMurNak:=proc(part1,part2)\n  option `Copyright (c) B. Fauser & \+
R. Ablamowicz 2004-2009. All rights reserved.`,\n          remember;\n
  if `+`(op(part1))<>`+`(op(part2)) then \n    # -- This function is g
raded, for different grades return zero \n    return 0;\n  else\n    #
 -- else use MurNakRim which needs a rim representation in the first a
rgument\n    # -- MurNak is _not_ symmetric in its entries\n    return
 MurNakRim(makeRimRep(part2),part1);\n  end if;\nend proc:\n#\n# CharH
ook compute the character <sfkt,pfkt> if pfkt is a one part partition \+
power\n#          sum. The result is zero unless sfkt=\{a+1,1^b\} is a
 Hook in which case\n#          the value of the character is (-1)^b, \+
the height of the hook (leglength)\n#\nCharHook:=proc(sfkt,pfkt)\n   o
ption `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights r
eserved.`,\n          remember;\n   local spart,ppart,ns,np;\n   spart
:=[op(sfkt)];\n   ppart:=[op(pfkt)];\n   np:=ppart[1];\n   ns:=`+`(op(
spart));\n   if ns<>np then return 0 end if;\n## -- check if s is a ho
ok\n   if spart[1]+nops(spart)-1<>ns then return 0 end if;\n   (-1)^(n
ops(spart)-1);    \nend proc:\n#\n# sq_coeff returns the square of the
 coefficients of a symmetric\n#          function polynomial of a cert
ain type.\n#\n#\nsq_coeff:=proc(x,typ::type)\n  option `Copyright (c) \+
B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;\n  local  \+
lst;\n  if x=0 then \n    return 0\n  elif type(x,`+`) then \n    lst:
=[op(x)];\n  else \n    lst:=[x];\n  end if;\n  lst:=map(x->if type(x,
`*`) then remove(type,x,typ) else 1 end if,lst);\n  add(i^2,i=lst);\ne
nd proc:\n#\n#\n#\n# MurNak2 is a function which as a proof of concept
 shows how the Murnaghan Nakayama\n#         rule can be evaluatedon b
ase of the Littlewood Richardson rule and the\n#         character for
mula on Hook Shapes \\Chi^\\lambda_n=Scalar(s_\\lambda,p[n]). It\n#   \+
      is much slower than the rimRep based function.\n#\n# WARINING: M
urNak2 needs FLAT and MLIN which make functions associative and multil
inear\n#         This should be replaced by a better version of 'defin
e' which specifies not\n#         the base ring, but the types of the \+
generating basis elemnts.\n#\nMurNak2:=proc(sfkt,pfkt)\n   option `Cop
yright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`
\n          ,remember;\n   local spart,ppart,ns,np,sw,CH;\n   spart:=[
op(sfkt)];\n   ppart:=[op(pfkt)];\n#   sw:=proc() T(args[1],args[3],ar
gs[2],args[4]) end proc:\n#   CH:=proc() CharHook(args[1],args[2])*Mur
Nak2(args[3],args[4]) end proc:\n   CH:=(a1,a2,a3,a4) -> CharHook(a1,a
3)*MurNak2(a2,a4): \n   if nops(pfkt)=1 then \n      return CharHook(s
fkt,pfkt);\n   else\n     T(subs(`&t`=T,couter(sfkt)),s[ppart[1]],s[op
(ppart[2..-1])]);\n     FLAT(eval(subs(T=MLIN,%)));\n#     eval(subs(T
=sw,%));\n     eval(subs(T=CH,%));\n   end if;\nend proc:\n###########
#############################\n#\n# dimSN_mon computes the dimension o
f an SN character\n#           according to the hook rule for an Sn ch
aracter\n#           s[lambda] (Schur function monom)\n#           ++ \+
dimSN(s[\\lambda]) = \n#           ++   factorial(|\\lambda|)/\\prod_
\{i,j\} h_ij  where\n#           ++   h_ij is the length of the hook a
t position (i,j)\n#           ++   in the Young diagram of \\lambda \n
#\n#\ndimSN_mon:=proc(x)\n  option `Copyright (c) B. Fauser & R. Ablam
owicz 2004-2009. All rights reserved.`,remember;\n  local part,part_co
nj,np,i,j,hooks;\n  part:=[op(x)];\n  if part=[0] then return 0 end if
;\n  np:=nops(part);\n  part_conj:=conjpart(part);\n  hooks:=1;\n  for
 i from 1 to np do\n  for j from 1 to part[i] do\n     hooks:=hooks *(
 (part[i]-j+1)+max(part_conj[j]-i , 0) );\n  end do;end do;\n  factori
al(`+`(op(part)))/hooks;\nend proc:\n#\n# dimSN is the multilinear ver
sion of simSN_mon\n#\ndimSN:=proc(x)\n  option `Copyright (c) B. Fause
r & R. Ablamowicz 2004-2009. All rights reserved.`;\n  local cf,tm,n1,
plst1,plst2,i;\n  if type(x,`+`) then \n    return map(procname,x,y);
\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,sfktmonom);
\n    return cf*procname(tm,y)\n  else\n    dimSN_mon(x);  \n  end if;
\nend proc:\n#\n# dimSNP gives the dimension of S_n-modules in the \n#
        power sum symmetric function basis\n#\ndimSNP:=proc(x)\n  opti
on `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights rese
rved.`;\n  local cf,tm;\n  if x=0 then return 0 end if;\n  if x=p[0] t
hen return 0 end if;\n  if type(x,`+`) then \n    return map(procname,
x);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,pfktmono
m);\n    return cf*procname(tm)\n  else\n    if `+`(op(x))=nops([op(x)
]) then\n      return `+`(op(x))!;\n    else \n      return 0;\n    en
d if;  \n  end if;\nend proc:\n#\n# dimSNM gives the dimension of S_n-
modules in the \n#        monomial symmetric function basis\n#\ndimSNM
:=proc(x)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009
. All rights reserved.`;\n  local cf,tm;\n  if x=0 then return 0 end i
f;\n  if x=m[0] then return 0 end if;\n  if type(x,`+`) then \n    ret
urn map(procname,x);\n  elif type(x,`*`) then \n    tm,cf:=selectremov
e(type,x,mfktmonom);\n    return cf*procname(tm)\n  else\n    if `+`(o
p(x))=nops([op(x)]) then\n      return 1\n    else \n      return 0;\n
    end if;  \n  end if;\nend proc:\n#\n# dimSNH gives the dimension o
f S_n-modules in the \n#        compleete symmetric function basis\n#
\ndimSNH:=proc(x)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2
004-2009. All rights reserved.`;\n  local cf,tm;\n  if x=0 then return
 0 end if;\n  if x=h[0] then return 0 end if;\n  if type(x,`+`) then \+
\n    return map(procname,x);\n  elif type(x,`*`) then \n    tm,cf:=se
lectremove(type,x,hfktmonom);\n    return cf*procname(tm)\n  else\n   \+
 return combinat:-multinomial(`+`(op(x)),op(x));\n  end if;\nend proc:
\n#\n# dimSNE gives the dimension of S_n-modules in the \n#        ele
mentray symmetric function basis\n#\ndimSNE:=proc(x)\n  option `Copyri
ght (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;\n \+
 local cf,tm;\n  if x=0 then return 0 end if;\n  if x=e[0] then return
 0 end if;\n  if type(x,`+`) then \n    return map(procname,x);\n  eli
f type(x,`*`) then \n    tm,cf:=selectremove(type,x,efktmonom);\n    r
eturn cf*procname(tm)\n  else\n    return combinat:-multinomial(`+`(op
(x)),op(x));\n  end if;\nend proc:\n##################################
######\n#\n# dimGL_mon computes the dimension of an GL(N) character\n#
           according to the hook rule for an Sn character\n#          \+
 s[lambda] (Schur function monom)\n#           ++ dimGL(s[\\lambda],N)
 = \n#           ++   content/\\prod_\{i,j\} h_ij  where\n#           \+
++   h_ij is the length of the hook at position (i,j)\n#           ++ \+
  in the Young diagram of \\lambda,\n#           ++   content is the p
roduct of the content of the \n#           ++   boxes x(i,j)=N-i+j  (i
,j = row,column) and N the dim\n#           ++ of the vectorspace unde
rlying GL(N) \n#\n#\ndimGL_mon:=proc(x,N)\n  option `Copyright (c) B. \+
Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,remember;\n  l
ocal part,part_conj,np,i,j,hooks,content;\n  part:=[op(x)];\n  if part
=[0] then return 1 end if;\n  np:=nops(part);\n  part_conj:=conjpart(p
art);\n  hooks:=1;\n  content:=1;\n  for i from 1 to np do\n  for j fr
om 1 to part[i] do\n     hooks:=hooks *( (part[i]-j+1)+max(part_conj[j
]-i , 0) );\n     content:=content*(N-i+j);\n  end do;end do;\n  conte
nt/hooks;\nend proc:\n#\n# dimGL is the multilinear version of dimGL_m
on\n#\ndimGL:=proc(x,N)\n  option `Copyright (c) B. Fauser & R. Ablamo
wicz 2004-2009. All rights reserved.`;\n  local cf,tm,n1,plst1,plst2,i
;\n  if type(x,`+`) then \n    return map(procname,x,N);\n  elif type(
x,`*`) then \n    tm,cf:=selectremove(type,x,sfktmonom);\n    return c
f*procname(tm,N)\n  else\n    dimGL_mon(x,N);  \n  end if;\nend proc:
\n################################################\n#\n# dimGLP_mon gi
ves the dimension of a monomial representing a module in the \n#      \+
  power sum symmetric function basis\n#\n#\ndimGLP_mon:=proc(pfkt,N)\n
  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All right
s reserved.`;\n  if pfkt=0 then \n    return 0\n  elif pfkt=p[0] then \+
\n    return 1\n  else\n    N^(nops([op(pfkt)]));\n  end if;\nend proc
:\n#\n# dimGLP gives the dimension of a sum of GL-modules in the \n#  \+
      power sum symmetric function basis\n#\ndimGLP:=proc(x,N)\n  opti
on `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights rese
rved.`;\n  local cf,tm;\n  if x=0 then return 0 end if;\n  if x=p[0] t
hen return 1 end if;\n  if type(x,`+`) then \n    return map(procname,
x,N);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,pfktmo
nom);\n    return cf*procname(tm,N)\n  else\n    dimGLP_mon(x,N);  \n \+
 end if;\nend proc:\n#\n# dimGLM gives the dimension of a sum of GL-mo
dules in the \n#        monomial symmetric function basis\n#\ndimGLM:=
proc(x,N)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009
. All rights reserved.`;\n  local cf,tm;\n  if x=0 then return 0 end i
f;\n  if x=m[0] then return 1 end if;\n  if type(x,`+`) then \n    ret
urn map(procname,x,N);\n  elif type(x,`*`) then \n    tm,cf:=selectrem
ove(type,x,mfktmonom);\n    return cf*procname(tm,N)\n  else\n    fact
or(1/(`*`(op(map(x->x!,part2mset([op(x)])))))*fallingFactorial(N,nops(
[op(x)])));\n  end if;\nend proc:\n#\n# dimGLH gives the dimension of \+
a sum of GL-modules in the \n#        compleete symmetric function bas
is\n#\ndimGLH:=proc(x,N)\n  option `Copyright (c) B. Fauser & R. Ablam
owicz 2004-2009. All rights reserved.`;\n  local cf,tm;\n  if x=0 then
 return 0 end if;\n  if x=h[0] then return 1 end if;\n  if type(x,`+`)
 then \n    return map(procname,x,N);\n  elif type(x,`*`) then \n    t
m,cf:=selectremove(type,x,hfktmonom);\n    return cf*procname(tm,N)\n \+
 else\n    factor(1/(`*`(op(map(x->x!,[op(x)])))) * `*`(op(map2(rising
Factorial,N,[op(x)]))));\n end if;\nend proc:\n#\n# dimGLE gives the d
imension of a sum of GL-modules in the \n#        elementray symmetric
 function basis\n#\ndimGLE:=proc(x,N)\n  option `Copyright (c) B. Faus
er & R. Ablamowicz 2004-2009. All rights reserved.`;\n  local cf,tm;\n
  if x=0 then return 0 end if;\n  if x=e[0] then return 1 end if;\n  i
f type(x,`+`) then \n    return map(procname,x,N);\n  elif type(x,`*`)
 then \n    tm,cf:=selectremove(type,x,efktmonom);\n    return cf*proc
name(tm,N)\n  else\n    factor(1/(`*`(op(map(x->x!,[op(x)])))) * `*`(o
p(map2(fallingFactorial,N,[op(x)]))));\n end if;\nend proc:\n#########
######################################################################
\n#\n# G E S S E L T H E T A functions\n#\n###########################
####################################################\n#\n# GesselTheta
 is the Gessel map from a polynomial ring in infinitley many\n#     (f
initely many) variables 'u1,u2,u3,...' into a polynomial ring\n#     i
n one variable 'z', say. The map is ussefull for counting purpose and
\n#     defined as follows:\n#\n# -- i)   \\Theta(1) = 1\n# -- ii)  \\
Theta(p_n(u)) = z if n=1 else 0\n#\n#     we have therefore for S-func
tiuons\n#\n# -- iii) \\Theta(s_\\lambda(u)) = f^\\lambda z^(|\\lambda|
) / (|\\lambda|)!\n#\n#    where |\\lambda| is the weight of a partiti
on lambda and\n#    f^\\lambda is the number of standard Young tableau
 of shape\n#    \\lambda i.e. SYT(\\lambda)=dimSN(s[\\lambda](u))\n#\n
######################################################################
#########\n#\n# GesselThetaP_mon is the theta function given for power
 sum monomials\n#\nGesselThetaP_mon:=proc(x,var)\n  option `Copyright \+
(c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n  rem
eber;\n  local n;\n  if (x=p[0] or x=1) then return 1 end if;\n  n:=no
ps([op(x)]);\n  if n=`+`(op(x)) then var^n else 0 end if;\nend proc:\n
#\n# GesselThetaP is the linear version for the Gessel map theta for \+
\n#              power sum polynomials\n#\nGesselThetaP:=proc(x,var)\n
  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All right
s reserved.`;\n  local cf,tm;\n  if type(x,`+`) then \n    return map(
procname,x,var);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(ty
pe,x,pfktmonom);\n    return cf*GesselThetaP_mon(tm,var)\n  else\n    \+
GesselThetaP_mon(x,var);  \n  end if;\nend proc:\n#\n# GesselThetaS_mo
n is the theta function given for Schur function monomials\n#\nGesselT
hetaS_mon:=proc(x,var)\n  option `Copyright (c) B. Fauser & R. Ablamow
icz 2004-2009. All rights reserved.`,\n  remeber;\n  local N;\n  if (x
=s[0] or x=1) then return 1 end if;\n  N:=`+`(op(x));\n  dimSN(x)*var^
N/factorial(N); \nend proc:\n#\n# GesselThetaS is the linear version f
or the Gessel map theta for \n#              Schur function polynomial
s\n#\nGesselThetaS:=proc(x,var)\n  option `Copyright (c) B. Fauser & R
. Ablamowicz 2004-2009. All rights reserved.`;\n  local cf,tm;\n  if t
ype(x,`+`) then \n    return map(procname,x,var);\n  elif type(x,`*`) \+
then \n    tm,cf:=selectremove(type,x,sfktmonom);\n    return cf*Gesse
lThetaS_mon(tm,var)\n  else\n    GesselThetaS_mon(x,var);  \n  end if;
\nend proc:\n\n########################################\n#\n# Function
s for s-functions\n#\n########################################\n\n\n##
######################################################################
########\n#\n# S C A L A R PRODUCTS\n#\n#     for different bases\n#\n
######################################################################
##########\n#\n# +++ scalar product of schur functions\n#\nScalar:=pro
c(x,y)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. A
ll rights reserved.`;\n  local cf,tm,p1,p2;\n  if x=0 or y=0 then retu
rn 0 end if;\n  if not (type(x,sfktpolynom) and type(y,sfktpolynom)) t
hen error \"wrong type\\n\" end if;\n  if type(x,`+`) then \n    retur
n map(procname,x,y);\n  elif type(x,`*`) then \n    tm,cf:=selectremov
e(type,x,sfktmonom);\n    return cf*procname(tm,y)\n  else\n    if typ
e(y,`+`) then \n      return map2(procname,x,y);\n    elif type(y,`*`)
 then\n      tm,cf:=selectremove(type,y,sfktmonom);\n      return cf*p
rocname(x,tm)\n    else\n      p1:=getPart(x):p2:=getPart(y):\n      i
f   nops(p1)<nops(p2) then p1:=[op(p1),0$(nops(p2)-nops(p1))];\n      \+
elif nops(p1)>nops(p2) then p2:=[op(p2),0$(nops(p1)-nops(p2))];\n     \+
 end if;\n      if \{op(zip((i,j)->i-j,p1,p2))\}=\{0\} then return s[0
] else return 0 end if;\n    end if;\n  end if;\nend proc:\n##########
######################################################################
#####\n#\n# ScalarP is the Schur-Hall scalar product on power sum func
tions\n#\nScalarP:=proc(x,y)\n  option `Copyright (c) B. Fauser & R. A
blamowicz 2004-2009. All rights reserved.`;\n  local cf,tm,p1,p2;\n  i
f not (type(x,pfktpolynom) and type(y,pfktpolynom)) then error \"wrong
 type\\n\" end if;\n  if type(x,`+`) then \n    return map(procname,x,
y);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,pfktmono
m);\n    return cf*procname(tm,y)\n  else\n    if type(y,`+`) then \n \+
     return map2(procname,x,y);\n    elif type(y,`*`) then\n      tm,c
f:=selectremove(type,y,pfktmonom);\n      return cf*procname(x,tm)\n  \+
  else\n      ###\n      p1:=[op(x)];\n      p2:=[op(y)];\n      if `+
`(op(p1))<>`+`(op(p2)) then return 0 end if;\n      if \{op(zip((x,y)-
>x-y,p1,p2))\}=\{0\} then \n        return zee(p1) \n      end if;\n  \+
    0;\n      ### \n    end if;\n  end if;\nend proc:\n###############
###################################################################\n#
\n# ScalarMH is the Schur-Hall scalar product for the dual pair of com
plete symmetric \n#          functions and monomial symmetric function
s. Alias is ScalarHM\n#\n#\nScalarMH:=proc(x,y)\n   option `Copyright \+
(c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved`;\n   if \+
x=0 or y=0 then return 0 end if;\n   if type(x,mfktpolynom) and type(y
,hfktpolynom) then \n      return Scalar(subs(`m`=s,x),subs(`h`=s,y)) \+
end if;\n      if type(x,hfktpolynom) and type(y,mfktpolynom) then \n \+
     return Scalar(subs(`h`=s,x),subs(`m`=s,y)) end if;\n   error \"un
known type in ScalarHM\";\nend proc:\nScalarHM:=(x,y)->ScalarMH(y,x);
\n####################################################################
#################\n#\n# O U T E R MONOID\n#\n#########################
############################################################\n#\n#\n# \+
outer product for S functions, this is the default proceedure, alias i
s outerS\n#\nouter:=proc(x)\n  option `Copyright (c) B. Fauser & R. Ab
lamowicz 2004-2009. All rights reserved.`;\n  local cf,tm,p1,p2,y;\n  \+
if nargs=1 then return x end if;\n  y:=args[2];\n  if x=0 or y=0 then \+
return 0 end if;\n  if nargs>2 then return procname(expand(procname(x,
y)),args[3..-1]) end if;\n  if not(type(x,sfktpolynom) and type(args[2
],sfktpolynom)) then error \"wrong type\\n\" end if;\n  if type(x,`+`)
 then \n    return map(procname,x,y);\n  elif type(x,`*`) then \n    t
m,cf:=selectremove(type,x,sfktmonom);\n    return cf*procname(tm,y)\n \+
 else\n    if type(y,`+`) then \n      return map2(procname,x,y);\n   \+
 elif type(y,`*`) then\n      tm,cf:=selectremove(type,y,sfktmonom);\n
      return cf*procname(x,tm)\n    else\n      if x=0 or y=0 then ret
urn 0 end if;\n      p1:=getPart(x): p2:=getPart(y):\n# +++ it is fast
er to add fewer boxes\n# --- the product is symmetric\n      if `+`(op
(p1))<`+`(op(p2)) then \n        return LRR(p2,p1);\n      else\n     \+
   return LRR(p1,p2);\n      end if;\n    end if;\n  end if;\nend proc
:\n#\n# +++ alias for outer product in Schur function basis\n#\nouterS
:=outer:\n#\n#\n# outerLS computes the product of two or any number of
 Schur functions [monoms]\n#     using the Lascoux Schuetzenberger tra
nsition algorithm. after some checking\n#     of the input for invalid
 or special input, we produce the permutation\n#     which is isomorph
ic to the concatenation of the Lehmer codes od the\n#     input Schur \+
functions. The transition algorithm descomposes this\n#     permutatio
n into Grassmannian ones which are turned byck into Schur functions\n#
     and then added up for output.\n#\nouterLS:=proc(x)\n  local perLs
t,res,res2,per,i,nopsD;\n  #-- nothing to do\n  if nargs=1 then return
 x end if;\n  #-- concattenate the Lehmer codes of inputs and turn int
o a permutation\n  perLst:= [ lehmerCodeToPermutation( op([ map(op@sch
urToLehmerCode1,[args])])) ];\n  nopsD:=nops(Descents(op(perLst)));\n \+
 #-- deal with special cases 0 descest output s[0], \n  #-- 1 descent=
Grassmannian permutation = Schur function\n  if nopsD=0 then \n     re
turn s[0]\n  elif nopsD=1 then \n     return lehmerCodeToSchurFkt(perm
utationToLehmerCode(op(perLst)))\n  end if;\n  # start computation: fo
r all permutations in perlst applay the\n  # transition algorithm (pos
sibly increasing the length of the list)\n  # If the number of descent
s for a permutatin is 1 add to result\n  # othewise feed back to perLs
t\n  res:=0;\n  while perLst<>[] do\n    per:=perLst[1];\n    perLst:=
perLst[2..-1];\n    res2:=transition(per);\n    for i from 1 to nops(r
es2) do \n       if nops(Descents(res2[i]))=1 then \n          res:=re
s+lehmerCodeToSchurFkt(permutationToLehmerCode(res2[i]));\n       else
\n          perLst:=[res2[i],op(perLst)];\n       end if;\n    end do;
\n  end do;  \n  res;\nend proc:\n#\n#\n# concatM_mon multiplies two m
onomials (mfktmonom) using the divided power representation of \n#    \+
         Rota-Stein 94\n# WARNING:    this is _not_ the outer product \+
of symmetric functions, but a concatenation \n#             product in
 a divided powers algebra!\n#\n#             (Internal use only)\n#\nc
oncatM_mon:=proc(fkt1,fkt2)\n   option `Copyright (c) B. Fauser & R. A
blamowicz 2004-2009. All rights reserved.`,\n   remember;\n   local ms
et1,mset2,n1,n2,N,lst,cf,res,i;\n   if fkt1=0 or fkt2=0 then return 0 \+
end if;\n   mset1,mset2:=part2mset([op(fkt1)]),part2mset([op(fkt2)]);
\n   n1,n2:=nops(mset1),nops(mset2);\n   if n1>n2 then\n     N:=n1;\n \+
    mset2:=[op(mset2),0$(n1-n2)];\n   elif n2>n1 then\n     N:=n2;\n  \+
   mset1:=[op(mset1),0$(n2-n1)];\n   else\n     N:=n1;\n   end if;\n  \+
 lst:=[seq([binomial(mset1[i]+mset2[i],mset1[i]),mset1[i]+mset2[i]] ,i
=1..N)];\n   cf,res:=1,[];\n   for i in lst do\n     cf:=cf*i[1];\n   \+
  res:=[op(res),i[2]];\n   end do;   \n   cf*m[op(mset2part(res))];\ne
nd proc:\n#\n# concatM provides the concatemation product of m-functio
ns (not the outer product of \n#         symmetric functions!) This pr
oduct is needed to produce a 'clifford' type\n#         product for th
e outer m-function product\n#\n#\nconcatM:=proc(x)\n  option `Copyrigh
t (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n  r
emember;\n  local cf,tm,p1,p2,y;\n  if nargs=1 then return x end if;\n
  y:=args[2];\n  if x=0 or y=0 then return 0 end if;\n  if nargs>2 the
n return procname(expand(procname(x,y)),args[3..-1]) end if;\n  if not
(type(x,mfktpolynom) and type(args[2],mfktpolynom)) then error \"wrong
 type\\n\" end if;\n  if type(x,`+`) then \n    return map(procname,x,
y);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,mfktmono
m);\n    return cf*procname(tm,y)\n  else\n    if type(y,`+`) then \n \+
     return map2(procname,x,y);\n    elif type(y,`*`) then\n      tm,c
f:=selectremove(type,y,mfktmonom);\n      return cf*procname(x,tm)\n  \+
  else\n      if x=0 or y=0 then return 0 end if;\n      concatM_mon(x
,y)\n    end if;\n  end if;\nend proc:\n#\n#\n# concat_mon multiplies \+
two monomials (e-, h-, p-function monoms) \n#            This _is_ the
 outer product! for these bases \n#\n#             (Internal use only)
\n#\nconcat_mon:=proc(fkt1,fkt2,name)\n   option `Copyright (c) B. Fau
ser & R. Ablamowicz 2004-2009. All rights reserved.`,\n   remember;\n \+
  local lst;\n   lst:=[op(fkt1),op(fkt2)];\n   name[op(sort(lst,(i,j)-
>if i>j then true else false end if))];\nend proc:\n#\n# outerH,E,P ar
e functions providing the outer product of complete, elementary and po
wer sum\n#         symmetric functions. These products are the outer p
roducts on these bases, since\n#         these particular bases are mu
ltiplicateive bases.\n#\n#\nouterH:=proc(x)\n  option `Copyright (c) B
. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n  remember
;\n  local cf,tm,p1,p2,y;\n  if nargs=1 then return x end if;\n  y:=ar
gs[2];\n  if x=0 or y=0 then return 0 end if;\n  if nargs>2 then retur
n procname(expand(procname(x,y)),args[3..-1]) end if;\n  if not(type(x
,hfktpolynom) and type(y,hfktpolynom)) then error \"wrong type\\n\" en
d if;\n  if type(x,`+`) then \n    return map(procname,x,y);\n  elif t
ype(x,`*`) then \n    tm,cf:=selectremove(type,x,hfktmonom);\n    retu
rn cf*procname(tm,y)\n  else\n    if type(y,`+`) then \n      return m
ap2(procname,x,y);\n    elif type(y,`*`) then\n      tm,cf:=selectremo
ve(type,y,hfktmonom);\n      return cf*procname(x,tm)\n    else\n     \+
 if x=0 or y=0 then return 0 end if;\n      if x=h[0] then return y en
d if;\n      if y=h[0] then return x end if;\n      concat_mon(x,y,`h`
)\n    end if;\n  end if;\nend proc:\n#\n#\n#\nouterE:=proc(x)\n  opti
on `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights rese
rved.`,\n  remember;\n  local cf,tm,p1,p2,y;\n  if nargs=1 then return
 x end if;\n  y:=args[2];\n  if x=0 or y=0 then return 0 end if;\n  if
 nargs>2 then return procname(expand(procname(x,y)),args[3..-1]) end i
f;\n  if not(type(x,efktpolynom) and type(args[2],efktpolynom)) then e
rror \"wrong type\\n\" end if;\n  if type(x,`+`) then \n    return map
(procname,x,y);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(typ
e,x,efktmonom);\n    return cf*procname(tm,y)\n  else\n    if type(y,`
+`) then \n      return map2(procname,x,y);\n    elif type(y,`*`) then
\n      tm,cf:=selectremove(type,y,efktmonom);\n      return cf*procna
me(x,tm)\n    else\n      if x=0 or y=0 then return 0 end if;\n      i
f x=e[0] then return y end if;\n      if y=e[0] then return x end if;
\n      concat_mon(x,y,`e`)\n    end if;\n  end if;\nend proc:\n#\n#\n
#\nouterP:=proc(x)\n  option `Copyright (c) B. Fauser & R. Ablamowicz \+
2004-2009. All rights reserved.`,\n  remember;\n  local cf,tm,p1,p2,y;
\n  if nargs=1 then return x end if;\n  y:=args[2];\n  if x=0 or y=0 t
hen return 0 end if;\n  if nargs>2 then return procname(expand(procnam
e(x,y)),args[3..-1]) end if;\n  if not(type(x,pfktpolynom) and type(ar
gs[2],pfktpolynom)) then error \"wrong type\\n\" end if;\n  if type(x,
`+`) then \n    return map(procname,x,y);\n  elif type(x,`*`) then \n \+
   tm,cf:=selectremove(type,x,pfktmonom);\n    return cf*procname(tm,y
)\n  else\n    if type(y,`+`) then \n      return map2(procname,x,y);
\n    elif type(y,`*`) then\n      tm,cf:=selectremove(type,y,pfktmono
m);\n      return cf*procname(x,tm)\n    else\n      if x=0 or y=0 the
n return 0 end if;\n      if x=p[0] then return y end if;\n      if y=
p[0] then return x end if;\n      concat_mon(x,y,`p`)\n    end if;\n  \+
end if;\nend proc:\n##################################################
######################################\n#\n# O U T E R COMONOID\n#\n#
\n####################################################################
####################\n#\n# couterM_mon computes the outer coproduct of
 the m-basis m-functions\n#\n# (Internal use only)\n#\ncouterM_mon:=pr
oc(mfkt)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009.
 All rights reserved.`,\n  remember;\n  local mset,T,res,nT;\n  if mfk
t=0 then return(0) end if;\n  mset:=part2mset([op(mfkt)]);\n  T:=combi
nat[cartprod]([seq([seq(k,k=0..mset[i])],i=1..nops(mset))]):\n  res:=[
];\n  while not T[finished] do\n    nT:=T[nextvalue](); \n    res:=[op
(res),[mset-nT,nT]] \n  end do;\n  add(&t(m[op(mset2part(i[1]))],m[op(
mset2part(i[2]))]),i=res);\nend proc:\n#\n#\n# couterM computes the ou
ter coproduct in the m-basis. This is essentially a wrapper\n#        \+
 function for couterM_mon on monomials, making it multilinear over the
\n#         integers.\n#\n#\ncouterM:=proc(x)\n  option `Copyright (c)
 B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n  rememb
er;\n  local cf,tm,n1,plst1,plst2,i;\n  if x=0 then return(0) end if;
\n  if type(x,`+`) then \n    return map(procname,x,y);\n  elif type(x
,`*`) then \n    tm,cf:=selectremove(type,x,mfktmonom);\n    return cf
*procname(tm,y)\n  else\n    if x=m[0] then return &t(m[0],m[0]) end i
f;\n    couterM_mon(x);  \n  end if;\nend proc:\n#\n# LaplaceMset is a
 internal function which implements the Laplace Pairing of Rota-Stein
\n#             in tha case of monomial symmetric functions. For effic
iency reasons, it\n#             uses a third representation of sparse
-multisets M(\\prod_k [i_k,ni_k])\n#             where the zero entrie
s [n,0] are omitted! \n#\n#\nLaplaceMset:=proc(Mset1,Mset2)\n  option \+
`Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserve
d.`,\n  remember;\n  local n1,n2,T,nT,res,a,b,c,d;\n  n1,n2:=nops(Mset
1),nops(Mset2);\n  # -- check for m[0]=1 cases directly\n  if n1=0 and
 n2=0 then return M() end if;\n  if n1=0 or n2=0 then return 0 end if;
\n  if n1=1 then\n    if n2=1 then\n      # -- case n1=n2=1 definition
 applies directly\n      if op(Mset1)[2]=op(Mset2)[2] then \n        r
eturn M([op(Mset1)[1]+op(Mset2)[1],op(Mset1)[2]]);\n      else\n      \+
  return 0;\n      end if; \n    else\n      # --n1=1, n2 a product\n \+
     return add(MCAT(\n                      procname( M([ op(Mset1)[1
] , k ]) , M( op(Mset2)[1] ) )\n                     ,procname( M([ op
(Mset1)[1] , op(Mset1)[2]-k ]), M( op(Mset2)[2..-1] ) )   \n          \+
           )\n                ,k=0..op(Mset1)[2] );\n    end if;\n  el
se\n    # -- n1 a product\n    if n2=1 then\n      # -- n2 not a produ
ct\n      return add(MCAT(\n                      procname( M([ op(Mse
t2)[1] , k ]) , M( op(Mset1)[1] ) )\n                     ,procname( M
([ op(Mset2)[1] , op(Mset2)[2]-k ]), M( op(Mset1)[2..-1] ) )\n        \+
             )\n                ,k=0..op(Mset2)[2] );\n    else\n     \+
 # -- n1 and n2 products, expand second argument ...\n      a,b:=M([op
(Mset1)][1]),M(op([op(Mset1)][2..-1]));\n      c:=[seq([op(Mset2)][i][
1],i=1..nops([op(Mset2)]))];\n      d:=[seq([op(Mset2)][i][2],i=1..nop
s([op(Mset2)]))];\n      T:=combinat[cartprod]([seq([seq(k,k=0..[op(Ms
et2)][i][2])],i=1..nops([op(Mset2)]))]):\n      res:=[];\n      while \+
not T[finished] do\n        nT:=T[nextvalue](); \n        res:=[op(res
),[d-nT,nT]] \n      end do;\n      add(MCAT(\n               procname
(a,M(seq([c[k],i[1][k]],k=1..nops(c)) ))\n              ,procname(b,M(
seq([c[k],i[2][k]],k=1..nops(c)) ))\n              )\n          ,i=res
);\n    end if;\n  end if;\nend proc:\n#\n# LaplaceM_mon is the wrappe
r function for LaplaceMset and computes the Laplace pairing\n#        \+
  between two _monomials_ in the monoamial symmetric function basis. U
nless\n#          it is bilinear it is for internal use in the outerM \+
product mainly.\n#\n#\nLaplaceM_mon:=proc(mfkt1,mfkt2)\n   option `Cop
yright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,
\n   remember;\n   local mset1,mset2,f;\n# -- SPECIAL CASES\n# -- Lapl
aceM is _not_ graded, by weight of the partitions of the mfkt's\n# -- \+
However, LaplaceM _is graded_ by the _length_ of the partitions!!\n# -
- The case m[0] is crittical since part2mset does return an empty list
\n# -- we deal hence with these cases seperately:\n# -- LaplaceM(m[0],
m[0])=m[0]\n# -- LaplaceM(m[0],<any-mfkt>) = 0 = LaplaceM(<any-mfkt>,m
[0])\n   if nops([op(mfkt1)])<>nops([op(mfkt2)]) then return 0 end if;
\n   if mfkt1=m[0] and mfkt2=m[0] then return m[0] end if;\n   if mfkt
1=m[0] or mfkt2=m[0] then return 0 end if;\n# -- transform partitions \+
into msets M([i1,ni1],[i2,ni2],...)\n   mset1,mset2:=part2mset([op(mfk
t1)]),part2mset([op(mfkt2)]);\n# -- f is a helper function which turns
 M-set representations back into\n# -- a partition representation\n   \+
f:=proc()\n      local x,n;\n      x,n:=args,nargs;\n      m[op( sort(
[seq([x][k][1]$[x][k][2],k=1..n)]) )];\n   end proc:\n# -- call the ac
tual LaplaceMset proceedure\n   LaplaceMset(M(seq([k,mset1[k]],k=1..no
ps(mset1))),M(seq([k,mset2[k]],k=1..nops(mset2))));\n# -- Turn the M-s
et representation output of LaplaceMset into a partition based form\n \+
  eval(subs(M=f,%));\n# -- substitute the unevaluated concatenation pr
oduct MCAT into the actual concatM product\n# -- and return the final \+
result \n   eval(subs(MCAT=concatM,%));\nend proc:\n#\n# The wrapper w
hich makes LaplaceM_mon multilinear\n#\nLaplaceM2:=proc(x,y)\n  option
 `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserv
ed.`;\n  local cf,tm,p1,p2;\n  if x=0 or y=0 then return 0 end if;\n  \+
if not (type(x,mfktpolynom) and type(y,mfktpolynom)) then error \"wron
g type\\n\" end if;\n  if type(x,`+`) then \n    return map(procname,x
,y);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,mfktmon
om);\n    return cf*procname(tm,y)\n  else\n    if type(y,`+`) then \n
      return map2(procname,x,y);\n    elif type(y,`*`) then\n      tm,
cf:=selectremove(type,y,mfktmonom);\n      return cf*procname(x,tm)\n \+
   else\n#      if x=m[0] then return y end if;\n#      if y=m[0] then
 return x end if;\n      LaplaceM_mon(x,y);\n    end if;\n  end if;\ne
nd proc:\n############################################################
########################\n#\n# Laplace helper functions:\n#\n# -------
----------------------------------------------------------------------
-----\n#\n# LP_l1 computes the LaplaceM pairing for monomials of lengt
h < 2\n# \nLP_l1:=proc(x,y)\n  option remember;\n  if x=m[0] or y=m[0]
 then\n    if y=x then\n      return m[0]\n    else \n      return 0\n
    end if;\n  end if;\n  return m[op(x)+op(y)];\nend proc:\n#\n# cout
erMproper1n computes the proper coproduct slice of length 1,n where\n#
                 the original monomial has length n+1\n#\ncouterMprope
r1n:=proc(x)\n  option remember;\n  local lst,mset;\n  if x=0 then ret
urn 0 end if;\n  if x=m[0] then return &t(m[0],m[0]) end if;\n  lst:=
\{op(x)\};\n  mset:=part2mset([op(x)]);\n  add(&t(m[i],m[op( mset2part
(mset-[0$(i-1),1,0$(nops(mset)-i)]))]) ,i in lst);\nend proc:\n#\n# LP
_mon is the actual LaplaceM pairing evaluated on arbitrary m-basis mon
omials\n#        LP_mon is faster and more memory efficient than the o
ld algorithm. It was \n#        seriously tested against the old routi
ne.\n#\nLP_mon:=proc(x,y)\n  option remember;\n  local lx,ly,f0,beta,r
es;\n  lx,ly:=nops([op(x)]),nops([op(y)]);\n  if lx<>ly then return 0 \+
end if;\n  if lx<2 then return LP_l1(x,y) end if;\n  # -- the Laplace \+
property (due to the length constraint we need only one direction)\n  \+
# -- we split of a single entry in the second fcator\n  # -- the copro
duct needs only terms of the length type 1,n, this is provided by\n  #
 -- the function couterMproper1n\n  # -- beta is a numerical factor ne
eded to split m-basis monomials into a\n  # -- concatenation product o
f two parts : concatM(A,B)/beta(C) = C\n  beta:=coeff(concatM(m[[op(y)
][1]], m[op([op(y)][2..-1])]),y);\n  f0:=(a,b,c,d)->concatM(LP_mon(a,c
),LP_mon(b,d));\n  eval(1/beta*subs(`&t`=f0, \n     &t( couterMproper1
n(x),  m[[op(y)][1]], m[op([op(y)][2..-1])] )\n  ));   \nend proc:\n#
\n# The wrapper which makes LaplaceM_mon multilinear\n#\nLaplaceM:=pro
c(x,y)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. A
ll rights reserved.`;\n  local cf,tm,p1,p2;\n  if x=0 or y=0 then retu
rn 0 end if;\n  if not (type(x,mfktpolynom) and type(y,mfktpolynom)) t
hen error \"wrong type\\n\" end if;\n  if type(x,`+`) then \n    retur
n map(procname,x,y);\n  elif type(x,`*`) then \n    tm,cf:=selectremov
e(type,x,mfktmonom);\n    return cf*procname(tm,y)\n  else\n    if typ
e(y,`+`) then \n      return map2(procname,x,y);\n    elif type(y,`*`)
 then\n      tm,cf:=selectremove(type,y,mfktmonom);\n      return cf*p
rocname(x,tm)\n    else\n      LP_mon(x,y);\n    end if;\n  end if;\ne
nd proc:\n#\n# outerM the cliffordization of the concatM product, the \+
outer product in the monomial\n#        symmetric function basis. This
 function takes 1,2, or n variables (associactive)\n#        and is mu
ltilinear over the integers / fractions.\n#\n#\nouterM:=proc(x)\n  opt
ion `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights res
erved.`,\n  remember;\n  local cf,tm,p1,p2,y,f;\n  if nargs=1 then ret
urn x end if;\n  y:=args[2];\n  if x=0 or y=0 then return 0 end if;\n \+
 if nargs>2 then return procname(expand(procname(x,y)),args[3..-1]) en
d if;\n  if not(type(x,mfktpolynom) and type(args[2],mfktpolynom)) the
n error \"wrong type\\n\" end if;\n  if type(x,`+`) then \n    return \+
map(procname,x,y);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(
type,x,mfktmonom);\n    return cf*procname(tm,y)\n  else\n    if type(
y,`+`) then \n      return map2(procname,x,y);\n    elif type(y,`*`) t
hen\n      tm,cf:=selectremove(type,y,mfktmonom);\n      return cf*pro
cname(x,tm)\n    else\n      if x=0 or y=0 then return 0 end if;\n    \+
  f:=(a,b,c,d)->concatM(LaplaceM_mon(a,c),concatM_mon(b,d));\n      ev
al(subs(`&t`=f,&t(couterM(x),couterM(y))));\n    end if;\n  end if;\ne
nd proc:\n############################################################
############################\n#\n# A D J O I N T OPERATIONS / SKEWS\n#
\n####################################################################
####################\n#\n#  +++ skew shur functions\n#\n#  skewLR comp
utes the skew operation by dualiting the outer product based\n#     on
 the Littlewood-Richarson rule, this is slow and ineefective, see skew
LS below\n#\nskewLR:=proc(x,y)\n  option `Copyright (c) B. Fauser & R.
 Ablamowicz 2004-2009. All rights reserved.`;\n  local cf,tm,n1,n2,n3,
plst;\n  if y=s[0] then return x; end if;\n  if type(x,`+`) then \n   \+
 return map(procname,x,y);\n  elif type(x,`*`) then \n    tm,cf:=selec
tremove(type,x,sfktmonom);\n    return cf*procname(tm,y)\n  else\n    \+
if type(y,`+`) then \n      return map2(procname,x,y);\n    elif type(
y,`*`) then\n      tm,cf:=selectremove(type,y,sfktmonom);\n      retur
n cf*procname(x,tm)\n    else\n      n1:=`+`(op(getPart(x))):n2:=`+`(o
p(getPart(y))):\n      n3:=n1-n2;\n      if n3<0 then return 0 \n     \+
 elif n3=0 then return Scalar(x,y) \n      else\n        plst:=map(x->
s[op(x)],[op(PartNM(n3,n3))]);\n        return add(outer(Scalar(x,oute
r(y,z)),z),z=plst);\n      end if;\n    end if;\n  end if;\nend proc:
\n#\n# skewLS computes the skew using the Lascoux Schuetzenberger tran
sition algorithm\n#     this is by fare the faster skew operation then
 the above one obtained by \n#     duality and is therefore set as def
ault\n#\nskewLS:=proc(sf1,sf2)\n  local perLst,res,res2,per,i,nopsD;\n
  #-- sf2=s[0] then nothing to do\n  if sf2=s[0] then return sf1 end i
f;\n  #-- check if sf1 covers sf2, otherwise zero\n  if nops([op(sf1)]
)<nops([op(sf2)]) then return 0 end if;\n  for i in zip((i,j)->i-j,[op
(sf1)],[op(sf2)]) do\n     if i<0 then return 0 end if;\n  end do;\n  \+
#-- construct the permutation of the Lehmer code of the skew diagram\n
  perLst:=[lehmerCodeToPermutation( skewToLehmerCode(sf1,sf2) )];\n  n
opsD:=nops(Descents(op(perLst)));\n  #-- deal with special cases 0 des
cest output s[0], \n  #-- 1 descent=Grassmannian permutation = Schur f
unction\n  if nopsD=0 then \n     return s[0]\n  elif nopsD=1 then \n \+
    return lehmerCodeToSchurFkt(permutationToLehmerCode(op(perLst)))\n
  end if;\n  # start computation: for all permutations in perlst appla
y the\n  # transition algorithm (possibly increasing the length of the
 list)\n  # If the number of descents for a permutatin is 1 add to res
ult\n  # othewise feed back to perLst\n  res:=0;\n  while perLst<>[] d
o\n    per:=perLst[1];\n    perLst:=perLst[2..-1];\n    res2:=transiti
on(per);\n    for i from 1 to nops(res2) do \n       if nops(Descents(
res2[i]))=1 then \n          res:=res+lehmerCodeToSchurFkt(permutation
ToLehmerCode(res2[i]));\n       else\n          perLst:=[res2[i],op(pe
rLst)];\n       end if;\n    end do;\n  end do;  \n  res;\nend proc:\n
#\n# DEFAULT: skewLS made linear\n#\nskew:=proc(x,y)\n  option `Copyri
ght (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;\n \+
 local cf,tm,n1,n2,n3,plst;\n  if y=s[0] then return x; end if;\n  if \+
type(x,`+`) then \n    return map(procname,x,y);\n  elif type(x,`*`) t
hen \n    tm,cf:=selectremove(type,x,sfktmonom);\n    return cf*procna
me(tm,y)\n  else\n    if type(y,`+`) then \n      return map2(procname
,x,y);\n    elif type(y,`*`) then\n      tm,cf:=selectremove(type,y,sf
ktmonom);\n      return cf*procname(x,tm)\n    else\n      return skew
LS(x,y);\n    end if;\n  end if;\nend proc:\n#\n#\n#\ncouter_mon:=proc
(x)\n   local par,parLst,pr;\n   if x=s[0] then return &t(s[0],s[0]); \+
end if;\n   if x=s[1] then return &t(s[1],s[0])+&t(s[0],s[1]); end if;
\n   par:=[op(x)];\n   parLst:=partitionsInShape(par);\n   add(&t(s[op
(pr)],skewLS(x,s[op(pr)])), pr in parLst);\nend proc:\n#\n#\n#\ncouter
:=proc(x)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009
. All rights reserved.`;\n  local cf,tm,n1,plst1,plst2,i;\n  if not ty
pe(x,sfktpolynom) then return x*procname(s[0]) end if;\n  if type(x,`+
`) then \n    return map(procname,x);\n  elif type(x,`*`) then \n    t
m,cf:=selectremove(type,x,sfktmonom);\n    return cf*procname(tm)\n  e
lse\n#----- obsolete code\n#    if x=s[0] then return &t(s[0],s[0]) en
d if;\n#    n1:=`+`(op(getPart(x))):\n#    tm:=&t(s[0],x)+&t(x,s[0]);
\n#    for i from 1 to n1-1 do\n#       plst1:=map(x->s[op(x)],PartNM(
n1-i,n1));\n#       plst2:=map(x->s[op(x)],PartNM(i,n1));\n#       tm:
=tm+add(add(subs(s[0]=1,Scalar(x,outer(y,z)))*&t(y,z),y=plst1),z=plst2
);\n#    end do;\n#    return tm;\n    return couter_mon(x);\n  end if
;\nend proc:\n#\n#\n# couterH_monom is the internal function computing
 the outer product on complete\n#              symmetric functions mon
oms\n#\n#\ncouterH_mon:=proc(x)\n   option `Copyright (c) B. Fauser & \+
R. Ablamowicz 2004-2009. All rights reserved.`,\n          remember;\n
   local prtx,p1,f,g,l;\n   prtx:=[op(x)];\n   if prtx=[] or prtx=[0] \+
then return &t(h[0],h[0]) end if;\n   if nops(prtx)=1 then return add(
&t(h[prtx[1]-i],h[i]),i=0..prtx[1]) end if;\n   p1:=prtx[1];\n   prtx:
=prtx[2..-1];\n   f:=(x,y,z)->&t(x,z,y):\n   l:=proc(x)\n      h[op(su
bs(0=NULL,[op(x)]))]; \n      if %=h[] then h[0] else % end if:\n   en
d proc:\n   g:=(x,y,s,t)->&t(l(outerH(x,y)),l(outerH(s,t))):\n   eval(
subs(`&t`=g,\n          add(f(h[p1-i],h[i],procname(h[op(prtx)])) ,i=0
..p1) ));\nend proc:\n#\n#\n# couterH computes the outer coproduct in \+
the h-basis. This is essentially a wrapper\n#         function for cou
terH_mon on monomials, making it multilinear over the\n#         integ
ers.\n#\n#\ncouterH:=proc(x)\n  option `Copyright (c) B. Fauser & R. A
blamowicz 2004-2009. All rights reserved.`,\n  remember;\n  local cf,t
m,n1,plst1,plst2,i;\n  ####if not type(x,efktpolynom) then return x*pr
ocname(h[0]) end if;#####<<<<<BUG\n  if not type(x,hfktpolynom) then r
eturn x*procname(h[0]) end if;\n  if type(x,`+`) then \n    return map
(procname,x,y);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(typ
e,x,hfktmonom);\n    return cf*procname(tm,y)\n  else\n    if type(y,`
+`) then \n      return map2(procname,x,y);\n    elif type(y,`*`) then
\n      cf,tm:=selectremove(type,y,integer);\n      return cf*procname
(x,tm)\n    else\n      if x=h[0] then return &t(h[0],h[0]) end if;\n \+
     couterH_mon(x);  \n    end if;\n  end if;\nend proc:\n#\n#\n# cou
terE_mon is the internal function computing the outer product on eleme
ntary\n#              symmetric functions monoms\n#\n#\ncouterE_mon:=p
roc(x)\n   option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. \+
All rights reserved.`,\n          remember;\n   local prtx,p1,f,g,l;\n
   prtx:=[op(x)];\n   if prtx=[] or prtx=[0] then return &t(e[0],e[0])
 end if;\n   if nops(prtx)=1 then return add(&t(e[prtx[1]-i],e[i]),i=0
..prtx[1]) end if;\n   p1:=prtx[1];\n   prtx:=prtx[2..-1];\n   f:=(x,y
,z)->&t(x,z,y):\n   l:=proc(x)\n      e[op(subs(0=NULL,[op(x)]))]; \n \+
     if %=e[] then e[0] else % end if:\n   end proc:\n   g:=(x,y,s,t)-
>&t(l(outerE(x,y)),l(outerE(s,t))):\n   eval(subs(`&t`=g,\n          a
dd(f(e[p1-i],e[i],procname(e[op(prtx)])) ,i=0..p1) ));\nend proc:\n#\n
#\n# couterE computes the outer coproduct in the e-basis. This is esse
ntially a wrapper\n#         function for couterE_mon on monomials, ma
king it multilinear over the\n#         integers.\n#\n#\ncouterE:=proc
(x)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All \+
rights reserved.`,\n  remember;\n  local cf,tm,n1,plst1,plst2,i;\n  if
 not type(x,efktpolynom) then return x*procname(e[0]) end if;\n  if ty
pe(x,`+`) then \n    return map(procname,x,y);\n  elif type(x,`*`) the
n \n    tm,cf:=selectremove(type,x,efktmonom);\n    return cf*procname
(tm,y)\n  else\n    couterE_mon(x);  \n  end if;\nend proc:\n#\n#\n# c
outerP_mon is the internal function computing the outer product on pow
er sum\n#              symmetric functions monoms\n#\n#\ncouterP_mon:=
proc(x)\n   option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009.
 All rights reserved.`,\n          remember;\n   local prtx,p1,f,g,l;
\n   prtx:=[op(x)];\n   if prtx=[] or prtx=[0] then return &t(p[0],p[0
]) end if;\n   if nops(prtx)=1 then return &t(x,p[0])+&t(p[0],x) end i
f;\n   p1:=prtx[1];\n   prtx:=prtx[2..-1];\n   f:=(x,y,z)->&t(x,z,y):
\n   l:=proc(x)\n      p[op(subs(0=NULL,[op(x)]))]; \n      if %=p[] t
hen p[0] else % end if:\n   end proc:\n   g:=(x,y,s,t)->&t(l(outerP(x,
y)),l(outerP(s,t))):\n   eval(subs(`&t`=g,\n          f(p[p1],p[0],pro
cname(p[op(prtx)]))\n         +f(p[0],p[p1],procname(p[op(prtx)])) ));
\nend proc:\n#\n#\n# couterP computes the outer coproduct in the p-bas
is. This is essentially a wrapper\n#         function for couterP_mon \+
on monomials, making it multilinear over the\n#         integers.\n#\n
#\ncouterP:=proc(x)\n  option `Copyright (c) B. Fauser & R. Ablamowicz
 2004-2009. All rights reserved.`,\n  remember;\n  local cf,tm,n1,plst
1,plst2,i;\n  if not type(x,pfktpolynom) then error \"Power sum polyno
m expected....\"; end if;\n  if x=0 then return 0 end if;\n  if type(x
,`+`) then \n    return map(procname,x,y);\n  elif type(x,`*`) then \n
    tm,cf:=selectremove(type,x,pfktmonom);\n    return cf*procname(tm,
y)\n  else\n    couterP_mon(x);  \n  end if;\nend proc:\n#\n# antipode
 for the Sfunctions\n#\n#\nantipS_mon:=proc(sfkt)\n  option `Copyright
 (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`; \n  l
ocal p1,Lambda,i,k,N;\n  p1:=[op(sfkt)];\n  if `+`(op(p1))=0 then retu
rn s[0] end if;\n  Lambda:=[0$`+`(op(p1))]:\n  for i from 1 to nops(p1
) do\n  for k from 1 to p1[i] do\n    Lambda[k]:=Lambda[k]+1;\n  end d
o: end do:\n  Lambda:=map(x-> if x=0 then NULL else x end if ,Lambda);
   \n  (-1)^(`+`(op(p1)))*s[op(Lambda)]; \nend proc:\n#\n# linear vers
ion for the antipode of the Sfunctions\n#\n#\nantipS:=proc(x)\n  optio
n `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reser
ved.`,\n  remember;\n  local cf,tm,n1,plst1,plst2,i;\n  if x=0 then re
turn 0 end if;\n  if x=s[0] then return s[0] end if;\n  if type(x,`+`)
 then \n    return map(procname,x);\n  elif type(x,`*`) then \n    tm,
cf:=selectremove(type,x,sfktmonom);\n    return cf*procname(tm)\n  els
e\n    antipS_mon(x);  \n  end if;\nend proc:\n#\n# antipode in the po
wer sum basis\n#\n#\nantipP_mon:=proc(pfkt)\n  option `Copyright (c) B
. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;\n  (-1)^(no
ps([op(pfkt)]))*pfkt; \nend proc:\n#\n# linear form of the power sum a
ntipode\n#\n#\nantipP:=proc(x)\n  option `Copyright (c) B. Fauser & R.
 Ablamowicz 2004-2009. All rights reserved.`,\n  remember;\n  local cf
,tm,n1,plst1,plst2,i;\n  if x=0 then return 0 end if;\n  if x=p[0] the
n return p[0] end if;\n  if type(x,`+`) then \n    return map(procname
,x);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,pfktmon
om);\n    return cf*procname(tm)\n  else\n    antipP_mon(x);  \n  end \+
if;\nend proc:\n#\n# antipH_mon is the recursively defined antipode fo
r the complete symmetric \n#            functions (internal use only)
\n#\nantipH_mon:=proc(hfktmonom)\n  option `Copyright (c) B. Fauser & \+
R. Ablamowicz 2004-2009. All rights reserved.`,\n         remember;\n \+
 local f;\n  if op(hfktmonom)=0 then return h[0] end if;\n  f:=(x,y)->
outerH(antipH_mon(x),y):\n  eval(subs(`&t`=f,-couterH(hfktmonom)+&t(hf
ktmonom,h[0])));\nend proc:\n#\n# antipH is the linear version of anti
H_mon\n#\nantipH:=proc(x)\n  option `Copyright (c) B. Fauser & R. Abla
mowicz 2004-2009. All rights reserved.`,\n  remember;\n  local cf,tm,n
1,plst1,plst2,i;\n  if x=0 then return 0 end if;\n  if x=h[0] then ret
urn h[0] end if;\n  if type(x,`+`) then \n    return map(procname,x);
\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,hfktmonom);
\n    return cf*procname(tm)\n  else\n    antipH_mon(x);  \n  end if;
\nend proc:\n#\n# antipE_mon is the recursively defined antipode for t
he elementary symmetric \n#            functions (internal use only)\n
#\nantipE_mon:=proc(efktmonom)\n  option `Copyright (c) B. Fauser & R.
 Ablamowicz 2004-2009. All rights reserved.`,\n         remember;\n  l
ocal f;\n  if op(efktmonom)=0 then return e[0] end if;\n  f:=(x,y)->ou
terE(antipE_mon(x),y):\n  eval(subs(`&t`=f,-couterE(efktmonom)+&t(efkt
monom,e[0])));\nend proc:\n#\n# antipE is the linear version of antiE_
mon\n#\nantipE:=proc(x)\n  option `Copyright (c) B. Fauser & R. Ablamo
wicz 2004-2009. All rights reserved.`,\n  remember;\n  local cf,tm,n1,
plst1,plst2,i;\n  if x=0 then return 0 end if;\n  if x=e[0] then retur
n e[0] end if;\n  if type(x,`+`) then \n    return map(procname,x);\n \+
 elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,efktmonom);\n \+
   return cf*procname(tm)\n  else\n    antipE_mon(x);  \n  end if;\nen
d proc:\n#\n# antipM_mon is the recursively defined antipode for the m
onomial symmetric \n#            functions (internal use only)\n#\nant
ipM_mon:=proc(mfktmonom)\n  option `Copyright (c) B. Fauser & R. Ablam
owicz 2004-2009. All rights reserved.`,\n         remember;\n  local f
;\n  if op(mfktmonom)=0 then return m[0] end if;\n  f:=(x,y)->outerM(a
ntipM_mon(x),y):\n  eval(subs(`&t`=f,-couterM(mfktmonom)+&t(mfktmonom,
m[0])));\nend proc:\n#\n# antipM is the linear version of antipM_mon\n
#\nantipM:=proc(x)\n  option `Copyright (c) B. Fauser & R. Ablamowicz \+
2004-2009. All rights reserved.`,\n  remember;\n  local cf,tm,n1,plst1
,plst2,i;\n  if x=0 then return 0 end if;\n  if x=m[0] then return m[0
] end if;\n  if type(x,`+`) then \n    return map(procname,x);\n  elif
 type(x,`*`) then \n    tm,cf:=selectremove(type,x,mfktmonom);\n    re
turn cf*procname(tm)\n  else\n    antipM_mon(x);  \n  end if;\nend pro
c:\n#\n# linear version for the antipode of the Hopf algebra of outer \+
coproduct and concatenation\n#   -- in the monomial basis...\n#\n#\nan
tipMC:=proc(x)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004
-2009. All rights reserved.`,\n  remember;\n  local cf,term;\n  if x=0
 then return 0 end if;\n  if x=m[0] then return m[0] end if;\n  if typ
e(x,`+`) then \n    return map(procname,x);\n  elif type(x,`*`) then \+
\n    term,cf:=selectremove(type,x,mfktmonom);\n    return cf*procname
(term)\n  else\n    return (-1)^nops(op([x]))*x;  \n  end if;\nend pro
c:\n##################################################################
######################\n#\n# T A B L E S\n#\n#########################
###############################################################\n#\n# \+
KostkaTable returns an equation Kostka'N'=matrix where matrix is the m
atrix of\n#             Kostka numbers in the anti lexicographic order
ing of partitions\n#\nKostkaTable:=proc(N::integer)\n  option `Copyrig
ht (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`; \n \+
 local part,sn,mks;\n  mks:=(lst)->map(i->s[op(i)],lst);\n  part:=Part
NM(N,N);\n  sn:=map(i->mks(i),part);\n  cat(Kostka,N)=subs(s[0]=1,eval
m(linalg[matrix](nops(part),nops(part),(i,j)->Scalar( s[op(part[i])],o
uter(op(sn[j]))))));\nend proc:\n#\n# LaplaceTable returns the matrix \+
of the Rota-Stein Laplace pairing for the monomial\n#              sym
metric function deformation. It is presented in the graded anti\n#    \+
          lexicographic ordering, which respects the grading of the La
place\n#              pairing (block diagonal form). First row and col
ums show the basis \n#              partitions\n#\nLaplaceTable:=proc(
N,M)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All
 rights reserved.`;\n  local prtN,prtM;\n  prtN,prtM:=sort(PartNM(N,N)
,grAlexComp),sort(PartNM(M,M),grAlexComp);\n  linalg[matrix](nops(prtN
)+1,nops(prtM)+1,\n       (i,j)->if i=1 and j=1 then \n               \+
 `<x|y>` elif j=1 then \n                prtN[i-1] elif i=1 then \n   \+
             prtM[j-1] else   \n                LaplaceM_mon(prtN[i-1]
,prtM[j-1]) \n              end if);\nend proc:\n\n###################
#######################################################\n#\n# I N N E \+
R MONOID and COMONOID\n#\n#           Power Sum Basis \n#\n###########
###############################################################\n\n###
######################################################################
#\n#\n# innerH_mon the inner product of symmetric functions in the h-b
asis\n#     -- it is based on the Laplace property of the inner and ou
ter products\n#     -- i)  (a.b) o c = \\sum_(c)  (a o c_(1)) . (b o c
_(2))\n#     -- ii) c o (a.b) = \\sum_(c)  (c_(1) o a) . (c_(2) o b)\n
#     -- where we have used:\n#     --  . outer product\n#     --  \\D
elta(c)= \\sum_(c) c_(1) otimes c_(2) outer coproduct\n#     --  o inn
er product \n#\ninnerH_mon:=proc(hfktmon1,hfktmon2)\n  local n,m,coh,f
;\n  n,m:=nops([op(hfktmon1)]),nops([op(hfktmon2)]);\n  if `+`(op(hfkt
mon1))<> `+`(op(hfktmon2)) then\n     return 0;\n  elif n=1 then\n    \+
 return hfktmon2;\n  elif m=1 then\n     return hfktmon1;\n  elif n<m \+
then\n     f:=(a,b,x,y)->outerH(innerH_mon(a,x),innerH_mon(b,y)); \n  \+
   coh:=&t(couterH(hfktmon1),h[[op(hfktmon2)][1]],h[op([op(hfktmon2)][
2..-1])]);\n     return eval(subs(`&t`=f,coh));\n  else\n     f:=(a,b,
x,y)->outerH(innerH_mon(a,x),innerH_mon(b,y)); \n     coh:=&t(couterH(
hfktmon2),h[[op(hfktmon1)][1]],h[op([op(hfktmon1)][2..-1])]);\n     re
turn eval(subs(`&t`=f,coh));\n  end if;\nend proc:\n#\n# innerH is the
 linear version of innerH_mon\n#\n#\ninnerH:=proc(x)\n  option `Copyri
ght (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n \+
 remember;\n  local cf,tm,p1,p2,y,f;\n  if nargs=1 then return x end i
f;\n  y:=args[2];\n  if x=0 or y=0 then return 0 end if;\n  if nargs>2
 then return procname(expand(procname(x,y)),args[3..-1]) end if;\n  if
 not(type(x,hfktpolynom) and type(args[2],hfktpolynom)) then error \"w
rong type\\n\" end if;\n  if type(x,`+`) then \n    return map(procnam
e,x,y);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,hfkt
monom);\n    return cf*procname(tm,y)\n  else\n    if type(y,`+`) then
 \n      return map2(procname,x,y);\n    elif type(y,`*`) then\n      \+
tm,cf:=selectremove(type,y,hfktmonom);\n      return cf*procname(x,tm)
\n    else\n      innerH_mon(x,y);\n    end if;\n  end if;\nend proc:
\n####################################################################
###################\n#\n# inner is the inner product on Schur function
s. It establishes the tensor product\n#    of S_n representations in t
erms of their characters under the Frobenius \n#    characteristic map
.\n#\ninner_mon := proc(sfkt1,sfkt2)\n  option `Copyright (c) B. Fause
r & R. Ablamowicz 2004-2009. All rights reserved.`; \n  local n1,n2,pr
t,mat,i,k,lst1,lst2,m;\n  lst1:=[op(sfkt1)];\n  lst2:=[op(sfkt2)];\n  \+
n1:=`+`(op(lst1));\n  n2:=`+`(op(lst2));\n  if n1<>n2 then return 0 en
d if;\n  if op(sfkt1)=0 and op(sfkt2)=0 then return s[0] end if;\n  pr
t:=PartNM(n1,n1);\n  n2:=nops(prt);\n  mat:=matrix(n2,n2,(i,j)->MurNak
(prt[j],prt[i]));\n # -- find position of lst1, and lst2 in prt\n  i:=
1:while prt[i]<>lst1 do i:=i+1; end do;\n  k:=1:while prt[k]<>lst2 do \+
k:=k+1; end do;\n # -- use the characters to generate the multp. table
\n  add(add(\n    zee(prt[l])^(-1)*mat[i,l]*mat[k,l]*mat[m,l]*s[op(prt
[m])]\n      ,l=1..nops(prt)),m=1..n2);\n#############################
###########################\n##\n##  this is a direct way to compute t
he inner product, needs to be tested\n##  in speed against the above v
ersion, rsults are the same.\n##  Note: in MurNak seems to be a transp
osition, so that here\n##        MurNak(par1,par2) = scalarPS(p[par1],
s[par2])\n##\n##  add(add(\n##    zee(rho)^(-1)*MurNak(rho,lst1)*MurNa
k(rho,lst2)*MurNak(rho,lambda)*s[op(lambda)]\n##      ,rho in prt),lam
bda in prt)\n\nend proc:\n#\n#\ninner:=proc(x)\n  option `Copyright (c
) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n  remem
ber;\n  local cf,tm,p1,p2,y,f;\n  if nargs=1 then return x end if;\n  \+
y:=args[2];\n  if x=0 or y=0 then return 0 end if;\n  if nargs>2 then \+
return procname(procname(x,y),args[3..-1]) end if;\n  if not(type(x,sf
ktpolynom) and type(args[2],sfktpolynom)) then error \"wrong type\\n\"
 end if;\n  if type(x,`+`) then \n    return map(procname,x,y);\n  eli
f type(x,`*`) then \n    tm,cf:=selectremove(type,x,sfktmonom);\n    r
eturn cf*procname(tm,y)\n  else\n    if type(y,`+`) then \n      retur
n map2(procname,x,y);\n    elif type(y,`*`) then\n      tm,cf:=selectr
emove(type,y,sfktmonom);\n      return cf*procname(x,tm)\n    else\n  \+
    if x=0 or y=0 then return 0 end if;\n      inner_mon(x,y)\n    end
 if;\n  end if;\nend proc:\n##########################################
###########################################\n#\n# innerM implements th
e inner product for monomial symmetric function bases\n#\n############
######################################################################
###\ninnerM:=proc(x)\n   local y,lst;\n   if nargs=1 then return x end
 if;\n   if nargs>2 then\n     y:=args[2];\n     lst:=args[3..-1];\n  \+
   return procname(expand(procname(x,y)),lst); \n   else\n     y:=args
[2];\n     p_to_m(innerP(m_to_p(x),m_to_p(y)));\n   end if;\nend proc:
\n#\n# cinner_mon is the inner coproduct on monomials, it is the Schur
-Hall dual of \n#            the inner product of Schur functions and \+
is computed by using that\n#            particular fact.\n#\ncinner_mo
n:=proc(sfkt)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-
2009. All rights reserved.`; \n  local n1,n2,prt,lst;\n  if sfkt=0 the
n return 0 end if;\n  lst:=[op(sfkt)];\n  if sfkt=s[0] then return &t(
s[0],s[0]) end if;\n  n1:=`+`(op(lst));\n  prt:=SchurFkt:-PartNM(n1,n1
);\n  add(&t(s[op(i)],inner(s[op(i)],s[op(lst)])),i=prt);\nend proc:\n
#\n# cinner is the linear version of cinner_mon\n#\ncinner:=proc(x)\n \+
 option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights
 reserved.`,\n  remember;\n  local cf,tm,n1,plst1,plst2,i;\n  if type(
x,`+`) then \n    return map(procname,x);\n  elif type(x,`*`) then \n \+
   tm,cf:=selectremove(type,x,sfktmonom);\n    return cf*procname(tm)
\n  else\n    cinner_mon(x);  \n  end if;\nend proc:\n#\n# counitInner
S computes the counit of the inner coporduct in the\n#        Schur fu
nction basis\n#\ncounitInnerS:=proc(x)\n  option `Copyright (c) B. Fau
ser & R. Ablamowicz 2004-2009. All rights reserved.`,\n  remember;\n  \+
local cf,tm;\n  if type(x,`+`) then \n    return map(procname,x,serNam
e);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,sfktmono
m);\n    return cf*procname(tm,serName)\n  else\n    subs(s[0]=1,Scala
r(x,s[`+`(op(x))]));\n  end if;\nend proc:\n#\n# innerP_mon computer t
he inner product of power sum functions. \n#\ninnerP_mon := proc(pfkt1
,pfkt2)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. \+
All rights reserved.`; \n  local n1,n2,bool,lst1,lst2;\n  n1:=`+`(op(p
fkt1));\n  n2:=`+`(op(pfkt2));\n  if n1<>n2 then return 0 end if;\n  b
ool:=map(x->if x=0 then true else false end if,zip((x,y)->x-y,[op(pfkt
1)],[op(pfkt2)]));\n  if convert(bool,set)=\{true\} then\n    return z
ee([op(pfkt1)])*pfkt1;\n  else \n    return 0;\n  end if; \nend proc:
\n#\n# innerP is the multilinear version of the inner product in power
 sum basis\n#\ninnerP:=proc(x)\n  option `Copyright (c) B. Fauser & R.
 Ablamowicz 2004-2009. All rights reserved.`,\n  remember;\n  local cf
,tm,p1,p2,y,f;\n  if nargs=1 then return x end if;\n  y:=args[2];\n  i
f x=0 or y=0 then return 0 end if;\n  if nargs>2 then return procname(
expand(procname(x,y)),args[3..-1]) end if;\n  if not(type(x,pfktpolyno
m) and type(args[2],pfktpolynom)) then error \"wrong type\\n\" end if;
\n  if type(x,`+`) then \n    return map(procname,x,y);\n  elif type(x
,`*`) then \n    tm,cf:=selectremove(type,x,pfktmonom);\n    return cf
*procname(tm,y)\n  else\n    if type(y,`+`) then \n      return map2(p
rocname,x,y);\n    elif type(y,`*`) then\n      tm,cf:=selectremove(ty
pe,y,pfktmonom);\n      return cf*procname(x,tm)\n    else\n      inne
rP_mon(x,y);\n    end if;\n  end if;\nend proc:\n#\n# cinnerP_mon comp
utes the inner coproduct on monomials in the power sum\n#             \+
basis, this coproduct is grouplike on all basis elements\n#           \+
  x |-->  &t(x,x) \n#\ncinnerP_mon:=proc(x)\n  &t(x,x);\nend proc:\n#
\n# cinnerP linear version of the inner coproduct in the power sum bas
is\n#\n#\ncinnerP:=proc(x)\n  option `Copyright (c) B. Fauser & R. Abl
amowicz 2004-2008. All rights reserved.`,\n  remember;\n  local cf,tm;
\n  if type(x,`+`) then \n    return map(procname,x);\n  elif type(x,`
*`) then \n    tm,cf:=selectremove(type,x,pfktmonom);\n    return cf*p
rocname(tm)\n  else\n    cinnerP_mon(x);\n  end if;\nend proc:\n#\n# c
innerP linear version of the inner coproduct in the power sum basis\n#
\n#\ncounitInnerP:=proc(x)\n  option `Copyright (c) B. Fauser & R. Abl
amowicz 2004-2008. All rights reserved.`,\n  remember;\n  local cf,tm;
\n  if type(x,`+`) then \n    return map(procname,x);\n  elif type(x,`
*`) then \n    tm,cf:=selectremove(type,x,sfktmonom);\n    return cf*p
rocname(tm)\n  else\n    return 1;\n  end if;\nend proc:\n############
#####################################################\n#\n#  cdiag imp
lements the diagonalization coproduc in all 5 standard\n#        bases
 the default basis is the 'p-basis' of power sums\n#        This imple
ments (if based on power sums) effectively the\n#        inner coprodu
ct.\n#  NOTE: The cdiag(x,TYPE) functions are _different_ if another\n
#        basis is chosen. cdiag(x,s) <> cdiag(x,m) etc. \n#\n#########
########################################################\ncdiag:=proc(
x)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2006. All r
ights reserved.`;\n  local cf,term,TYPE;\n  if nargs=2 then\n    TYPE:
=args[2];\n    if not member(TYPE,\{s,p,m,h,f,e\}) then\n      error \+
\"You picked a type '%1' which is not in my list of known types\\n 's,
p,m,h,f,e' !\",TYPE;\n    end if;\n  else \n    TYPE:='p';\n  end if;
\n  if x=0 then return 0; end if;\n  if type(x,cat(TYPE,fktpolynom)) t
hen\n    if type(x,`+`) then\n      return map(procname,x,TYPE);\n    \+
elif type(x,`*`) then\n      term,cf:=selectremove(type,x,cat(TYPE,fkt
monom));\n      return cf*procname(term,TYPE);\n    else\n      return
 &t(x,x);\n    end if;\n  else\n    error \"No basis monom of type `%1
` found, allowed types are in \{s,p,h,m,e,f\}!\\n\",TYPE;\n  end if;\n
end proc:\n###########################################################
#########################\n#\n# Plethysms\n#\n########################
############################################################\n#\n# lis
t_divisors(n::posint) -> a list of all natrural numbers which divide n
 \n#\nlist_divisors:=proc(x)\n  option `Copyright (c) B. Fauser & R. A
blamowicz 2004-2009. All rights reserved.`; \n  local i,t,res;\n  if x
=1 then return [1] end if;\n  res:=[];\n  for i from 1 to floor(x/2) d
o\n    t:=irem(x,i);\n    if t = 0 then\n      res:=[op(res),i];\n    \+
end if;\n  end do;  \n  [op(res),x];\nend:\n##########################
##########################################################\n#\n# pleth
ysm coproduct of a single part power sum \n#\n########################
############################################################\nplethPsi
ngleP:=proc(pfkt)\n   option `Copyright (c) B. Fauser & R. Ablamowicz \+
2004-2009. All rights reserved.`; \n   local part,ld;\n   part:=[op(pf
kt)];\n   ld:=list_divisors(op(part));\n   add(&t(p[i],p[op(part)/i]),
i=ld);\nend proc:\n#\n# plethP_mon computes the plethysm between two p
ower sum basis monoms. We have\n#       -- p_0[p\\mu]=p[0]\n#       --
 p_\\mu[p_0]=p_0\n#       -- p_n[p_m]=p_n.m\n#       -- p_n[p_mu]=p_\\
mu[p_n] and hence\n#       -- p_\\mu[p_\\nu] = \\prod_(i,j) p_[\\mu_i.
\\nu_j]\n#\n# NOTE: THIS VERSION SEEMS TO BE SLOWER THAN THE BELOW GIV
EN BY A FACTOR 1.5\n#\n#plethP_mon:=proc(x,y)\n#  option `Copyright (c
) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n#      \+
   remember;\n#  local p1,p2;\n#  p1,p2:=[op(x)],[op(y)];\n#  if p1=[0
] or p2=[0] then return p[0] end if;\n#  if nops(p1)=1 then\n#    if n
ops(p2)=1 then\n#       return p[op(p1)*op(p2)]\n#    else\n#       re
turn p[op(map(x->op(p1)*x,p2))]\n#    end if\n#  else\n#    outerP(seq
(procname(p[l],y),l in p1));\n#  end if;\n#end proc:\n################
##################################################################\n# \+
plethP_mon is the plethysm product on power sum symmetric monomial fun
ctions\n#   -- nonrecursive version\n#\n#\nplethP_mon:=proc(pfkt1,pfkt
2)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All r
ights reserved.`;\n  local part1,part2;\n  part1:=[op(pfkt1)];\n  part
2:=[op(pfkt2)];\n     p[op(sort(\n         [seq(seq(part1[i]*part2[j],
i=1..nops(part1)),j=1..nops(part2))],\n         (i,j)->if i>j then tru
e else false end if\n           ))];\nend proc:\n#\n# plethysm of powe
r sum polynomials ...\n#\n# plethP(P,Q) = P[Q]\n#  -- linear in P   (P
1+P2)[Q]=P1[Q]+P2[Q]\n#  -- not linear in Q, that is\n#  -- P[Q1+Q2]=P
_(1)[Q1].P_(2)[Q2]  where \\Delta(P)=P_(1) \\otimes P_(2) is the outer
 coproduct\n#  -- P[Q1.Q2]=P_[1][Q1].P_[2][Q2]  where \\delta(P)=P_[1]
 \\otimes P_[2] is the inner corpoduct\n#                             \+
      (this case is trated in plethP_mon\n#  -- P[-Q]=(antipP(P))[Q]  \+
        hence we need to split Q in to a positive and negative\n#     \+
                              part\n#\nplethP:=proc(x,y)\n  option `Co
pyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`
,\n         remember;\n  local cf,term,term2,cout,sgn,f0,f1,a,b;\n  if
 type(x,pfktmonom) then\n    if x=p[0] then return p[0] end if;\n    i
f x=p[1] then return y end if;\n    if type(y,pfktmonom) then\n      i
f y=p[0] then return p[0] end if;\n      if y=p[1] then return x end i
f;\n      return plethP_mon(x,y)\n    elif type(y,`*`) then\n#  -- not
e that cf*term = term+term+...+term is the additive case!!\n      term
,cf:=selectremove(type,y,pfktmonom);\n      if type(cf,integer) then\n
        if cf<0 then\n          return (-1)^nops([op(x)])*procname(x,-
cf*term);\n        end if;\n#  -- put a bracket [cf-1] to prevent line
ar expansion in the tensor &t(...)\n        cout:=&t(couterP(x),[cf-1]
,term); \n        f0:=(u,v,c,t)->outerP(plethP(u,t),plethP(v,op(c)*t))
;\n        return eval(subs(`&t`=f0,cout));\n      else\n#  -- put a b
racket [cf] to prevent linear expansion in the tensor &t(...)\n   #  -
- works but is slower than a direct computation...\n   #     cout:=&t(
cinnerP(x),[cf],term);\n   #     f1:=(x1,x2,cf,term)->dimGLP(x1,op(cf)
)*plethP_mon(x2,term);\n   #     return eval(subs(`&t`=f1,cout ));\n  \+
 #     error(\"2nd argument need to be a polynomial over the integers \+
but received: %1\\n\",y);\n        return cf^nops([op(x)])*plethP_mon(
x,term);\n      end if;\n    else\n      cout:=[op(y)];\n      a,b:=co
ut[1],cout[2..-1];\n      cout:=&t(couterP(x),[a],b);\n      f0:=(u,v,
c,t)->outerP(plethP(u,op(c)),plethP(v,`+`(op(t)))):\n         return e
val(subs(`&t`=f0,cout));   \n    end if;\n  elif type(x,`*`) then\n   \+
 term,cf:=selectremove(type,x,pfktmonom);\n    return cf*procname(term
,y);\n  else\n    return map(procname,x,y);\n  end if;\nend proc:\n" }
{MPLTEXT 1 0 17368 "#\n# cplethP is the plethystic coproduct on power \+
sum functions\n#\n#\ncplethP:=proc(pfkt)\n  option `Copyright (c) B. F
auser & R. Ablamowicz 2004-2009. All rights reserved.`;\n  local cf,te
rm,llst,dlst,res,i,Npi,pi,dPi;\n##\n  if type(pfkt,`+`) then \n    ret
urn map(procname,pfkt)\n  elif type(pfkt,`*`) then\n    term,cf:=selec
tremove(type,pfkt,pfktmonom);\n    return cf*procname(term)\n  else\n \+
 ######\n    pi:=[op(pfkt)];\n    Npi:=`+`(op(pi));\n    dPi:=list_div
isors(Npi);\n    res:=0;\n    for i in dPi do\n       llst:=PartNM(i,i
);\n       dlst:=PartNM(Npi/i,Npi/i);\n       res:=res+\n         add(
add(\n            1/(zee(l)*zee(d))\n            *ScalarP(p[op(pi)],pl
ethP(p[op(l)],p[op(d)]))*&t(p[op(l)],p[op(d)])\n            ,l=llst),d
=dlst);\n    end do;\n    res;\n  ######\n  end if; \nend proc:\n#####
######################################################################
######\n#\n#    SFunction PLETHYSMS\n#\n##############################
###################################################\n#\n# plethysm of \+
two complete symmetric functions aka s[n],s[m]\n#\n#   -- we use the n
otation P[Q]=pleth(P,Q), hence the plethysm is linear in P (first vari
able)\n#   -- the plethysm is not linear in the second variable Q, it \+
distributes with the inner\n#   -- coproduct over the the second argum
ent:\n#   -- P[Q1.Q2]=P_\{[1]\}[Q1].P_\{[2]\}[Q2]\n#   -- if P is give
n in a power sum basis, then \\delta P = P_[1]\\otimes P_[2] = P \\oti
mes P\n#\n#  +++ plethsp(sfkt,pfkt) -> sfkt\n#   --         this funct
ion is based on the transition s_to_p and the power sum plethysm\n#   \+
--         of pfktmonomials, followed by a transformation back into sf
unctions!\n#   --         plethP_mon computes pfktmonom[pfktmonom] ple
thysms \n#   --         Since x=s[n] is a one row sfkt (complete funct
ion), the characters in the\n#   --         expansions are all 1 and d
issapear from the computation.\n#\nplethsp:=proc(x,y)\n  option `Copyr
ight (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n
  remember;\n  local n;\n  n:=op(x);\n  p_to_s(add(1/zee(i)*plethP(y,p
[op(i)]),i in PartNM(n,n)));\nend proc:\n#\n# +++ plethSnm(sfkt,sfkt) \+
-> sfkt\n#  --      this function expands the outer one row Sfunction \+
into power sums (without\n#  --      characters as in plethsp above) a
nd uses afterwards the fact that \n#  --      p_n[Q] = Q[p_n] for one \+
part (primitive) power sum functions. The remaining\n#  --      plethy
sms are of the form s_n[p_k] which can be computed via the function\n#
  --      plethsp defined above.\n#  --      This function does not ma
ke use of a possible cancellation of terms due\n#  --      to the fini
teness of dimenions (the alphabet involved)\n#  --      This function \+
is by fare not optimal (see Axel Kohnert's algorithm)\n#\nplethSnm:=pr
oc(x,y)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. \+
All rights reserved.`,\n  remember;\n  local n,m;\n  n,m:=op(x),op(y);
\n  if n=0 then \n    return s[0]\n  elif m=0 then \n    return s[0]\n
  elif n=1 then\n    return y\n  elif m=1 then \n    return x\n  end i
f; \n  add(1/zee(i)*outer(op(map((k)->plethsp(s[m],p[k]),[op(i)]))) ,i
 in PartNM(n,n));\nend proc:\n#\n# plethSP: sfkt x pfkt --> sfkt\n# ++
+   plethSP realized the pletysm of an Sfucntion monom by a pfktmonom \+
for general\n#  --   partitions \\lambda,\\mu. This time we need to in
sert the characters of the\n#  --   s_to_p transition computed via the
 Murnaghan Nakayama rule.\n#\n#  ++   plethSP shows that\n#  ++   plet
hSP(s[n],p[0]) = s[0]\n#  ++   plethSP(s[lambda],p[0]) = 0  for \\leng
th(lambda)>1\n#\nplethSP:=proc(x,y)\n  option `Copyright (c) B. Fauser
 & R. Ablamowicz 2004-2009. All rights reserved.`,\n  remember;\n  loc
al i,n;\n  n:=`+`(op(x));\n  p_to_s(add(1/zee(i)*MurNak(i,[op(x)])*ple
thP(y,p[op(i)]),i in PartNM(n,n)));\nend proc:\n#\n#\n# plethS_mon : s
fkt x sfkt --> sfkt\n# +++ plethS_mon computes the pletysm of two SFun
ction monoms. It uses the expansion \n#  -- s_to_p and thereby the Mur
naghan Nakayama coefficients. The second step is once \n#  -- more to \+
use p_n[s_\\lambda] = s_\\lambda[p_n] and compute these plethysms via
\n#  -- plethSP\n#\nplethS_mon:=proc(x,y)\n  option `Copyright (c) B. \+
Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n         rem
ember;\n  local n,m,i;\n  n,m:=`+`(op(x)),`+`(op(y));\n  if n=0 then \+
\n    return s[0]\n  elif m=0 then\n    # -- according to SCHUR (and p
lethSP see above)\n    # -- plethS(s[n],s[0]) = s[0]\n    # -- plethS(
s[lambda],s[0]) = 0 if length(lambda)>1\n    if nops([op(x)]) > 1 then
  \n      return 0\n    else\n      return s[0]\n    end if;\n  elif n
=1 then\n    return y\n  elif m=1 then \n    return x\n  end if; \n  e
xpand(\n     add(1/zee(i)*MurNak(i,[op(x)])*outer(op(map((k)->plethSP(
y,p[k]),[op(i)]))) \n         ,i in PartNM(n,n))  );\nend proc:\n#####
###################################################################\n#
\n# plethSAxNB computes the plethysm of a Schur function A with the\n#
    n-fold multiple of a Schur function B  A[n.B] using the inner\n#  \+
  coproduct. This can be used to produce q-deformed symmetric\n#    fu
nctions [see Francesco Brenti, A Class of q-Symmetric Functions\n#    \+
Arising from Plethysm, J. Comb.Theor. Series A 91, 2000:137-170]\n#\n#
######################################################################
#\nplethSAxNB:=proc(sfkta,sfktb,N)\n  option `Copyright (c) B. Fauser \+
& R. Ablamowicz 2004-2009. All rights reserved.`;\n  local f;\n  if N=
1 then return plethS(sfkta,sfktb) end if;\n  if N=0 then return 0 end \+
if;\n  f:=(x,y,n,sb)->dimGL(x,op(n))*plethS(y,sb):\n  eval(subs(`&t`=f
,  &t(cinner(sfkta),[N],sfktb)  ));\nend proc:\n#\n#  X[Y] is linear i
n X and not linear in Y\n#  -- (X+Y)[Z] = X[Z] + Y[Z]\n#  -- X[Y+Z] = \+
X(1)[Y] . X(2)[Z]   where . = outer, couter(X)=X(1) x X(2)\n#  -- X[YZ
] = X[1] . X[2]  where . = outer, cinner(X) =X[1] x X[2]\n#  --       \+
  this case does not appear in the function, since unevaluated\n#  -- \+
        outer products YZ do not appear.\n#\nplethS:=proc(x,y)\n  opti
on `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights rese
rved.`,\n         remember;\n  local cf,tm,p1,p2,a,b,f;\n# ++ special \+
cases\n# -- one argument numerical zero\n  if x=0 then \n     return 0
\n  elif y=0 then \n     return 0\n  end if;\n# ++ typecheck\n  if not
(type(x,sfktpolynom) and type(y,sfktpolynom)) then \n     error \"wron
g type\\n\" \n  end if;\n  if x=s[0] then \n  #-- s_(0)[s_(lambda)] = \+
s_(0) for all lambda\n    return s[0]\n  # -- the case y=s[0] needs a \+
more sophisticated treatment\n  # -- which is done in plethS_mon\n  # \+
++ s[1] is left and right unit of plethS\n  elif x=s[1] then\n    retu
rn y\n  elif y=s[1] then\n    return x\n  end if;\n## -- end of specia
l cases\n## -- plethS is linear in x but _not_ linear in y\n## ++ line
arity in x \n  if type(x,`+`) then \n    return map(procname,x,y);\n  \+
elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,sfktmonom);\n  \+
  return cf*procname(tm,y)\n  else\n## -- the y argument distributes u
sing coproducts\n## -- outer roducts do not happen, so we need to dist
inguish\n## -- two types of additive terms y = a+b and y = a+a = 2a\n#
# -- different terms have type `+`\n##\n## -- the following code cures
 a subtle error in the plethysm routine\n## -- found via computing a p
roblem of Ralf Holtkamp\n## -- one needs to make sure that the `+`(op(
b_)) is only evaluated\n## -- after the expansion has taken place!\n##
 -- change this part of teh code only with care and severe checkig\n##
 -- of at least 3 summand entries for x,y\n    if type(y,`+`) then \n \+
     b:=[op(y)];\n      a:=&t(couter(x),[b[1]],b[2..-1]);\n      f:=(x
_,y_,a_,b_)->outer( plethS(x_,op(a_)),expand( plethS(y_,`+`(op(b_))) )
 );\n      return eval(subs(`&t`=f,a));\n## -- numerical multiples of \+
the same term\n    elif type(y,`*`) then\n      tm,cf:=selectremove(ty
pe,y,sfktmonom);\n##//// here we could use plethSAxNB to allow even sy
mbolic prefactors\n      if not type(cf,integer) then\n         return
 expand(plethSAxNB(x,tm,cf));\n##//// we do not put this error message
 any longer  \n##       error \"Second input must be a polynomial over
 the integers, but received \",y; \n      end if;\n      if cf>0 then
\n        return expand(plethSAxNB(x,tm,cf));\n        #-- obsolete co
de\n        #--a:=&t(couter(x),tm,[cf-1]);\n        #--f:=(x_,y_,a_,b_
)->outer(plethS_mon(x_,a_),plethS(y_,op(b_)*a_));\n        #--return e
val(subs(`&t`=f,a));\n      else\n        return procname(antipS(x),-y
);\n      end if;\n    else\n## ++ if neither x nor y has type `+` or \+
`*` then we have tow sfktmonomials \n      plethS_mon(x,y)\n    end if
;\n  end if;\nend proc:\n#############################################
##############################\n#\n# cplethS_mon is the plethysm copro
duct of a sfktmonom\n#    -- the plethysm coproduct is obtained by dua
lizing the plethysm operation w.r.t\n#    -- the Schur-Hall scalar pro
duct:\n#    -- cplethS(x) = \\sum_(y,z)  < x ,plethS(y,z) > (y &t z)\n
#    -- where <,> is teh scalar product and plethS is the pelthysm of \+
sfunctions\n#    -- note that this is a noncocommutative operation and
 the order of y,z matters.\n#\ncplethS_mon:=proc(x)\n  local n,divx,pr
ta,prtb;\n  n:=`+`(op(x));\n  divx:=list_divisors(n);\n  add(add(add(
\n     eval(subs(s[0]=1,Scalar(x,plethS(s[op(a)],s[op(b)]))))*&t(s[op(
a)],s[op(b)]), \n    b in PartNM(n/i,n/i)), a in PartNM(i,i)), i in di
vx);\nend proc:\n#\n# cplethS is the linear version of cplethS_mon est
ablishing the plethysm coproduct of \n#    -- SFunctions.  \n#\n#\ncpl
ethS:=proc(x)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-
2009. All rights reserved.`,\n  remember;\n  local cf,tm,n1,plst1,plst
2,i;\n  if x=0 then return 0 end if;\n  if type(x,`+`) then \n    retu
rn map(procname,x);\n  elif type(x,`*`) then \n    tm,cf:=selectremove
(type,x,sfktmonom);\n    return cf*procname(tm)\n  else\n    if x=s[0]
 then return &t(s[0],s[0]) end if;\n    cplethS_mon(x);  \n  end if;\n
end proc:\n###########################################################
################\n#\n#\n#########\n######### Orthogonal Hopf algebra\n
#########\n#\n# outerON_monom outer product on s-function monoms of th
e orthogonal group\n#\n#\nouterON_monom:=proc(x,y)\n  option `Copyrigh
t (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;\n  l
ocal N,prt;\n  N:=min(`+`(op(x)),`+`(op(y)));\n  prt:=[s[0],op(map(x->
s[op(x)],[seq(op(PartNM(i,i)),i=1..N)]))];\n  add(outer(skew(x,s[op(i)
]),skew(y,s[op(i)])),i=prt);\nend proc:\n#\n# outerON outer product of
 s-function polynoms fro orthogonal groups\n#\n#\n#\nouterON:=proc(x)
\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rig
hts reserved.`,\n  remember;\n  local cf,tm,p1,p2,y,f;\n  if nargs=1 t
hen return x end if;\n  y:=args[2];\n  if x=0 or y=0 then return 0 end
 if;\n  if nargs>2 then return procname(expand(procname(x,y)),args[3..
-1]) end if;\n  if not(type(x,sfktpolynom) and type(args[2],sfktpolyno
m)) then error \"wrong type\\n\" end if;\n  if type(x,`+`) then \n    \+
return map(procname,x,y);\n  elif type(x,`*`) then \n    tm,cf:=select
remove(type,x,sfktmonom);\n    return cf*procname(tm,y)\n  else\n    i
f type(y,`+`) then \n      return map2(procname,x,y);\n    elif type(y
,`*`) then\n      tm,cf:=selectremove(type,y,sfktmonom);\n      return
 cf*procname(x,tm)\n    else\n      outerON_monom(x,y);\n    end if;\n
  end if;\nend proc:\n#\n# couterON_monom outer coproduct of s-functio
n monoms for the orthogonal groups \n#\n#\ncouterON_monom:=proc(x)\n  \+
option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights \+
reserved.`;\n  local prt, del;\n  prt:=[[0],seq(op(PartNM(i,i)),i=1..`
+`(op(x)))];\n  del:=map(x->2*x,[[0],seq(op(PartNM(i,i)),i=1..floor(`+
`(op(x)))/2)]);\n  add(&t(skew(x,outer(add(s[op(k)],k=del),s[op(i)])),
s[op(i)]),i=prt); \nend proc:\n#\n# couterON outer coproduct of sfunct
ion polynoms for the orthogonal groups \n#\ncouterON:=proc(x)\n  optio
n `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reser
ved.`,\n         remember;\n  local cf,tm;\n  if type(x,`+`) then \n  \+
  return map(procname,x);\n  elif type(x,`*`) then \n    tm,cf:=select
remove(type,x,sfktmonom);\n    return cf*procname(tm)\n  else\n    cou
terON_monom(x);  \n  end if;\nend proc:\n#############################
###########################################################\n##\n## S-
function Series facilities\n##\n######################################
##################################################\n#\n#  getSfktSerie
s returns a sum of S-functions of a known Schur function series\n#\n# \+
 -- currently known series are M,L,D,B,F\n#\ngetSfktSeries:=proc(name)
\n   option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All ri
ghts reserved.`,\n          remember;\n   local N,prt,serFlag,t,f,m,i,
j;\n   if nargs=1 then\n      if args[1]='names' then \n        return
 \"Known Series are: A,B,C,D,E,F,L,M\";\n      else\n        error \"U
sage: either give one argument 'names' or [2|3] arguments, see help pa
ge\";\n      end if;\n   end if; \n   if nargs>=2 then N:=args[2] end \+
if;\n   if nargs=3 then serFlag:=true; t:=args[3] else serFlag:=false \+
end if;\n   ## ///////////////////////////\n   ## M-series = \\sum \{m
\} t^m\n   ##\n   if name='M' then\n      if serFlag=false then\n     \+
    return [seq(s[m],m=0..N)];\n      else\n         add(s[m]*t^m,m=0.
.N);\n      end if;\n   ## ///////////////////////////\n   ## L-series
 = \\sum (-1)^m \{1^m\} t^m\n   ##\n   ## (special care for zero parti
tion)\n   ##\n   elif name='L' then\n      if serFlag=false then\n    \+
     return [seq((-1)^m*s[m],m=0..N)];\n      else\n         f:=m->if \+
m=0 then 0 else 1$m end if:\n         add((-1)^m*s[f(m)]*t^m,m=0..N);
\n      end if;\n   ## ///////////////////////////\n   ## C-series = \+
\\sum \{\} (inverse of the D series)\n   ##\n   ## (we scale the param
eter t also!)\n   elif name='C' then\n      prt:=[s[0],op(\n          \+
    map(x->if \{1\}=\{op(zip((i,j)->i-j,op(part2Frob([op(x)]))))\} the
n \n                  (-1)^(`+`(op(x))/2)*x else   NULL end if,procnam
e(F,N))  )];\n      if serFlag=false then\n         return prt;\n     \+
 else\n        ## --- take care of the sign\n        f:=proc(x,t)\n   \+
        local cf,term;\n           cf:=1:\n           if type(x,`*`) t
hen\n             term,cf:=selectremove(type,x,sfktmonom);\n          \+
   return (cf*t)^(`+`(op(term)))\n           else\n             return
 (cf*t)^(`+`(op(x)))\n           end if;\n         end proc:\n        \+
 ## ---        \n         add(i*f(i,t),i=prt);\n      end if;\n   ## /
//////////////////////////\n   ## D-series = \\sum \{delta\}   delta=e
ven parts only\n   ##\n   ## (we scale the parameter t also!)\n   elif
 name='D' then\n      prt:=map(x->2*x,[[0],seq(op(PartNM(i,i)),i=1..fl
oor(N/2))]);\n      if serFlag=false then\n         return map(x->s[op
(x)],prt);\n      else\n         add(s[op(i)]*t^(`+`(op(i))),i=prt);\n
      end if;\n   ## ///////////////////////////   \n   ## B-series = \+
\\sum \{beta\}   conjpart(beta)=even parts only\n   ##\n   ## (we scal
e the parameter t also!)\n   elif name='B' then\n      prt:=map(x->2*x
,[[0],seq(op(PartNM(i,i)),i=1..floor(N/2))]);\n      prt:=map(x->conjp
art(x),prt);\n      if serFlag=false then\n         return map(x->s[op
(x)],prt);\n      else\n         add(s[op(i)]*t^(`+`(op(i))),i=prt);\n
      end if;\n   ## ///////////////////////////\n   ## A-series  \n  \+
 ##\n   elif name='A' then \n      prt:=[s[0],op(\n              map(x
->if \{1\}=\{op(zip((i,j)->j-i,op(part2Frob([op(x)]))))\} then \n     \+
             (-1)^(`+`(op(x))/2)*x else   NULL end if,procname(F,N))  \+
)];\n      if serFlag=false then\n         return prt;\n      else\n  \+
      ## --- take care of the sign\n        f:=proc(x,t)\n           l
ocal cf,term;\n           cf:=1:\n           if type(x,`*`) then\n    \+
         term,cf:=selectremove(type,x,sfktmonom);\n             return
 (cf*t)^(`+`(op(term)))\n           else\n             return (cf*t)^(
`+`(op(x)))\n           end if;\n         end proc:\n         ## ---  \+
      \n         add(i*f(i,t),i=prt);\n      end if;\n   ## //////////
/////////////////\n   ## E-series  = \\sum_self conj part (-)^(|x|+r) \+
*s[prt]\n   ##              r = Frobenius rank of the partition\n   ##
\n   elif name='E' then \n      prt:=[s[0],op(\n              map(x->i
f \{0\}=\{op(zip((i,j)->j-i,op(part2Frob([op(x)]))))\} then \n        \+
             x else NULL end if,procname(F,N))  )];\n      if serFlag=
false then\n         return map(x->(-1)^((`+`(op(x))+nops(part2Frob([o
p(x)])[1]))/2)*x ,prt);\n      else\n         add((-1)^((`+`(op(i))+no
ps(part2Frob([op(i)])[1]))/2)*i\n             *t^(`+`(op(i))),i=prt);
\n      end if;\n   ## ///////////////////////////\n   ## F-series = \+
\\sum \{zeta\}  all partitions \n   ##\n   elif name='F' then\n      p
rt:=[[0],seq(op(PartNM(i,i)),i=1..N)];\n      if serFlag=false then\n \+
        return map(x->s[op(x)],prt);\n      else\n         add(s[op(i)
]*t^(`+`(op(i))),i=prt);\n      end if;\n    else\n      error \"unrec
ognized series name: use getSfktSeries(names) to see which names are k
nown!\";\n   end if;\nend proc:\n#\n# branch_monom internal function f
or branchings on monoms\n#\n# +++ !!!! this function should be already
 multilinear !!!!\n# +++ remove branch and rename this one after a tes
t!\nbranch_monom:=proc(x,serName)\n   option `Copyright (c) B. Fauser \+
& R. Ablamowicz 2004-2009. All rights reserved.`;\n  local ser;\n  ser
:=getSeries(serName,`+`(op(x)),1);\n  skew(x,ser);\nend proc:\n#\n# br
anch computes the reduction of induction of characters with respect to
\n#        certain S-function series\n#\nbranch:=proc(x,serName)\n  op
tion `Copyright (c) B. Fauser & R. Ablamowicz 2004-2006. All rights re
served.`,\n  remember;\n  local ser,cf,tm,n1,plst1,plst2,i;\n  if type
(x,`+`) then \n    return map(procname,x,serName);\n  elif type(x,`*`)
 then \n    tm,cf:=selectremove(type,x,sfktmonom);\n    return cf*proc
name(tm,serName)\n  else\n    ser:=SchurFkt:-getSfktSeries(serName,`+`
(op(x)),1);\n    skew(x,ser);  \n  end if;\nend proc:\n\n" }{MPLTEXT 
1 207 14 "end module:\n##" }}{PARA 6 "" 1 "" {TEXT -1 41 "SchurFkt Ver
sion 1.0.4 says 'Good bye...'" }}{PARA 6 "" 1 "" {TEXT -1 50 "SchurFkt
 Version 1.0.4 (2 xi 2009) at your service" }}{PARA 6 "" 1 "" {TEXT 
-1 58 "(c) 2003-2009 BF&RA, no warranty, no fitness for anything!" }}
{PARA 6 "" 1 "" {TEXT -1 83 "Increase verbosity by infolevel[`function
`]=val -- use online help > ?Bigebra[help]" }}}{EXCHG {PARA 227 "> " 
0 "" {MPLTEXT 1 206 77 "libname:=\"/usr/local/maple/maple13/Cliffordli
b\",libname;\nsavelib('SchurFkt');" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#
>%(libnameG6&QE/usr/local/maple/maple13/Cliffordlib6\"F&Q@/usr/local/m
aple/maple13/FGblibF'Q=/usr/local/maple/maple13/libF'" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "restart:restart:" }}{PARA 6 "" 1 "
" {TEXT -1 41 "SchurFkt Version 1.0.4 says 'Good bye...'" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "restart:with(SchurFkt);nops(%);" }}
{PARA 6 "" 1 "" {TEXT -1 50 "SchurFkt Version 1.0.4 (2 xi 2009) at you
r service" }}{PARA 6 "" 1 "" {TEXT -1 58 "(c) 2003-2009 BF&RA, no warr
anty, no fitness for anything!" }}{PARA 6 "" 1 "" {TEXT -1 83 "Increas
e verbosity by infolevel[`function`]=val -- use online help > ?Bigebra
[help]" }}{PARA 12 "" 1 "" {XPPMATH 20 "6#7fr%)AlexCompG%)CharHookG%'C
ompNMG%)DescentsG%%FLATG%*Frob2partG%-GesselThetaPG%-GesselThetaSG%)Ko
stkaPCG%,KostkaTableG%'LP_monG%)LaplaceMG%*LaplaceM2G%-LaplaceM_monG%-
LaplaceTableG%%MLING%'MurNakG%(MurNak2G%'PartNMG%'ScalarG%)ScalarHMG%)
ScalarMHG%(ScalarPG%'antipEG%'antipHG%'antipMG%(antipMCG%'antipPG%'ant
ipSG%'branchG%&cdiagG%'cinnerG%(cinnerPG%)cmp2partG%,cmp2prtMultG%-col
lect_sfktG%(concatMG%)conjpartG%-counitInnerPG%-counitInnerSG%'couterG
%(couterEG%(couterHG%(couterMG%)couterONG%(couterPG%(cplethPG%(cplethS
G%&dimGLG%'dimGLEG%'dimGLHG%'dimGLMG%'dimGLPG%&dimSNG%'dimSNEG%'dimSNH
G%'dimSNMG%'dimSNPG%'e_to_hG%'e_to_mG%'e_to_sG%6evalJacobiTrudiMatrixG
%1fallingFactorialG%.getSfktSeriesG%+grAlexCompG%'h_to_mG%'h_to_pG%'h_
to_sG%&innerG%'innerHG%'innerMG%'innerPG%*isLatticeG%8lehmerCodeToPerm
utationG%5lehmerCodeToSchurFktG%'m_to_eG%'m_to_hG%'m_to_pG%*m_to_pMatG
%'m_to_sG%0maxlengthSymFktG%*mset2partG%&outerG%'outerEG%'outerHG%(out
erLSG%'outerMG%(outerONG%'outerPG%'outerSG%'p_to_mG%'p_to_sG%*part2Fro
bG%*part2msetG%2partitionsInShapeG%8permutationToLehmerCodeG%'plethPG%
'plethSG%+plethSAxNBG%)plethSnmG%0risingFactorialG%'s_to_eG%'s_to_hG%)
s_to_hJTG%*s_to_hMatG%*s_to_hmatG%'s_to_mG%'s_to_pG%'s_to_xG%2schurToL
ehmerCodeG%3schurToLehmerCode1G%+sfkt_termsG%%skewG%'skewLRG%'skewLSG%
1skewToLehmerCodeG%)sq_coeffG%+transitionG%)truncLENG%(truncWTG%'x_to_
sG%$zeeG" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#\"$A\"" }}}{EXCHG {PARA 0 
"> " 0 "" {MPLTEXT 1 0 16 "&t(s[2],s[1,1]);" }}{PARA 11 "" 1 "" 
{XPPMATH 20 "6#-%#&tG6$&%\"sG6#\"\"#&F'6$\"\"\"F," }}}{EXCHG {PARA 0 "
> " 0 "" {MPLTEXT 1 0 204 "basS:=PartNM(4,4);\nmatrix(nops(basS)+1,nop
s(basS)+1,\n  (i,j)->if i=1 and j=1 then \"MurNak\" elif i=1 then s[op
(basS[j-1])] elif j=1 then s[op(basS[i-1])] else\n         MurNak(basS
[j-1],basS[i-1]) end if); " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 11 "" 1 "" {XPPMATH 20 "6#>%%basSG7'7#\"\"%7$\"\"$\"\"\"7$\"\"#F
,7%F,F*F*7&F*F*F*F*" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#K%'matrixG6#7(7
(Q'MurNak6\"&%\"sG6#\"\"%&F+6$\"\"$\"\"\"&F+6$\"\"#F4&F+6%F4F1F1&F+6&F
1F1F1F17(F*F1F1F1F1F17(F.!\"\"\"\"!F;F1F07(F2F<F;F4F<F47(F5F1F<F;F;F07
(F7F;F1F1F;F1Q(pprint0F)" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
211 "basS:=PartNM(4,4);\nmatrix(nops(basS)+1,nops(basS)+1,\n  (i,j)->i
f i=1 and j=1 then \"*\" elif i=1 then s[op(basS[j-1])] elif j=1 then \+
s[op(basS[i-1])] else\n         inner(s[op(basS[j-1])],s[op(basS[i-1])
]) end if);" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#>%%basSG7'7#\"\"%7$\"\"
$\"\"\"7$\"\"#F,7%F,F*F*7&F*F*F*F*" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#
K%'matrixG6#7(7(Q\"*6\"&%\"sG6#\"\"%&F+6$\"\"$\"\"\"&F+6$\"\"#F4&F+6%F
4F1F1&F+6&F1F1F1F17(F*F*F.F2F5F77(F.F.,*F*F1F.F1F2F1F5F1,&F.F1F5F1,*F.
F1F2F1F5F1F7F1F57(F2F2F<,(F*F1F2F1F7F1F<F27(F5F5F=F<F;F.7(F7F7F5F2F.F*
Q(pprint0F)" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "KostkaTable(
4);" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#/%(Kostka4GK%'matrixG6#7'7'\"\"
\"F*F*F*F*7'\"\"!F*F*\"\"#\"\"$7'F,F,F*F*F-7'F,F,F,F*F.7'F,F,F,F,F*Q(p
print06\"" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "LaplaceTable(4
,6);" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#K%'matrixG6#7(7.%&<x|gry>G7#\"
\"'7$\"\"&\"\"\"7$\"\"%\"\"#7%F/F-F-7$\"\"$F37%F3F0F-7&F3F-F-F-7%F0F0F
07&F0F0F-F-7'F0F-F-F-F-7(F-F-F-F-F-F-7.7#F/&%\"mG6#\"#5\"\"!F@F@F@F@F@
F@F@F@F@7.7$F3F-F@,&&F=6$\"\")F0F-&F=6$F*F/F-,&&F=6$\"\"(F3F-*&F0F-&F=
6$F,F,F-F-F@FGF@F@F@F@F@F@7.7$F0F0F@FJFGF@FNF@F@F@F@F@F@7.7%F0F-F-F@F@
F@,&&F=6%F*F0F0F-&F=6%F,F3F0F-F@,(FWF-*&F0F-&F=6%F/F/F0F-F-*&F0F-&F=6%
F/F3F3F-F-F@FhnF@F@F@7.7&F-F-F-F-F@F@F@F@F@F@&F=6&F/F0F0F0F@&F=6&F3F3F
0F0F@F@Q(pprint06\"" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "getS
fktSeries(E,6);\ncollect(getSfktSeries(F,6,t),t);\ndimSN(expand(%));" 
}}{PARA 11 "" 1 "" {XPPMATH 20 "6#7(&%\"sG6#\"\"!,$&F%6#\"\"\"!\"\"&F%
6$\"\"#F+,$&F%6$F/F/F,,$&F%6%\"\"$F+F+F,&F%6%F6F/F+" }}{PARA 12 "" 1 "
" {XPPMATH 20 "6#,0*&,8&%\"sG6#\"\"'\"\"\"&F'6$\"\"&F*F*&F'6$\"\"%\"\"
#F*&F'6%F0F*F*F*&F'6$\"\"$F6F*&F'6%F6F1F*F*&F'6&F6F*F*F*F*&F'6%F1F1F1F
*&F'6&F1F1F*F*F*&F'6'F1F*F*F*F*F*&F'6(F*F*F*F*F*F*F*F*)%\"tGF)F*F**&,0
&F'6#F-F*&F'6$F0F*F*&F'6$F6F1F*&F'6%F6F*F*F*&F'6%F1F1F*F*&F'6&F1F*F*F*
F*&F'6'F*F*F*F*F*F*F*)FDF-F*F**&,,&F'6#F0F*&F'6$F6F*F*&F'6$F1F1F*&F'6%
F1F*F*F*&F'6&F*F*F*F*F*F*)FDF0F*F**&,(&F'6#F6F*&F'6$F1F*F*&F'6%F*F*F*F
*F*)FDF6F*F**&,&&F'6#F1F*&F'6$F*F*F*F*)FDF1F*F**&&F'6#F*F*FDF*F*&F'6#
\"\"!F*" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#,.%\"tG\"\"\"*&\"\"#F%)F$F'
F%F%*&\"\"%F%)F$\"\"$F%F%*&\"#5F%)F$F*F%F%*&\"#EF%)F$\"\"&F%F%*&\"#wF%
)F$\"\"'F%F%" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "" 0 "" {TEXT 
-1 3 "End" }}}}{MARK "0 1 1" 35047 }{VIEWOPTS 1 1 0 1 1 1803 1 1 1 1 }
{PAGENUMBERS 0 1 2 33 1 1 }
