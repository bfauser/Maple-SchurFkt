{VERSION 6 0 "IBM INTEL LINUX" "6.0" }
{USTYLETAB {CSTYLE "Maple Input" -1 0 "Courier" 1 12 255 0 0 1 2 1 2 
2 1 2 0 0 0 1 }{CSTYLE "2D Output" -1 20 "Times" 1 12 0 0 255 1 2 2 2 
2 2 1 0 0 0 1 }{CSTYLE "_cstyle69" -1 206 "Courier" 1 12 255 0 0 1 2 
1 2 2 1 2 0 0 0 1 }{CSTYLE "_cstyle67" -1 207 "Courier" 1 12 255 0 0 
1 2 1 2 2 1 2 0 0 0 1 }{CSTYLE "_cstyle66" -1 208 "Courier" 1 12 255 
0 0 1 2 1 2 2 1 2 0 0 0 1 }{PSTYLE "Normal" -1 0 1 {CSTYLE "" -1 -1 "T
imes" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }
{PSTYLE "Line Printed Output" -1 6 1 {CSTYLE "" -1 -1 "Courier" 1 12 
0 0 255 1 2 2 2 2 2 1 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "
Maple Output" -1 11 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 
2 1 0 0 1 }3 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Left Justified Maple
 Output" -1 12 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 
0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "_pstyle138" -1 227 1 
{CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 0 
0 2 0 2 0 2 2 -1 1 }{PSTYLE "_pstyle135" -1 233 1 {CSTYLE "" -1 -1 "Co
urier" 1 12 255 0 0 1 2 1 2 2 1 2 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 
1 }{PSTYLE "_pstyle134" -1 234 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 
1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }}
{SECT 0 {EXCHG {PARA 234 "> " 0 "" {MPLTEXT 1 208 3766 "#\n# This is t
he source code file of the \"SchurFkt\" package\n# SchurFkt Version 1.
0.4 (2 xi 2009) file SchurFkt-code-ver.1.0.4-2xi09_M10.mws\n# date:   \+
Nov 2, 2009\n#\n# copyright (c) Bertfried Fauser, & Rafal Ablamowicz\n
#               June 2003-September 2009, all rights reserved.\n#\n###
######################################################################
####\n#                                                               \+
            #\n#  DISCLAIMER:                                         \+
                     #\n#                                             \+
                              #\n#  THERE IS NO WARRANTY FOR THE SCHUR
FKT PACKAGE TO THE EXTENT PERMITTED    #\n#  BY APPLICABLE LAW. EXCEPT
 WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT #\n#  HOLDERS AND/OR O
THER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT         #\n#  WARRA
NTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT    #
\n#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 FOR    #\n#  A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY \+
AND PERFORMANCE  #\n#  OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM \+
PROVE DEFECTIVE, YOU      #\n#  ASSUME THE COST OF ALL NECESSARY SERVI
CING, REPAIR OR CORRECTION.        #\n#                               \+
                                            #\n#######################
######################################################\n#\n#  If you w
ant to use this code or parts of it under a GPL LICENCE, please\n#  co
ntact the authors:\n#  rablamowicz <at> tntech.edu                 or \+
\n#  Bertfried.Fauser <at> uni-konstanz.de\n#\n#\n# +++ The package co
mputes some products and coproducts for Schur functions\n# --- \n# ---
 Remember: elementary symmetric functions are s[1^r] \n# ---          \+
 complete symmetric functions are s[r]\n# ---           m[r] equals p[
r]\n# ---           m[1,...,1] equals e[r]  (r-ones)\n#\n# +++ Main fu
nctions are:\n# --- outer      : the outer product of Schur functions \+
outer(s[3,2],s[1],...)\n# --- inner      : the inner product of Schur \+
functions inner(s[2,2],s[3,1],...)\n# --- skew       : the (outer) ske
w product of two Schur functions skew(s[3,2,1],s[2])\n# --- couter    \+
 : the outer coproduct of a Schur function couter(s[4,2])\n# --- cinne
r     : the inner coproduct of a Schur function cinner(s[4,2,2])\n# --
- antipS     : the antipode of a Schur function AntipS(s[lambda])= (-1
)^|lambda|*s[lambda']\n#                  w.r.t. the outer(!) Hopf alg
ebra\n# --- plethS     : the plethysm of two Schur function polynomial
s over a ring extension\n#                  i.e. one can compute pleth
ysms of the form \n#                  plethS(a*s[3]+s[1],q*s[2,1]+s[2]
)\n#\n# --- KostkaTable: computes the Kostka matrix of rank n\n# --- i
sLattice  : returns true is a Young tableau filled with letters (0) 1.
.n is a \n#                  lattice permutation\n#                  t
he tableau has to be given as [[row1 list ,...],[row2 list, ...],...] \+
\n#                  (mainly internal use)\n#\n# +++ TYPES:\n#        \+
   Are exposed globally to Maple via the init routine of the package, \+
any\n#           new basis requires an own type. Later versions of Sch
ur may allow the \n#           user to create own types!\n#\n# --- s-f
unctions come in monoms, terms and polynoms\n# --- m-functions come in
 monoms, terms and polynoms\n# --- p-functions come in monoms, terms a
nd polynoms\n# --- e-functions come in monoms, terms and polynoms\n# -
-- h-functions come in monoms, terms and polynoms\n# --- f-functions c
ome in monoms, terms and polynoms\n# \n#     There is a need to introd
uce orthogonal and symplectic Schur functions and other bases\n#     c
urrently these are dealt with using the _same_ names but _different_ a
lgebraic maps!!\n#\n# ===> some symmetric function bases and or operat
ions in several bases are not yet available \n#" }}{PARA 233 "> " 0 "
" {MPLTEXT 1 0 9 "restart:\n" }{MPLTEXT 1 207 128327 "SchurFkt:=module
()\n   export MLIN,FLAT,\n          fallingFactorial,risingFactorial,
\n          lehmerCodeToPermutation,permutationToLehmerCode,\n        \+
  lehmerCodeToSchurFkt,schurToLehmerCode,schurToLehmerCode1,\n        \+
  skewToLehmerCode,\n          transition,\n          Descents,\n     \+
     isLattice,\n          concatM,LaplaceM,LaplaceM2,LP_mon,LaplaceM_
mon,LaplaceTable,\n          outer,outerLS,outerS,outerM,outerH,outerE
,outerP,\n          skew,skewLR,skewLS,\n          couter,couterM,cout
erH,couterE,couterP,\n          antipS,antipP,antipH,antipE,antipM,ant
ipMC,\n          KostkaTable,KostkaPC,Scalar,ScalarP,ScalarMH,ScalarHM
,\n          AlexComp,grAlexComp,PartNM,partitionsInShape,CompNM,zee,
\n          truncWT,truncLEN,collect_sfkt,sfkt_terms,\n          part2
mset,mset2part,conjpart,cmp2prtMult,cmp2part,Frob2part,part2Frob,\n   \+
       MurNak,MurNak2,CharHook,sq_coeff,\n          dimSN,dimSNP,dimSN
M,dimSNH,dimSNE,\n          dimGL,dimGLP,dimGLM,dimGLH,dimGLE,\n      \+
    GesselThetaP,GesselThetaS,\n          inner,innerP,innerH,innerM,
\n          cinner,counitInnerS,cinnerP,counitInnerP,\n          cdiag
,\n          plethP,cplethP,plethSAxNB,plethS,plethSnm,cplethS,\n     \+
     p_to_m,p_to_s,\n          m_to_p,m_to_pMat,m_to_e,m_to_h,m_to_s,
\n          s_to_p,s_to_x,s_to_h,s_to_hMat,s_to_hJT,s_to_e,s_to_hmat,s
_to_m,\n          h_to_s,h_to_m,h_to_p,\n          e_to_h,e_to_s,e_to_
m,\n          x_to_s,\n          evalJacobiTrudiMatrix,maxlengthSymFkt
,\n          outerON,couterON,getSfktSeries,branch;\n   global `type/c
liscalar`, `type/mydomain`,\n          `type/hfktmonom`, `type/hfktter
m`, `type/hfktpolynom`,\n          `type/efktmonom`, `type/efktterm`, \+
`type/efktpolynom`,\n          `type/sfktmonom`, `type/sfktterm`, `typ
e/sfktpolynom`,\n          `type/pfktmonom`, `type/pfktterm`, `type/pf
ktpolynom`,\n          `type/ffktmonom`, `type/ffktterm`, `type/ffktpo
lynom`,\n          `type/mfktmonom`, `type/mfktterm`, `type/mfktpolyno
m`,\n          `type/symfktmonom`, `type/symfktterm`, `type/symfktpoly
nom`;\n   local init,exit,ADD,LRR,getPart,makeRimRep,removeRimHook,Mur
NakRim,\n         partitionsInShape_gen,\n         dimSN_mon,dimGL_mon
,dimGLP_mon,\n         LaplaceMset,couterMproper1n,LP_l1,concatM_mon,c
oncat_mon,\n         inner_mon,cinner_mon,innerP_mon,cinnerP_mon,inner
H_mon,\n         couter_mon,couterM_mon,couterH_mon,couterE_mon,couter
P_mon,\n         antipS_mon,antipP_mon,antipH_mon,antipE_mon,antipM_mo
n,\n         p_to_mM,m_to_pM,\n         list_divisors,truncLEN_mon,Ges
selThetaP_mon,GesselThetaS_mon,\n         plethPsingleP,\n         x_t
o_sM,\n         s_to_xM,s_to_hM,s_to_eM,s_to_mM,\n         h_to_sM,h_t
o_mM,h_to_pM,\n         m_to_hM,m_to_sM,\n         etoh,e_to_hM,e_to_s
M,e_to_mM,\n         plethP_mon,plethsp,plethSP,plethS_mon,cplethS_mon
,\n         sfktmon_to_hmatrix,\n         outerON_monom,couterON_monom
,branch_monom;  \n   option package,\n          load=init,\n          \+
unload=exit;\n########################################################
#########################\n#\n#  init exposes several types in the glo
bal name space, it greets the user\n#       and initialized the tensor
 product.\n#\ninit:=proc()\n  global FIELD;\n#\n#\n#\nprintf(\"SchurFk
t Version 1.0.4 (2 xi 2009) at your service\\n(c) 2003-2009 BF&RA, no \+
warranty, no fitness for anything!\\n\",%s);\n#\n# set the global vari
able FIELD to specify the ground field of the ring /\\ and \n#     sep
cify the linearity of the tensor product &t in use\n#\n# overwirte a p
ossibly set type cliscalar, which is to radical in its linearity\n  `t
ype/cliscalar`:=proc(x)\n         type(x,'rational');\n  end proc:\n#
\n  FIELD := radalgfun(rational,[q,t,u,v]);\n  `type/mydomain`:=proc(x
) \n         type(x,radalgfun(rational,[q,t,u,v]));\n  end proc:\n  if
 assigned(`&t`) then unassign(`&t`) end if;\n  define(`&t`,multilinear
,flat,domain='mydomain');\n#\n# type:   SYM-Fkt (general symmetric fun
ction type)\n#\n  `type/symfktmonom`:=proc(a)\n     option `Copyright \+
(c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;  \n   \+
  member(op(0,a),\{s,p,h,m,e,f\});\n  end proc:\n#\n  `type/symfktterm
`:=proc(a)\n     option `Copyright (c) B. Fauser & R. Ablamowicz 2004-
2009. All rights reserved.`;  \n     if type(a,`symfktmonom`) then ret
urn true fi; \n     if type(a,`*`) and 1<>select(type,a,`symfktmonom`)
 then\n       true;\n     else\n       false; \n     fi;\n  end proc:
\n#\n  `type/symfktpolynom`:=proc(a) \n     option `Copyright (c) B. F
auser & R. Ablamowicz 2004-2009. All rights reserved.`;  \n     if typ
e(a,`symfktterm`) then return true fi:\n     if type(a,`+`) then \n   \+
    return evalb(map(type,\{op(a)\},symfktterm)=\{true\})\n     else\n
       return false;\n     fi\n  end proc:\n#\n# type:   S-Fkt\{monom,
term,polynom\}\n#\n  `type/sfktmonom`:=proc(a)\n     option `Copyright
 (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;  \n  \+
   evalb(`s`=op(0,a));\n  end proc:\n#\n  `type/sfktterm`:=proc(a)\n  \+
   option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All righ
ts reserved.`;  \n     if type(a,`sfktmonom`) then return true fi; \n \+
    if type(a,`*`) and 1<>select(type,a,`sfktmonom`) then\n       true
;\n     else\n       false; \n     fi;\n  end proc:\n#\n  `type/sfktpo
lynom`:=proc(a) \n     option `Copyright (c) B. Fauser & R. Ablamowicz
 2004-2009. All rights reserved.`;  \n     if type(a,`sfktterm`) then \+
return true fi:\n     if type(a,`+`) then \n       return evalb(map(ty
pe,\{op(a)\},sfktterm)=\{true\})\n     else\n       return false;\n   \+
  fi\n  end proc:\n#\n# type:   p-Fkt\{monom,term,polynom\}\n#\n  `typ
e/pfktmonom`:=proc(a)\n     option `Copyright (c) B. Fauser & R. Ablam
owicz 2004-2009. All rights reserved.`;  \n     evalb(`p`=op(0,a));\n \+
 end proc:\n#\n  `type/pfktterm`:=proc(a)\n     option `Copyright (c) \+
B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;  \n     if
 type(a,`pfktmonom`) then return true fi; \n     if type(a,`*`) and 1<
>select(type,a,`pfktmonom`) then\n       true;\n     else\n       fals
e; \n     fi;\n  end proc:\n#\n  `type/pfktpolynom`:=proc(a) \n     op
tion `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights re
served.`;  \n     if type(a,`pfktterm`) then return true fi:\n     if \+
type(a,`+`) then \n       return evalb(map(type,\{op(a)\},pfktterm)=\{
true\})\n     else\n       return false;\n     fi\n  end proc:\n#\n# t
ype:   m-Fkt\{monom,term,polynom\}\n#\n  `type/mfktmonom`:=proc(a)\n  \+
   option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All righ
ts reserved.`;  \n     evalb(`m`=op(0,a));\n  end proc:\n#\n  `type/mf
ktterm`:=proc(a)\n     option `Copyright (c) B. Fauser & R. Ablamowicz
 2004-2009. All rights reserved.`;  \n     if type(a,`mfktmonom`) then
 return true fi; \n     if type(a,`*`) and 1<>select(type,a,`mfktmonom
`) then\n       true;\n     else\n       false; \n     fi;\n  end proc
:\n#\n  `type/mfktpolynom`:=proc(a) \n     option `Copyright (c) B. Fa
user & R. Ablamowicz 2004-2009. All rights reserved.`;  \n     if type
(a,`mfktterm`) then return true fi:\n     if type(a,`+`) then \n      \+
 return evalb(map(type,\{op(a)\},mfktterm)=\{true\})\n     else\n     \+
  return false;\n     fi\n  end proc:\n#\n# type:   h-Fkt\{monom,term,
polynom\}\n#\n  `type/hfktmonom`:=proc(a)\n     option `Copyright (c) \+
B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;  \n     ev
alb(`h`=op(0,a));\n  end proc:\n#\n  `type/hfktterm`:=proc(a)\n     op
tion `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights re
served.`;  \n     if type(a,`hfktmonom`) then return true fi; \n     i
f type(a,`*`) and 1<>select(type,a,`hfktmonom`) then\n       true;\n  \+
   else\n       false; \n     fi;\n  end proc:\n#\n  `type/hfktpolynom
`:=proc(a) \n     option `Copyright (c) B. Fauser & R. Ablamowicz 2004
-2009. All rights reserved.`;  \n     if type(a,`hfktterm`) then retur
n true fi:\n     if type(a,`+`) then \n       return evalb(map(type,\{
op(a)\},hfktterm)=\{true\})\n     else\n       return false;\n     fi
\n  end proc:\n#\n# type:   e-Fkt\{monom,term,polynom\}\n#\n  `type/ef
ktmonom`:=proc(a)\n     option `Copyright (c) B. Fauser & R. Ablamowic
z 2004-2009. All rights reserved.`;  \n     evalb(`e`=op(0,a));\n  end
 proc:\n#\n  `type/efktterm`:=proc(a)\n     option `Copyright (c) B. F
auser & R. Ablamowicz 2004-2009. All rights reserved.`;  \n     if typ
e(a,`efktmonom`) then return true fi; \n     if type(a,`*`) and 1<>sel
ect(type,a,`efktmonom`) then\n       true;\n     else\n       false; \+
\n     fi;\n  end proc:\n#\n  `type/efktpolynom`:=proc(a) \n     optio
n `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reser
ved.`;  \n     if type(a,`efktterm`) then return true fi:\n     if typ
e(a,`+`) then \n       return evalb(map(type,\{op(a)\},efktterm)=\{tru
e\})\n     else\n       return false;\n     fi\n  end proc:\n#\n#\n# t
ype:   f-Fkt\{monom,term,polynom\}\n#\n  `type/ffktmonom`:=proc(a)\n  \+
   option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All righ
ts reserved.`;  \n     evalb(`f`=op(0,a));\n  end proc:\n#\n  `type/ff
ktterm`:=proc(a)\n     option `Copyright (c) B. Fauser & R. Ablamowicz
 2004-2009. All rights reserved.`;  \n     if type(a,`ffktmonom`) then
 return true fi; \n     if type(a,`*`) and 1<>select(type,a,`ffktmonom
`) then\n       true;\n     else\n       false; \n     fi;\n  end proc
:\n#\n  `type/ffktpolynom`:=proc(a) \n     option `Copyright (c) B. Fa
user & R. Ablamowicz 2004-2009. All rights reserved.`;  \n     if type
(a,`ffktterm`) then return true fi:\n     if type(a,`+`) then \n      \+
 return evalb(map(type,\{op(a)\},ffktterm)=\{true\})\n     else\n     \+
  return false;\n     fi\n  end proc:\n#\n# -- we protect the labesl f
or the various Schur function bases, so that no\n# -- mischieve can ha
ppen\n#\n# protect the names of basis elements\n  protect('h','m','e',
'f','s','p');\n#\n#\nend proc: # init \n#\n#\n#\nexit:=proc()\n  optio
n `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reser
ved.`;  \n  printf(\"SchurFkt Version 1.0.4 says 'Good bye...'\\n\",%s
);\nend proc:\n#######################################################
###########################\n#\n# Actual package starts here with some
 helper and internal functions \n#\n##################################
################################################\n####################
##############################################################\n#\n# H
elper functions\n#\n##################################################
################################\n#\n# MLIN is a function which allows
 to make a procedure multilinear w.r.t. the integers\n#      or any gr
ound field specified in the global variable FIELD\n#      Mostly inter
nal use!\n# +++ (warning may be replaced in future releases, don't use
 it in own code!)\n#\nMLIN:=proc()\n  option `Copyright (c) B. Fauser \+
& R. Ablamowicz 2004-2009. All rights reserved.`;  \n  local i,P,pt,re
s,sg;\n  for i from 1 to nargs do\n    lst||i:=args[i];\n    if type(l
st||i,`+`) then lst||i:=[op(lst||i)] else lst||i:=[lst||i] end if;\n  \+
end do:\n  sg:=proc(x)\n    local cf,tm;\n    if type(x,symfktmonom) t
hen \n      return 1 \n    elif type(x,symfktterm) then \n      tm,cf:
=selectremove(type,x,symfktmonom);\n      return cf; \n    else \n    \+
  error \"this should not happen\"; \n    end if; \n  end proc:\n  res
:=0:\n  P:=combinat[cartprod]([seq(lst||i,i=1..nargs)]):\n  while not \+
P[finished] do \n    pt:=P[nextvalue]();\n    res:=res+mul(sg(pt[i]),i
=1..nops(pt))*_T(seq(pt[i]/sg(pt[i]),i=1..nops(pt)));\n  end do;\n  ev
al(subs(_T=`&t`, res ));\nend proc:\n#\n# FLAT is a function which all
ows to impose the associativity of functions \n#      (flaten expressi
ons) Mostly internal use.\n# +++  (warning may be replaced in future r
eleases, don't use it in own code!)\n#\nFLAT:=proc()\n  option `Copyri
ght (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;  \+
\n  local x,lst,drp,cf,term;\n  x:=eval(subs(T=MLIN,args));\n  drp:=pr
oc() args end proc:\n  if type(x,`+`) then \n    return eval(subs(T=ML
IN,map(procname,x)))\n  elif type(x,`*`) then \n    cf,term:=selectrem
ove(type,x,'integer');\n    return cf*eval(subs(T=MLIN,T(eval(subs(T=d
rp,term)))));\n  else\n    return eval(subs(T=MLIN,T(eval(subs(T=drp,x
)))));\n  end if;\nend proc:\n########################################
########################################\n#\n# fallingFactorial is the
 polynomial Pochhammer symbol (for nonnegative integral N)\n# risingFa
ctorial  seems not to be implemented in Maple\n#\nfallingFactorial:=(x
,N)->mul((x-k),k=0..N-1):\nrisingFactorial:=(x,N)->mul((x+k),k=0..N-1)
:\n#\n#\n##########################\n#\n# Combinatorial functions\n#\n
##########################\n#\n# KostkaPC computes the Kostka coeffici
ent between a partition and a composition.\n#          Every compositi
on lies in a symmetric group orbit of a particular \n#          partit
ion, on which the Kostka coefficient is actually constant.\n#         \+
 KostkaPC is defined as the Schur-Hall scalar product of the h[comp[i]
]\n#          (=s[comp[i]) and the Schur function with partition part.
 Since the outer\n#          product is commutative and since zero par
ts of the composition turn into\n#          the multiplicative unit, w
e compute just the outer product of the one\n#          part Schurfunc
tions and then the scalar product. \n#\nKostkaPC:=proc(part1,part2)\n \+
 option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights
 reserved.`;\n  local mks;\n  mks:=(lst)->map(i->s[op(i)],lst);\n  sub
s(s[0]=1,\n      Scalar(outer(op(map(i->mks(i),part2))),s[op(part1)])
\n      );\nend proc:\n#\n# grAlexcomp establishes the graded (by part
s) anti lexicographical ordering on integer \n#            partitions \+
or compositions.\n#\ngrAlexComp:=proc(x,y)\n  option `Copyright (c) B.
 Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;  \n  if nops
(x)<nops(y) then \n    true\n  else\n     AlexComp(x,y)\n  end if;\nen
d proc:\n#\n# AlexComp  establishes the anti lexicographical ordering \+
on integer partitions or\n#           compositions.\n#\nAlexComp:=proc
(x,y)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. Al
l rights reserved.`;\n  local i,bool;\n  i:=1;\n  while i <= min(nops(
x),nops(y)) do\n    if x[i]>y[i] then return true elif x[i]<y[i] then \+
return false end if;\n    i:=i+1;\n  end do;\n  true;   \nend proc:\n#
\n# isLattice checks if a tableaux (Young diagram or shape filled with
 (non negative) \n#           integers is a Lattice permutation (ballo
t sequence)\n#\nisLattice:=proc(tbl)\n  option `Copyright (c) B. Fause
r & R. Ablamowicz 2004-2009. All rights reserved.`\n         ,remember
;  \n  local cl,lst,i,nl,T;\n  cl:=nops(tbl);\n  lst:=map(x->if x=0 th
en NULL else x end if,[seq(op(tbl[cl+1-i]),i=1..cl)]);\n  nl:=max(op(l
st));\n  for i from 1 to nl do\n    T[i]:=0:\n  end do:\n  for i from \+
nops(lst) by -1 to 1 do\n    T[lst[i]]:=T[lst[i]]+1;\n    if member(fa
lse,\{seq(evalb(T[i]>=T[i+1]),i=1..nl-1)\}) then \n      return false;
\n    end if;\n  end do;\n  true; \nend proc:\n#\n# ADD (internal use)
 adds a single letter named 'let' (integer) to a tableau in such\n#   \+
  a way, that the resulting word is a lattice permutation (i.e. in a w
ay which is\n#     allowed by the Littlewood Richardson rule). This is
 the function which actually\n#     implements the Littlewood Richards
on rule. It tries to be clever about summation\n#     but might be gre
atly improved on speed still, but uses option remember.\n#     \nADD:=
proc(tbl,let)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-
2009. All rights reserved.`\n         ,remember;\n  local cl,rl,ad,min
,res,i;\n#####\n# +++ preliminary stuff\n  cl:=nops(tbl); \n  rl:=map(
x->nops(x),tbl);\n  ad:=(x,y)->[op(x),y]:\n  res:=[]:\n# ---  \n#####
\n# +++ find first row with letter 'let'\n# --- descending search\n  m
in:=cl+1:\n  if member(let,\{op(map(x->op(x),tbl))\}) then\n    for i \+
from cl by -1 to 1 do\n      if member(let,\{op(tbl[i])\}) then min:=i
: break; end if;\n    end do:\n  else # -- no let 'let'\n    min:=1;\n
  end if;\n#####\n# +++ find first row with more letters let-1 than le
tters 'let'\n# +++ but start at row 'min'\n# --- ascending search\n  i
f let>1 then \n    for i from max(1,min-1) to cl do\n      if `+`(op( \+
map(x->op(x),[seq( map( x->if x=let-1 then -1 elif x=let then 1 else N
ULL end if,\n                       tbl[k]), k=1..i)]) )) < 0 then min
:=i+1: break; \n      end if;\n    end do:\n  end if;\n##### \n  #\n  \+
# +++ now start to put the letter in any possible place\n  # --- begin
ning with row 'min'\n  #\n  for i from min to cl do\n  #\n  # +++ case
 i=1 is different\n  #\n    if i=1 then \n      if (tbl[i][-1]<=let or
 tbl[i][-1]=0) then  \n        if isLattice(subsop(i=ad(tbl[i],let),tb
l)) then \n          res:=[op(res),subsop(i=ad(tbl[i],let),tbl)];\n   \+
     end if; \n      end if;\n    else\n  # +++ cases i=2..cl\n      i
f (rl[i-1]>rl[i]) then \n        if (tbl[i][-1]<=let or tbl[i][-1]=0) \+
then\n          if (tbl[i-1][rl[i]+1]<let or tbl[i-1][rl[i]+1]=0) then
\n            if isLattice(subsop(i=ad(tbl[i],let),tbl)) then \n      \+
        res:=[op(res),subsop(i=ad(tbl[i],let),tbl)];\n            end \+
if;      \n          end if;\n        end if;\n      end if;\n    end \+
if;\n  end do:\n  # +++ last row\n  if (tbl[cl][1]<let or tbl[cl][1]=0
) then\n    if isLattice([op(tbl),[let]]) then \n          res:=[op(re
s), [op(tbl),[let]] ];\n    end if;      \n  end if;\n  op(res);\nend \+
proc:\n#\n# LLR (internal use) is the Littlewood Richardson rule. This
 function is based on \n#     the functionality of ADD adding one lett
er at a time. LLR evacuates one tableau \n#     by adding its letters \+
successively to the (list of) tableaux emerging from \n#     previous \+
adds. \n#\nLRR:=proc(lst1,lst2)\n  option `Copyright (c) B. Fauser & R
. Ablamowicz 2004-2009. All rights reserved.`\n         ,remember;\n  \+
local i,j,k,TT,srt;\n  #\n  if lst1=[0] then return s[op(lst2)] end if
;\n  if lst2=[0] then return s[op(lst1)] end if;\n  #\n  TT:=[[seq([0$
lst1[j]],j=1..nops(lst1))]]:\n  for i from 1 to nops(lst2) do\n  for j
 from 1 to lst2[i] do\n    TT:=map(ADD,TT,i);    end do;\n  end do;\n \+
 `+`(op(map(x->s[op(x)],[seq(map(x->nops(x),TT[k]),k=1..nops(TT))])));
 \nend proc:\n#\n# (obsolete function, internal use only)\n#\n# getPar
t strips of the name of a symmetric function n[a,b,c] returning the in
dexing list.\n# +++     no longer used, inline use in code as [op(x)] \+
directly. \ngetPart:=proc(x)\n  option `Copyright (c) B. Fauser & R. A
blamowicz 2004-2009. All rights reserved.`;  \n  [op(x)];\nend proc:\n
#\n# PartNM returns a list of partitions of N with M parts.\n#        \+
PartNM returns a list ordered inversely to teh standard Maple\n#      \+
  combinat package! \n#\nPartNM := proc(n, m)\n  option `Copyright (c)
 B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n        \+
 remember;\n  local i, p, s, t;\n  if n = 0 then\n    return [[]]\n  e
lif m = 1 then\n    return [[`$`(1,n)]]\n  else\n    for i to m do\n  \+
    t := procname(n-i,min(n-i,i));\n      p[i] := seq([i, op(s)],s = t
)\n    end do;\n    [seq](p[m+1-i],i = 1 .. m);\n  end if;\nend proc:
\n#\n#\n# partitionsInShape_gen(par) produces a _set_ of all partition
s which fit into the shape par\n#         these are partitions of all \+
weights wt, 0 <= wt <= weight(par). These partitions\n#         form t
he set of possibly non-trivial skews, and generate a minimal number of
\n#         partitions for the Schur outer coproduct. This routine is \+
not optimal as it internally\n#         produces some partitions with \+
a multiplicity, this is removed by the set data structure.\n#         \+
(internal use only)\n#\npartitionsInShape_gen:=proc(par)\n   local res
,i,newpar,min,k;\n   if par=[] then return [[0]] end if;\n   if nops(p
ar)=1 then return [seq([par[1]-i],i=0..par[1])] end if; \n   res:=\{pa
r\};\n   #-- for all descents delete a box\n   for i from 1 to nops(pa
r)-1 do\n      if par[i]>par[i+1] then\n         newpar:=par;\n       \+
  newpar[i]:=newpar[i]-1;\n         res:=\{op(res),op(procname(newpar)
)\};\n      end if;\n   end do;\n   #-- last index, i points already t
o last index\n   if par[i]>1 then\n      newpar:=par;\n      newpar[i]
:=newpar[i]-1;\n      res:=\{op(res),op(procname(newpar))\};\n   else
\n      newpar:=par[1..-2];\n      res:=\{op(res),op(procname(newpar))
\};\n   end if;\n   res; \nend proc:\n#\n# partitionsInShape(par) retu
rns a sorted (wrt AlexComp) list of all partitions, including\n#      \+
   the emty one and the input partition par of partitions mu such that
 mu in par. These\n#         are the pertitions which potentially occu
re in the skew (and hence in the outer\n#         coproduct).\n#\npart
itionsInShape:=(par)->sort(ListTools:-Reverse([op(partitionsInShape_ge
n(par))]),AlexComp):\n#\n#\n#\n# CompNM returns a list of compositions
 of N with M parts\n#\nCompNM:=proc(N,M)\n   option `Copyright (c) B. \+
Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n          re
member;\n   local res,i;\n   if M<1 then return [] end if;\n   if M=1 \+
then return [N] end if;\n   if M=2 then return [seq([N-i,i],i=0..N)] e
nd if;\n   res:=[];\n   for i from N to 0 by -1 do\n     res:=[op(res)
,op(map(x->[i,op(x)],procname(N-i,M-1)))];\n   end do;\n   res;\nend p
roc:\n#\n# part2mset transforms a partition into multiset format, that
 is a composition\n#           which gives the multiplicities of parts
 [4,4,2,1,1] -> [2,1,0,2]\n#\npart2mset:=proc(part)\n  option `Copyrig
ht (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n  \+
        remember;\n  local m,mset,i;\n  if part=[0] then return [] end
 if;\n  m:=max(op(part));\n  mset:=[seq(0,i=1..m)];\n  for i from 1 to
 nops(part) do\n    mset[part[i]]:=mset[part[i]]+1;\n  end do;\n  mset
; \nend proc:\n#\n# mset2part transforms a partition in multi set repr
esentation into an ordinary partition\n#           represented by nonn
egative integer parts\n#\nmset2part:=proc(mset)\n  option `Copyright (
c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n      \+
    remember;\n  local prt,i;\n  prt:=[];\n  for i from 1 to nops(mset
) do\n    prt:=[i$mset[i],op(prt)]\n  end do;\n  if prt=[] then return
 [0] end if;\n  prt;\nend proc:\n#\n# conjpart gives the conjugated pa
rtition of the partition part\n#\nconjpart:=proc(part)\n  option `Copy
right (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`\n
         ,remember;\n  local len,res,ppart;\n  if part=[] or part=[0] \+
then return [0] end if;\n  len:=nops(part);\n  ppart:=part;\n  res:=[]
;\n  while ppart<>[] do\n    res:=[op(res),len$ppart[-1]];\n    ppart:
=map(x->if x=ppart[-1] then NULL else x-ppart[-1] end if,ppart);\n    \+
len:=nops(ppart);\n  end do;\n  res;\nend proc:\n#\n# zee gives the fa
ctor z(lambda) in the schur scalar product of power sums.\n#\n#\nzee:=
proc(part)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-200
9. All rights reserved.`\n         ,remember;\n  local mset;\n  mset:=
part2mset(part);\n  mul(i^mset[i]*mset[i]!,i=1..nops(mset));\nend proc
:\n#\n#  cmp2prtMult gives the multiplicity of the orbit of a composit
ion\n#              of its associated partition under the S_n\n#\ncmp2
prtMult:=proc(comp)\n  option `Copyright (c) B. Fauser & R. Ablamowicz
 2004-2009. All rights reserved.`,\n          remember;\n  local nc,pa
rt,f,cnt0;\n  nc:=nops(comp);\n  cnt0:=0;\n  part:=map(x->if x=0 then \+
cnt0:=cnt0+1; NULL else x end if,\n            sort(comp,(i,j)->if i>=
j then true else false end if) );\n  part:=map(x->if x=0 then NULL els
e x end if,part2mset(part));\n  if cnt0=0 then part:=part[1..-2] end i
f;\n  #################\n  f:=(ri,N)->mul(N-k,k=0..ri-1)/ri!;\n  #####
############\n  mul(f(part[k],nc+part[1]-add(part[m],m=1..k)),k=1..nop
s(part));\nend proc:\n#\n# cmp2part takes a composition and transforms
 it into a partition.\n#          This is a projection and a 'base poi
nt projection'.\n#\ncmp2part:=proc(comp)\n   option `Copyright (c) B. \+
Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n          re
member;\n   map(x->if x=0 then NULL else x end if,\n   sort(comp,(i,j)
->if i>=j then true else false end if) );\nend proc:\n#\n# part2Frob (
internal usage) maps a partition into Frobenius notation.\n#\npart2Fro
b:=proc(Part)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-
2009. All rights reserved.`,\n          remember;\n  local res,part;\n
  if Part=[0] or Part=[] then return [[],[]] end if;\n  part,res:=Part
,[[],[]];\n  while part<>[] do\n    res[1]:=[op(res[1]),part[1]-1];\n \+
   res[2]:=[op(res[2]),nops(part)-1];\n    part:=map(x->if x>1 then x-
1 else NULL end if,part[2..-1]);\n  end do;\n  res;\nend proc:\n#\n# F
rob2part (internal use) maps a partition in Frobenius notation into a \+
\n#           standard partition\n#\nFrob2part:=proc(LList)\n  option \+
`Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserve
d.`,\n          remember;\n  local res,llist,row;\n  if LList=[[],[]] \+
then return [0] end if;\n  res:=[LList[1][-1]+1,1$LList[2][-1]];\n  if
 nops(LList[1])=1 then return res end if;\n  llist:=[LList[1][1..-2],L
List[2][1..-2]];\n  while llist<>[[],[]] do\n     row:=[1$llist[2][-1]
];\n     res:=[llist[1][-1]+1,op(zip((i,j)->i+j,row,res,0))];\n     ll
ist:=[llist[1][1..-2],llist[2][1..-2]];  \n  end do;\n  res;\nend proc
:\n###################################################################
################\n#\n# T R U N C functions\n#\n#######################
############################################################\n#\n# tru
ncWT truncates the input to partitions of weight less or equal to the \+
seond \n#         argument N\n#\ntruncWT:=proc(x,N)\n  option `Copyrig
ht (c) B. Fauser & R. Ablamowicz 2004-2006. All rights reserved.`,\n  \+
remember;\n  local cf,tm,n1,plst1,plst2,i;\n  if type(x,`+`) then \n  \+
  return map(procname,x,N);\n  elif type(x,`*`) then \n    tm,cf:=sele
ctremove(type,x,symfktmonom);\n    return cf*procname(tm,N)\n  else\n \+
   if `+`(op(x))>N then return 0 else return x end if;\n  end if;\nend
 proc:\n#\n# truncLEN_mon truncates partitions of any type of symmetri
c function monoms\n#       to length less or equal to L\n#\ntruncLEN_m
on:=proc(sfkt,L)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 20
04-2006. All rights reserved.`;\n   if nops([op(sfkt)])<=L then\n     \+
return sfkt\n   else\n     return 0\n   end if;\nend proc:\n#\n# trunc
LEN truncates the partitions of a symmetric function polynom\n#       \+
to length smaller or euqlt to L, it is a linear function\n#\n#\ntruncL
EN:=proc(symfkt,L)\n  option `Copyright (c) B. Fauser & R. Ablamowicz \+
2004-2006. All rights reserved.`;\n  local cf,term;\nif symfkt=0 then \+
return 0 end if;\n  if type(symfkt,symfktmonom) then\n    truncLEN_mon
(symfkt,L)\n  elif type(symfkt,`*`) then\n    term,cf:=selectremove(ty
pe,symfkt,symfktmonom);\n    return cf*truncLEN_mon(term,L);\n  else\n
    map(procname,symfkt,L);\n  end if;\nend proc:\n###################
##############################################\n#\n# collect_sfkt coll
ects a polynomial with respect to an sfunction \n#      basis 's,p,m,h
,f,e' and returns the prefactors factorized.\n#      The basis is by d
efault the Schur function basis and may be\n#      altered by giving a
 letter from the set 's,p,m,h,f,e' as\n#      second argument.\n#\n###
##############################################################\ncollec
t_sfkt:=proc(X)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 200
4-2006. All rights reserved.`;\n  local x,lst,i,term,terms,termTbl,TYP
E;\n  if nargs=2 then\n    TYPE:=args[2];\n    if not member(TYPE,\{s,
p,m,h,f,e\}) then\n      error \"You picked a type '%1' which is not i
n my list of known types\\n\n             's,p,m,h,f,e' !\",TYPE;\n   \+
 end if;\n  else \n    TYPE:='s';\n  end if;\n  if x=0 then return 0 e
nd if;\n  x:=expand(X);\n  terms:=\{\}; \n  if type(x,cat(TYPE,fktmono
m)) then \n     return x;\n  elif type(x,cat(TYPE,fktterm)) then\n    \+
  return x;\n  elif type(x,`+`) then\n      lst:=[op(x)];\n      for i
 from 1 to nops(lst) do\n        if type(lst[i],cat(TYPE,fktmonom)) th
en\n          termTbl:=(lst[i])=1;\n        else\n          term:=sele
ct(type,lst[i],cat(TYPE,fktmonom));\n          terms:=\{op(terms),term
\};\n        end if;\n      end do;\n      if terms=\{1\} then\n      \+
  error \"I didn't find a basis element, provide a correct basis!\";\n
      end if;\n      return map(factor,collect(x,terms));\n  end if;\n
end proc:\n###########################################################
######\n#\n#  sfkt_terms returns a set of basis monoms of an input exp
ression. \n#      The basis is by default the Schur function basis and
 may be\n#      altered by giving a letter from the set 's,p,m,h,f,e' \+
as\n#      second argument.\n#\n######################################
###########################\nsfkt_terms:=proc(X)\n  option `Copyright \+
(c) B. Fauser & R. Ablamowicz 2004-2006. All rights reserved.`;\n  loc
al cf,x,lst,i,term,terms,termTbl,TYPE;\n  if nargs=2 then\n    TYPE:=a
rgs[2];\n    if not member(TYPE,\{s,p,m,h,f,e\}) then\n      error \"Y
ou picked a type '%1' which is not in my list of known types\\n 's,p,m
,h,f,e' !\",TYPE;\n    end if;\n  else \n    TYPE:='s';\n  end if;\n  \+
x:=expand(X);\n  terms:=\{\}; \n  if type(x,cat(TYPE,fktmonom)) then \+
\n     return \{x\};\n  elif type(x,cat(TYPE,fktterm)) then\n      ter
m,cf:=selectremove(type,x,cat(TYPE,fktterm));\n      return \{term\};
\n  elif type(x,`+`) then\n      lst:=[op(x)];\n      for i from 1 to \+
nops(lst) do\n        if type(lst[i],cat(TYPE,fktmonom)) then\n       \+
   terms:=\{op(terms),lst[i]\};\n        else\n          term:=select(
type,lst[i],cat(TYPE,fktmonom));\n          terms:=\{op(terms),term\};
\n        end if;\n      end do;\n      if terms=\{1\} then error \"Co
uldn't find a basis monom!\\nyou can provide a second argument with th
e name of the basis like 's', 'p', 'h', 'f', 'e' \\n\";\n      end if;
\n      return terms;\n  end if;\nend proc:\n#########################
########################################\n#\n# Functions related to th
e Lascoux Schuetzenberger algorithm \n#\n#          to multiply and sk
ew Schur functions\n#\n###############################################
##################\n#\n#\n# lehmerCodeToPermutation transform a Lehmer
 code of a permutation\n#           into the list representation of th
at permutation, that\n#           is the list of the image of the perm
utaion of of the\n#           standatd list [1..n]\n#\n#     Note: we \+
prune trailing fixed points, it the second variable is set to \"prune
\"\n#           including quotes\n#\n#   -- The algorithm use is the f
ollowing recursion:\n#   -- let ordLst be the orderd list [1..n]\n#   \+
-- \\pi_1 is the lement ordLst_\{code[1]+1\}\n#   -- remove the elemen
t ordLst_\{code[1]+1\} from the list ordList\n#   -- \\pi_2 is the lem
ent ordLst_\{code[2]+1\}\n#   -- remove the element ordLst_\{code[2]+1
\} from the list ordList\n#   -- repeat unless ordLst is empty\n#   --
 if \"prune\" is set, we skip trailing fixed points, that is\n#   -- w
e reduce the permutation from S_n (n=card(ordLst)) to a smaller\n#   -
- S_k which acts on the first [1..k] entries, in this way S_k is\n#   \+
-- canonically embedded into S_n for n>k.\n#\nlehmerCodeToPermutation:
=proc(code)\n  option remember;\n  local ordLst,i,idx,per,prune;\n  if
 nargs=2 and args[2]=\"prune\" then prune:=true; print(\"prune is true
 now\"); else prune:=false; end if;\n  ordLst:=[seq(i,i in 1..nops(cod
e))];\n  per:=[];\n  for i from 1 to nops(code) do\n     idx:=ordLst[c
ode[i]+1];\n     per:=[op(per),idx];\n     ordLst:=subs(idx=NULL,ordLs
t);\n  end do;\n  if prune=true then\n     i:=nops(per);\n     while p
er[i]=i and i>1 do\n        i:=i-1;\n        per:=per[1..-2];\n     en
d do;\n   end if;\n  per;\nend proc:\n#\n# permutationToLehmerCode tra
nsforms a permutation \\pi in list representation (image\n#           \+
  of \\pi acting on the standard set [1..n]) into the Lehmer code of t
he\n#             permutation\n#\n#     -- The Lehmer code of a permut
ation is given by code:=[l1,..,ln] with\n#     -- lk :=Card \{ j>k, \\
pi[k]>\\pi[j] \}\n#     -- The Lehmer code is a factorial number syste
m adapted to permutations\n#     -- since card S_n = n! This allows a \+
one-one relation between such codes\n#     -- and permutations.\n#    \+
 -- If S_k is embedded into S_n in such a way that S_k permuste the fi
rst [1..k]\n#     -- entries of the standard set while S_n permutes [1
..n], then the Lehmer code\n#     -- of a permutation S_k transforms u
nder this injection into the Lehmer code of\n#     -- \\pi in S_n by a
dding appropriatly many trailing zeros.\n#\npermutationToLehmerCode:=p
roc(per)\n  option remember;\n  local idx,lehmer,res,k,j;\n  if per=[]
 then return [] end if;\n  if \{op(per)\}<>\{seq(i,i in 1..nops(per))
\} then error \"input was not a permutation of the form (i1,i2,...in) \+
with entries ik in [1..n]\" end if;\n  if per=[] then return [0] end i
f;\n  lehmer:=[];\n  for k from 1 to nops(per)-1 do\n     idx:=0;\n   \+
  for j from k+1 to nops(per) do\n        if per[j]<per[k] then idx:=i
dx+1 end if;\n     end do;\n     lehmer:=[op(lehmer),idx];\n   end do;
\n  [op(lehmer),0];\nend proc:\n#\n# Descents takes a permutation pi a
nd returns the the list of descents of pi\n#         ++ the list of de
scents is in decreasing order\n#         ++ Descents describe importan
t facts about the structure of\n#         ++ reduced words representin
g permutations when written as\n#         ++ product of elementary tra
nspositions (i,i+1)\n#\nDescents:=proc(per)\n   option remember;\n   l
ocal des,i;\n   des:=[];\n   for i from 1 to nops(per)-1 do\n      if \+
per[i]>per[i+1] then des:=[i,op(des)]; end if;\n   end do;\n   des;\ne
nd proc:\n#\n# lehmerCodeToSchurFkt transforms a Lehmer code of a Gras
smannian permutation\n#         ++ that is a permutation which respres
ents a Schur function into\n#         ++ the Schurfunction with the co
rresponding partition lable\n#         ++ NOTE: No check is performed \+
if the input is a Lehmer code of a Grassmanian\n#         ++       per
mutation. This routine is meant for internal use mainly.\n#\nlehmerCod
eToSchurFkt:=proc(code)\n   option remember;\n   local i,prt;\n   ## +
+ no check included, user or algorithm must make sure\n   ## ++ input \+
represents a Schur function, otherwise return value is invalid_operati
on\n   prt:=[];\n   for i from 1 to nops(code) do\n     if code[i]<>0 \+
then\n       prt:=[code[i],op(prt)];\n     end if;\n   end do;\n   ## \+
-- possibly needs to be sorted, if vexillary permutations are used, if
 the\n   ## -- transition algorithm runs through, till the permutation
 has only one\n   ## -- descent, it seems to be unnecessary to sort he
re.\n   s[op(prt)]\nend proc:\n#\n# schurToLehmerCode implements the r
elation between a Schurfunction \{\\lambda\}^m\n#     \{\\lambda\}^m=s
_\\lambda(x1,...xm) in exactly m-variables and a Grassmannian\n#     L
ehmer code of a permutation (that is a permutation with exactly one de
scent.\n#     The parameter m gived the muner of variables. Caution, i
f m is too small,\n#     the Schur function may be unrepresentable (=0
) in that Z[x1,..,xm]\n#     An optimal embedding is reached by settin
g m=length(\\lambda), resulting in\n#     no leading zerors on teh Leh
mer code.\n#     We don't add trailing zeros, but keep the minimal num
ber of _required_\n#     trailing zeros\n#\nschurToLehmerCode:=proc(sf
kt,m)\n   option remember;\n   local code,i,par,wt;\n   par:=[op(sfkt)
];\n   wt:=`+`(op(sfkt));\n   code:=[];\n   for i from 1 to nops(par) \+
do\n      code:=[par[i],op(code)];\n   end do;\n   code:=[op(code),0$p
ar[1]];\n   [0$(m-nops(par)),op(code)];\nend proc:\n#\n# schurToLehmer
Code1 computes automatically the minimal embedding of the Schur functi
on\n#     in terms of Lehmer codes\n#\nschurToLehmerCode1:=proc(x) sch
urToLehmerCode(x,nops([op(x)])) end proc:\n#\n# skewToLehmerCode trans
forms two partitions of two schur functions\n#      which are to be sk
ewed into the Lehmer code representing the\n#      skew partitions sch
ur function.\n#\nskewToLehmerCode:=proc(sf1,sf2)\n   option remember;
\n   local prt,i,code,k,elem;\n   prt:=[op(sf1)];\n   code:=[];\n   fo
r i from 1 to nops(prt) do\n      code:=[prt[i],op(code)];\n   end do;
\n   code:=[op(code),0$code[-1]];\n   if sf2=s[0] then return code end
 if;\n   k:=nops(prt);\n   prt:=[op(sf2)];\n   for i from 1 to nops(pr
t) do\n      code[k+prt[i]]:=code[k]-prt[i];\n      code[k]:=0;\n     \+
 k:=k-1;\n   end do;\n   [op(code)];\nend proc:\n#\n# transition imple
ments an algorithmy by Lascoux and Schuetzernberger Lett. Math. Phys. \+
10 (1985) 111-124\n#      this paper does not give a full description \+
of the implemented code, but uses vexillary permutations.\n#      We u
se a variant of the algorithm described by Axel Konhner, who was also \+
helpful in proding\n#      details and further information, see:\n#   \+
   A. Kohner, Schubert polynomials and skew Schur functions, 1991\n#  \+
    A. Kohner, The use of Schubert polynomials in SYMCHAR (later SYMME
TRICA), 1991\n#      A further usefull resource is\n#      R. Winkel, \+
Recursive and combinatorial properties of Schubert polynomials, \n#   \+
              Sem. Lotharigien de Comb. Vol38 1996 B38c 29pp \n#\n#   \+
   The algorithms is as follows:\n#      input a permutation pi, not o
f Grassmanian type (two or more descents)\n#      1) compute the right
 most descent k\n#      2) swap the element pi[k] and the largest pi[l
] to the right smaller than pi[k]\n#      3) find all elements to the \+
left of k such that\n#         -- pi[l] is smaller than pi[k]\n#      \+
   -- there is no pi[j] with pi[l]<pi[j]<pi[k] for l<j<k\n#         pr
oduce all permutationes obtained by swapping the pi[l] with pi[k]\n#  \+
       Note: We had to add the following rule:\n#         -- If the se
arch for pi[l] returns no element, then return the partition\n#       \+
     which is obtained by shifting the Lehmer code of the _input_ part
ition\n#            by one to the right inserting a 0 at place 1\n#   \+
         [On the partition this means add a 1 to each part and concate
nate\n#              1 |_| 1+[pi]\n#      4) output the list of the pr
oduced permutations\n#\n#\ntransition:=proc(perIN)\n   option remember
;\n   local max,per,k,l,i,elem,res,sp_min,newper,code;\n   # -- per ne
eds to have nops(per)>2 check?\n   max:=nops(perIN);\n   per:=perIN;\n
   # -- ingone final fixed points\n   while per[max]=max do max:=max-1
; end do;\n   # -- find last descent\n   k:=max-1;\n   while per[k]<pe
r[k+1] do k:=k-1; end do;\n   # find largest per[l] to the right of pe
r[k] with per[l]<per[k]\n   l:=k+1;\n   elem:=per[l];\n   for i from k
+2 to max do\n      if per[i]<per[k] and elem<per[i] then elem:=per[i]
; l:=i end if;\n   end do;\n   ## -- switch places k,l, note elem:=per
[l]\n   per[l]:=per[k];\n   per[k]:=elem;\n   # -- find all elements l
eft to k which fulfill\n   # -- per[l]<per[k] and no element exists wi
th\n   # -- per[l\}<per[i]<per[k] for l<i<k\n   # -- switch these elem
ents and return the list or permutations\n   res:=[];\n   # -- find el
ements smaller per[k] to the left\n   # -- special case k=1\n   if k=1
 then return [per] end if;\n   l:=k-1;\n   sp_min:=0;  \n   while l>0 \+
do\n        if sp_min<per[l] and per[l]<per[k] then\n        # -- make
 new permutation with (l,k) switched\n        sp_min:=per[l];\n       \+
 newper:=per;\n        newper[l]:=per[k];\n        newper[k]:=per[l];
\n        res:=[op(res),newper];\n      end if;\n      # -- else proce
ed\n      l:=l-1; \n   end do;\n   ## A. Kohnert says keep this:\n   i
f l=0 and res=[] then\n   # -- However, we need to add a prefix 0 to t
he Lehmer code of perIN\n   # -- otherwise the algorithm cannot find a
n element in the left search\n      res:=[[1,seq(perIN[i]+1,i in 1..no
ps(perIN)-1)]]; \n   end if;\n   res;\nend proc:\n#\n#################
################################################\n#\n# basis transform
ations\n#\n###########################################################
######\n#\n# s_to_xM transforms an S-function into a polynom of x-mono
mials in\n#         N variables (x1,x2,...,xn) (N should be greater or
 equal\n#         to the weight of the partition.\n#\n#         <inter
nal use; users use the linear version s_to_x>\n#\ns_to_xM:=proc(sfkt,N
)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All ri
ghts reserved.`\n         ,remember;\n  local cmp;\n  cmp:=CompNM(`+`(
op(sfkt)),N);\n  add(KostkaPC([op(sfkt)],k)*x[op(k)],k=cmp);\nend proc
:\n#\n# x_to_sM gets a monomial and transforms it back into an S-funct
ion.\n#         This transformation is critical, since the transformat
ion matrix\n#         K is rectangular! The inverse is computes on the
 maximal rank\n#         subspace, and suitably normalized, so that th
e collextion of\n#         *all* x monomials which give rise to the sa
me S-functions\n#         adds up to the integral result\n#\n#        \+
 <internal use; users use the linear version x_to_s>\n#\nx_to_sM:=proc
(xfkt)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. A
ll rights reserved.`\n         ,remember;\n  local wgt,prt,KMat,tab,ta
bc,cmp,matT;\n  wgt:=`+`(op(xfkt));\n  prt:=PartNM(wgt,wgt);\n  KMat :
=evalm(linalg[matrix](nops(prt),nops(prt),(i,j)->KostkaPC(prt[i],prt[j
]))^(-1));\n  tab:=table([seq((prt[k])=k,k=1..nops(prt))]);\n  cmp:=Co
mpNM(wgt,nops([op(xfkt)]));\n  matT:=linalg[matrix](nops(cmp),nops(prt
),\n       (i,j)->1/cmp2prtMult(cmp[i])*KMat[tab[cmp2part(cmp[i])],tab
[prt[j]]]);\n  ## new index  \n  tabc:=1; while [op(xfkt)]<>cmp[tabc] \+
do tabc:=tabc+1; end do;\n  add(matT[tabc,k]*s[op(prt[k])],k=1..nops(p
rt));\nend proc:\n#\n# s_to_x linear version of the transformation of \+
S functions to x monomials\n#\ns_to_x:=proc(sfkt,weight)\n  option `Co
pyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`
,\n          remember;\n  local cf,term,lst;\n  if weight=0 then retur
n 1 end if;\n  if sfkt=0 then \n    return 0;\n  elif type(sfkt,`+`) t
hen \n    return map(procname,sfkt,weight)\n  elif type(sfkt,`*`) then
\n    term,cf:=selectremove(type,sfkt,sfktmonom);\n    return cf*procn
ame(term,weight)\n  else\n    s_to_xM(sfkt,weight);\n  end if; \nend p
roc:\n#\n# x_to_s linear version of the transformation of x monomials \+
to S functions\n#\nx_to_s:=proc(xfkt)\n  option `Copyright (c) B. Faus
er & R. Ablamowicz 2004-2009. All rights reserved.`,\n          rememb
er;\n  local cf,term,lst;\n  if type(xfkt,`+`) then \n    return map(p
rocname,xfkt)\n  elif type(xfkt,`*`) then\n    cf,term:=selectremove(t
ype,xfkt,\{'integer','fraction'\});\n    return cf*procname(term)\n  e
lse\n    x_to_sM(xfkt);\n  end if; \nend proc:\n######################
#########################################################\n#\n# h_to_s
 transformes a complete symmetric function into an s-function polynomi
al.\n#        \nh_to_sM:=proc(hfkt)\n  option `Copyright (c) B. Fauser
 & R. Ablamowicz 2004-2009. All rights reserved.`,\n          remember
;\n  if hfkt=0 then return 0 end if;\n  outer(op(map(i->s[i],[op(hfkt)
])));\nend proc:\nh_to_s:=proc(hfkt)\n  option `Copyright (c) B. Fause
r & R. Ablamowicz 2004-2009. All rights reserved.`;\n  local n1,prt,cf
,term,lst;\n  if hfkt=0 then return 0 end if;\n  if not type(hfkt,hfkt
polynom) then \n     error(\"wrong basis as input, need complete symme
tric functions\"); \n  end if;\n  if hfkt=h[0] then return s[0] end if
;\n  if type(hfkt,`+`) then \n    return map(procname,hfkt)\n  elif ty
pe(hfkt,`*`) then\n    term,cf:=selectremove(type,hfkt,hfktmonom);\n  \+
  return cf*procname(term)\n  else\n    return h_to_sM(hfkt)\n  end if
; \nend proc:\n#######################################################
########################\n#\n# s_to_h transformes a s-function polynom
ial into complete symmetric functions.\n#\n# WARNING: SLOW!! Uses the \+
inverse Kostka Matrix\n#          better use the Jacobi-Trudi formula!
\n#        \ns_to_hM:=proc(sfkt)\n  option `Copyright (c) B. Fauser & \+
R. Ablamowicz 2004-2009. All rights reserved.`,\n          remember;\n
  local prt,N,KI,i;\n  KI:=evalm(rhs(KostkaTable(`+`(op(sfkt))))^(-1))
;\n  N:=`+`(op(sfkt));\n  prt:=PartNM(N,N);\n  i:=1: while prt[i]<>[op
(sfkt)] do i:=i+1 end do;\n  add(KI[j,i]*h[op(prt[j])],j=1..nops(prt))
;\nend proc:\ns_to_hMat:=proc(sfkt)\n  option `Copyright (c) B. Fauser
 & R. Ablamowicz 2004-2009. All rights reserved.`;\n  local n1,prt,cf,
term,lst;\n  if sfkt=0 then return 0 end if;\n  if sfkt=s[0] then retu
rn h[0] end if;\n  if type(sfkt,`+`) then \n    return map(procname,sf
kt)\n  elif type(sfkt,`*`) then\n    term,cf:=selectremove(type,sfkt,s
fktmonom);\n    return cf*procname(term)\n  else\n    return s_to_hM(s
fkt)\n  end if; \nend proc:\n#########################################
######################################\n#\n# s_to_h recursive faster v
ersion\n#\ns_to_h:=proc(x)\n  option `Copyright (c) B. Fauser & R. Abl
amowicz 2004-2009. All rights reserved.`,\n  remember;\n  local term,c
f;\n  if x=0 then return 0 end if;\n  if x=s[0] then return h[0] end i
f;\n  if type(x,`+`) then\n     map(procname,x)\n  elif type(x,`*`) th
en\n    term,cf:=selectremove(type,x,sfktmonom);\n    return cf*procna
me(term);\n  else\n    return h[op(x)] + procname(x-h_to_s(h[op(x)]));
\n  end;\nend proc:\n#\n##############################################
#################################\n#\n# sfktmon_to_hmatrix transforms \+
a sfktmonom (Schur basis function) into\n#   -- a matrix in such a way
, that the determinant of the matrix w.r.t\n#   -- the outer product y
ields back the Schur function monom.\n#   -- the entries of the matrix
 are one part Schur functions, and hence\n#   -- can be multiplies by \+
teh outer product in teh complete symmetric function\n#   -- basis, th
is gives teh Jacobi-Trudi formula for Schur functions\n#   -- s_\\lamb
da = det( h_[\\lambda_i-i+j]) \n#   -- (there is a similar formula for
 the elementray symetric functions)\n#\nsfktmon_to_hmatrix:=proc(x)\n \+
 local l,f,dim,lst;\n  l,dim:=nops([op(x)]),0;\n  if nargs=2 then l:=m
ax(l,args[2]) end if;\n  lst:=[op(x),0$(l-nops([op(x)]))];\n  f:=(x)->
if x<0 then 0 else h[x] end if;\n  evalm(linalg[matrix](l,l,(i,j)->f(l
st[i]-i+j)));\nend proc:\n#\n# s_to_hmat transforms an sfunction into \+
a Toeplitz matrix of complete one part\n#    -- symmetric functions. I
t takes as a second argument a dimension, which can\n#    -- be taken \+
to be the largest length of all involved partitions in teh sfktpolynom
\n#    -- see : \"maxlengthSymFkt()\" below\n#\ns_to_hmat:=proc(x)\n  \+
option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights \+
reserved.`,\n  remember;\n  local cf,tm,dim;\n  if nargs=2 then dim:=a
rgs[2] else dim:=NULL end if;\n  if type(x,`+`) then \n    return map(
procname,x,dim);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(ty
pe,x,sfktmonom);\n    return cf*procname(tm,dim)\n  else\n    sfktmon_
to_hmatrix(x,dim);  \n  end if;\nend proc:\n#\n# evalJacobiTrudiMatrix
 given an Jacobi-Trudin matrix (say from sfktmon_to_hmatrix)\n#    -- \+
this function evaluates the determinant w.r.t. the outer product in th
e \n#    -- complete symmetric function basis.\n#    -- NOTE: one can \+
give a multiplication as second argument! \n#\nevalJacobiTrudiMatrix:=
proc(matrix)\n  local mdim,lst,i,k,l,fun;\n  if nargs=2 then fun:=args
[2] else fun:=outerH end if;\n  mdim:=linalg[rowdim](matrix);\n  if md
im=1 then return matrix[1,1] end if;\n  lst:=[seq(i,i=1..mdim)];\n  ad
d((-1)^(i-1)*expand(fun(matrix[i,1],\n       procname(linalg[submatrix
](\n     matrix,map(x->if x=i then NULL else x end if,lst),[seq(k,k=2.
.mdim)]))))\n     ,i=1..mdim);\nend proc:\n#\n# s_to_hJT linear versio
n of the transition from the s-basis into the h-basis\n#   -- useing t
he Jacobi-Trudi formula\n#\ns_to_hJT:=proc(x)\n  option `Copyright (c)
 B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n  rememb
er;\n  local cf,tm,fun;\n  if nargs=2 then fun:=args[2] else fun:=oute
rH end if;\n  if type(x,`+`) then \n    return map(procname,x);\n  eli
f type(x,`*`) then \n    tm,cf:=selectremove(type,x,sfktmonom);\n    r
eturn cf*procname(tm)\n  else\n    evalJacobiTrudiMatrix(sfktmon_to_hm
atrix(x),fun);  \n  end if;\nend proc:\n#\n# maxlengthSymFkt gives the
 maximal length of a partition index in a\n#  -- symfktpolynom of type
 \{s,p,m,h,f,e\}\n#\n#\nmaxlengthSymFkt:=proc(x)\n  option `Copyright \+
(c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n  rem
ember;\n  local cf,tm;\n  if type(x,`+`) then \n    return max(op(map(
procname,[op(x)])));\n  elif type(x,`*`) then \n    tm,cf:=selectremov
e(type,x,symfktmonom);\n    return nops([op(tm)])\n  else\n    return \+
nops([op(x)])  \n  end if;\nend proc:\n###############################
################################################\n#\n# etoh is the tra
nsition from elementary to complete symmetric functions for\n#     -- \+
one part elementary symmetric functions e_n. It is done using the fact
\n#     -- that the generating functions H_t=\\sum_n \{n]t^n and E_-t \+
= \\sum_m (-1)^m \{1^m\}t^m\n#     -- are inverse series under the poi
ntwise product of functions\n#     -- Note: H_t = M_t and E_-t = M_t[-
s_1] = \\sum_n S(\{n\})t^n\n#\netoh:=proc(x)\n  local n;\n  n:=op(x);
\n  if n=1 then return h[1] elif n=0 then return h[0] end if;\n  add((
-1)^(n-r-1)*outerH(h[n-r],procname(e[r])),r=0..n-1);\nend proc:\n#\n# \+
e_to_hM is the basis change e_to_h on a single efktmonom, it uses the \+
fact that the '\n#     -- elementary symmetric functions for a multipl
icative basis and employs `etoh'\n#\ne_to_hM:=proc(x)\n  local prt;\n \+
 prt:=[op(x)];\n  outerH(op(map(etoh,map(x->[x],prt))));\nend proc:\n#
\n# e_to_h linear version of the transformation of elementary function
s into complete functions\n#\ne_to_h:=proc(efkt)\n  local cf,term,lst;
\n  if efkt=0 then return 0 end if;\n  if efkt=e[0] then return h[0] e
nd if;\n  if type(efkt,`+`) then \n    return map(procname,efkt)\n  el
if type(efkt,`*`) then\n    term,cf:=selectremove(type,efkt,efktmonom)
;\n    return cf*procname(term)\n  else\n    e_to_hM(efkt);\n  end if;
 \nend proc:\n#\n# e_to_sM is the transition from elementary symmetric
 function monoms to Schur functions\n#    -- it uses the fact that e_k
=s[1,1,...,1] (k ones) \n#\ne_to_sM:=proc(x)\n  outerS(op(map((x)->s[1
$x],[op(x)])));\nend proc:\n#\n# e_to_s linear version of the transfor
mation of elementary functions into Schur functions\n#\ne_to_s:=proc(e
fkt)\n  local cf,term,lst;\n  if type(efkt,`+`) then \n    return map(
procname,efkt)\n  elif type(efkt,`*`) then\n    term,cf:=selectremove(
type,efkt,efktmonom);\n    return cf*procname(term)\n  else\n    e_to_
sM(efkt);\n  end if; \nend proc:\n#\n# e_to_mM ist the basis change fr
om e-fkt to m-fkt on monomials\n#\ne_to_mM:=proc(x)\n  option `Copyrig
ht (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;\n  \+
local lst;\n  lst:=[op(x)];\n  outerM(op(map(x->m[1$x],lst)));\nend pr
oc:\n#\n# e_to_m is the linear basis change from elementary symmetric \+
functions to\n#        monomial symmetric functions\n#\ne_to_m:=proc(x
)\n   option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All r
ights reserved.`,\n          remember;\n   local cf,tm;\n   if x=0 the
n return 0 end if;\n   if x=e[0] then return m[0] end if;\n   if type(
x,`+`) then \n     return map(procname,x);\n   elif type(x,`*`) then \+
\n     tm,cf:=selectremove(type,x,efktmonom);\n     return cf*procname
(tm,x)\n   else\n     e_to_mM(x);  \n   end if;\n end proc:\n#########
######################################################################
\n#\n# h_to_mM is the basis transformation from complete to monomials \+
ymmetric functions\n#   -- it is computed along the lines of Rota-Stei
n using the multiplicativity of \n#   -- the complete basis. The copro
duct is used in disguise in the formula\n#   -- h_(n) = \\sum_\{\\mu|-
n\} m_\\mu, and the multiplicativity is translated into\n#   -- the no
nmultiplicative outerM product.\n#\nh_to_mM:=proc(x)\n  option `Copyri
ght (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n \+
         remember;\n  local lst,f;\n  if x=0 then \n    return 0\n  el
if x=h[0] then\n    return m[0]\n  end if;\n  #  -- h(n) = \\sum_rho p
[rho] = \\sum_\\rho \\prod_i p[rho_i]\n  #  -- and use p(n)==m(n)\n  f
:=(x)->add(m[op(i)],i=PartNM(x,x));\n  lst:=[op(x)];\n  outerM(op(map(
f,lst)));\nend proc:\n#\n# h_to_m linear version of the transformation
 of complete functions into monomial functions\n#\nh_to_m:=proc(hfkt)
\n   option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All ri
ghts reserved.`;\n  local cf,term,lst;\n  if type(hfkt,`+`) then \n   \+
 return map(procname,hfkt)\n  elif type(hfkt,`*`) then\n    term,cf:=s
electremove(type,hfkt,hfktmonom);\n    return cf*procname(term)\n  els
e\n    h_to_mM(hfkt);\n  end if; \nend proc:\n#\n# h_to_pM is the tran
sformation from h-basis monomials to p-bases\n#\nh_to_pM:=proc(x)\n  o
ption `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights r
eserved.`,\n         remember;\n  local lst,f;\n  f:=(x)->add(p[op(i)]
,i=PartNM(x,x));\n  if x=0 then \n    return 0\n  elif x=h[0] then\n  \+
  return m[0]\n  end if;\n  lst:=[op(x)];\n  outerP(op(map(f,lst))); \+
\nend proc:\n#\n# h_to_p linear version of the transformation of compl
ete functions into power sums\n#\nh_to_p:=proc(hfkt)\n   option `Copyr
ight (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;\n
  local cf,term,lst;\n  if type(hfkt,`+`) then \n    return map(procna
me,hfkt)\n  elif type(hfkt,`*`) then\n    term,cf:=selectremove(type,h
fkt,hfktmonom);\n    return cf*procname(term)\n  else\n    h_to_pM(hfk
t);\n  end if; \nend proc:\n##########################################
#####################################\n#\n# p_to_s transformes a power
 sum polynomial into an s-function polynomial.\n#        This version \+
was checked against SCHUR\n#\np_to_s:=proc(pfkt)\n  option `Copyright \+
(c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;\n  loc
al n1,prt,cf,term,lst;\n  if pfkt=0 then return 0 end if;\n  if pfkt=p
[0] or pfkt=p[] then return s[0] end if;\n  if type(pfkt,`+`) then \n \+
   return map(procname,pfkt)\n  elif type(pfkt,`*`) then\n    term,cf:
=selectremove(type,pfkt,pfktmonom);\n    return cf*procname(term)\n  e
lse\n    n1:=`+`(op(pfkt));   \n    prt:=PartNM(n1,n1);\n    add(s[op(
i)]*MurNak([op(pfkt)],i),i=prt);\n  end if; \nend proc:\n#############
##################################################################\n#
\n# p_to_s recursive version INACTIVE about 10 times slower than the c
ombinatorial\n#        version using the Murnaghan Nakayama rule\n#\n#
######################################################################
########\n#p_to_sM:=proc(x)\n#  option remember;\n#  local k,lst;\n#  \+
if x=0 then return 0 end if;\n#  if nops([op(x)])=1 then\n#    return \+
s[op(x)]+add((-1)^k*s[op(x)-k,1$k],k=1..op(x)-1);\n#  else\n#    lst:=
[op(x)];\n#    return outer(op(map((a)->s[op(a)]+add((-1)^k*s[op(a)-k,
1$k],k=1..op(a)-1) ,lst)));\n#  end if;\n#end proc:\n#\n#p_to_s2:=proc
(x)\n#  local cf,term;\n#  if x=0 then return 0 end if;\n#  if type(x,
`+`) then\n#    return map(procname,x);\n#  elif type(x,`*`) then\n#  \+
  term,cf:=selectremove(type,x,pfktmonom);\n#    return expand(cf*proc
name(term));\n#  else\n#    return p_to_sM(x);\n#  end if;\n#end proc:
\n####################################################################
############\n#\n# s_to_p transformes an s-function into power sums.\n
#        This version was checked against SCHUR, but *differs*\n#     \+
   in that effect, that it does not introduce an artificial \n#       \+
 factor n! to avaoid fractional coefficients\n#\n#\ns_to_p:=proc(xfkt)
\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rig
hts reserved.`;\n  local cf,term,lst,mat,np,prt,i;\n  if xfkt=0 then r
eturn 0 end if;\n  if xfkt=s[0] then return p[0] end if;\n  if type(xf
kt,`+`) then \n    return map(procname,xfkt)\n  elif type(xfkt,`*`) th
en\n    term,cf:=selectremove(type,xfkt,sfktmonom);\n    return cf*pro
cname(term)\n  else\n    np:=`+`(op(xfkt));\n    prt:=PartNM(np,np);  \+
 \n    i:=1:\n    while prt[i]<>[op(xfkt)] do i:=i+1 end do;\n    #\n \+
   #+++ use the Murnaghan-Nakayama rules directly without the matrix i
nversion\n    #\n    add(1/zee(prt[k])*MurNak(prt[k],prt[i])*p[op(prt[
k])],k=1..nops(prt));\n  end if; \nend proc:\n########################
#######################################################\n#\n# s_to_e t
ransformes a s-function polynomial into elementary symmetric functions
.\n#\n# WARNING: SLOW!! Uses the inverse Kostka Matrix\n#          bet
ter use the Jacobi-Trudi formula!\n#        \ns_to_eM:=proc(sfkt)\n  o
ption `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights r
eserved.`,\n          remember;\n  local prt,N,KI,J,i;\n  N:=`+`(op(sf
kt));\n  prt:=PartNM(N,N);\n  J:=linalg[matrix](nops(prt),nops(prt),(i
,j)->if nops(prt)+1-i=j then 1 else 0 end if);\n  KI:=evalm(evalm(J &*
 rhs(KostkaTable(`+`(op(sfkt)))))^(-1));\n  i:=1: while prt[i]<>[op(sf
kt)] do i:=i+1 end do;\n  add(KI[j,i]*e[op(prt[j])],j=1..nops(prt));\n
end proc:\ns_to_e:=proc(sfkt)\n  option `Copyright (c) B. Fauser & R. \+
Ablamowicz 2004-2009. All rights reserved.`;\n  local n1,prt,cf,term,l
st;\n  if sfkt=0 then return 0 end if;\n  if sfkt=s[0] then return e[0
] end if;\n  if type(sfkt,`+`) then \n    return map(procname,sfkt)\n \+
 elif type(sfkt,`*`) then\n    term,cf:=selectremove(type,sfkt,sfktmon
om);\n    return cf*procname(term)\n  else\n    return s_to_eM(sfkt)\n
  end if; \nend proc:\n#\n# s_to_mM basis change from Schur functions \+
to monomial symmetric functions\n#\ns_to_mM:=proc(sfkt)\n  option `Cop
yright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,
\n         remember;\n  local prt,pt,k;\n  if sfkt=0 then \n    return
 0\n  elif sfkt=s[0] then \n    return m[0];\n  else\n    prt:=PartNM(
`+`(op(sfkt)),`+`(op(sfkt)));\n    add(subs(s[0]=1,Scalar(sfkt,outer(o
p(map(k->s[k],pt)))))*m[op(pt)], pt in prt)\n  end if;\nend proc:\n#\n
# s_to_m linear basis change from Schur functions to monomial symmetri
c functions\n#\ns_to_m:=proc(x)\n  option `Copyright (c) B. Fauser & R
. Ablamowicz 2004-2009. All rights reserved.`;\n  local cf,tm;\n  if t
ype(x,`+`) then \n    return map(procname,x);\n  elif type(x,`*`) then
 \n    tm,cf:=selectremove(type,x,sfktmonom);\n    return expand(cf*pr
ocname(tm))\n  else\n    s_to_mM(x,N);  \n  end if;\nend proc:\n#\n# m
_to_sM basis change from monomial to Schur functions\n#\nm_to_sM:=proc
(mfkt)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. A
ll rights reserved.`,\n         remember;\n  local prt,pt,k;\n  if mfk
t=0 then \n    return 0\n  elif mfkt=m[0] then \n    return s[0];\n  e
lse\n    prt:=PartNM(`+`(op(mfkt)),`+`(op(mfkt)));\n    add(subs(s[0]=
1,ScalarMH(mfkt,s_to_h(s[op(pt)])))*s[op(pt)], pt in prt)\n  end if;\n
end proc:\n#\n# m_to_s linear basis change from monomial to Schur func
tions\n#\nm_to_s:=proc(x)\n  option `Copyright (c) B. Fauser & R. Abla
mowicz 2004-2009. All rights reserved.`;\n  local cf,tm;\n  if type(x,
`+`) then \n    return map(procname,x);\n  elif type(x,`*`) then \n   \+
 tm,cf:=selectremove(type,x,mfktmonom);\n    return expand(cf*procname
(tm))\n  else\n    m_to_sM(x,N);  \n  end if;\nend proc:\n#\n# p_to_mM
 is an internal function computing the transition from a power sum mon
omial\n#         into a monomial symmetric function. Internal use only
.\n#\np_to_mM:=proc(x)\n  option `Copyright (c) B. Fauser & R. Ablamow
icz 2004-2009. All rights reserved.`,\n          remember;\n  if x=0 t
hen return 0 end if;\n  if nops([op(x)])<1 then return m[0] end if;\n \+
 outerM(seq(m[op([op(x)][k])],k=1..nops([op(x)])))\nend proc:\n#\n# p_
to_m linear version of the transformation of power sums into monomial \+
functions\n#\np_to_m:=proc(pfkt)\n  option `Copyright (c) B. Fauser & \+
R. Ablamowicz 2004-2009. All rights reserved.`;\n  local cf,term,lst;
\n  if type(pfkt,`+`) then \n    return map(procname,pfkt)\n  elif typ
e(pfkt,`*`) then\n    term,cf:=selectremove(type,pfkt,pfktmonom);\n   \+
 return cf*procname(term)\n  else\n    p_to_mM(pfkt);\n  end if; \nend
 proc:\n#\n# m_to_pM transferes monomial symmetric function basis mono
ms into power sum symmetric\n#         functions. Internal use only. \+
\n#\n# SLOW!! This routine uses matrix inversion and not a direct comb
inatorial algorithm !!! \n#\nm_to_pM:=proc(mfkt)\n  option `Copyright \+
(c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n     \+
     remember;\n  local nm,np,mat,prt,k;\n  if mfkt=0 then return 0 en
d if;\n  if mfkt=m[0] then return p[0] end if;\n  nm:=`+`(op(mfkt));\n
  prt:=PartNM(nm,nm);\n  np:=nops(prt);\n  mat:=linalg[matrix](np,np,(
i,j)->coeff(p_to_mM(prt[i]),m[op(prt[j])]));\n  mat:=evalm(mat^(-1));
\n  k:=1: while prt[k]<>[op(mfkt)] do k:=k+1; end do:\n  add(mat[k,i]*
p[op(prt[i])],i=1..nops(prt));\nend proc:\n#\n# m_to_p linear version \+
of the transformation of monomial functions into power sums\n#\nm_to_p
Mat:=proc(mfkt)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 200
4-2009. All rights reserved.`;\n  local cf,term,lst;\n  if type(mfkt,`
+`) then \n    return map(procname,mfkt)\n  elif type(mfkt,`*`) then\n
    term,cf:=selectremove(type,mfkt,mfktmonom);\n    return cf*procnam
e(term)\n  else\n    m_to_pM(mfkt);\n  end if; \nend proc:\n##########
#####################################################\n#\n# m_to_p rec
ursive faster version\n#\n############################################
###################\nm_to_p:=proc(x)\n  option `Copyright (c) B. Fause
r & R. Ablamowicz 2004-2009. All rights reserved.`,\n  remember;\n  lo
cal term,cf,y,const;\n  if x=0 then return 0 end if;\n  if x=m[0] then
 return p[0] end if;\n  if type(x,`+`) then\n     map(procname,x)\n  e
lif type(x,`*`) then\n    term,cf:=selectremove(type,x,mfktmonom);\n  \+
  return cf*procname(term);\n  else\n    y:=p_to_m(x);\n    const:=sub
s(s[0]=1, ScalarMH(y,h[op(x)]));\n    return p[op(x)]/const+ procname(
x-y/const);\n  end;\nend proc:\n######################################
###########################################\n#\n# m_to_hM is the basis
 change from monomial to complete symmetric functions\n#         it us
es the m_to_p function to evaluate the Scalar product in terms\n#     \+
    of poer sum symmetric functions\n#\n##############################
###################################################\nm_to_hM:=proc(x)
\n  local prt,pt;\n  if x=0 then return 0 end if;\n  if x=m[0] then re
turn h[0] end if;\n  prt:=[op(PartNM(`+`(op(x)),`+`(op(x))))];\n  add(
 subs(s[0]=1, ScalarP( m_to_p(x), m_to_p(m[op(pt)]) ))*h[op(pt)] ,pt i
n prt);\nend proc:\n##################################################
###############################\n#\n# m_to_h is the linear version of \+
m_to_pM basis change from monomial to\n#        complete symmetrc func
tions\n#\n############################################################
#####################\nm_to_h:=proc(x)\n  local cf,term;\n  if type(x,
`+`) then\n    return map(procname,x);\n  elif type(x,`*`) then\n    t
erm,cf:=selectremove(type,x,mfktmonom);\n    return expand(cf*procname
(term));\n  else\n    return m_to_hM(x);\n  end if; \nend proc:\n#\n##
#############################################################\n#\n# m_
to_e transformation from m-bases to p-bases\n#\n######################
#########################################\nm_to_e:=proc(x)\n  option `
Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved
.`,\n  remember;\n  local term,cf,y,const,len,mred;\n  if x=0 then ret
urn 0 end if;\n  if x=m[0] then return e[0] end if;\n  if type(x,`+`) \+
then\n     map(procname,x)\n  elif type(x,`*`) then\n    term,cf:=sele
ctremove(type,x,mfktmonom);\n    return cf*procname(term);\n  else\n  \+
  len:=nops([op(x)]);\n    mred:=subs(0=NULL,m[ op([op(x)]-[1$len]) ])
;\n    if mred=m[] then mred:=m[0] end if;\n    #const:=coeff(outerM(o
p(map(z->m[op(z)],[op(x)]))),m[1$`+`(op(x))]);\n    return outerE( e[l
en] , procname( mred ))\n          - procname( outerM(m[1$len],  mred \+
) - x);\n  end;\nend proc:\n##########################################
#####################\n###############################################
################\n#\n# makeRimRep is a cast from a partition into a re
presentation of a \n#            partition by noting its E-N direction
s by 1-0 symbols\n#            This sequence is infinite having infini
t many leading 0\n#            and traling 1s (which are of course not
 stored)\n#\nmakeRimRep:=proc(part)\n   option `Copyright (c) B. Fause
r & R. Ablamowicz 2004-2009. All rights reserved.`\n          ,remembe
r;\n   local n1,diff,res,i;\n   n1:=nops(part);\n   diff:=[part[-1],se
q(-part[n1+1-i]+part[n1-i],i=1..n1-1)];\n   res:=[];\n   for i from 1 \+
to nops(diff) do\n      res:=[op(res),seq(1,j=1..diff[i]),0];\n   end \+
do;\n   res;\nend proc:\n#\n#  removeRimHook removes a rim hook (edgew
ise conected boundary strip)\n#                of length hocklength in
 all possible ways. It returns \n#                a list with the rimr
epresented partitions of the remaining\n#                part of the p
artition and a list with the rimheight attached to\n#                t
he removed hoocks.\n#\nremoveRimHook:=proc(rimrep,hooklength)\n   opti
on `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights rese
rved.`,\n          remember;\n   local i,j,mult,redrimrep,rimhieght,nr
r,tmprim,del0,del1;\n   redrimrep:=[];\n   rimhieght:=[];\n   nrr:=nop
s(rimrep);\n   for i from 1 to nrr-1 do\n     if rimrep[i]=1 then\n   \+
    for j from i+1 to nrr do\n         if rimrep[j]=0 then\n          \+
 if j-i=hooklength then\n             tmprim:=rimrep;\n             tm
prim[i]:=0;\n             tmprim[j]:=1; \n             redrimrep:=[op(
redrimrep),tmprim];\n             rimhieght  :=[op(rimhieght),\n      \+
                   `+`(op(map(x->if x=0 then 1 else 0 end if,[seq(tmpr
im[k],k=i+1..j-1)])))] \n           end if;              \n         en
d if;  \n       end do;   \n     end if;\n   end do;\n###############
\n      del0:=proc(lst)\n        local flag;\n        flag:=false;\n  \+
      map(x->if x=0 and flag=false then return NULL else flag:=true; r
eturn x end if,lst); \n      end proc:\n      del1:=proc(lst)\n       \+
 local flag,f,res,i;\n        flag:=false;\n        f:=x->if x=1 and f
lag=false then return NULL else flag:=true; return x end if;\n        \+
res:=[];\n        for i from nops(lst) to 1 by -1 do\n          res:=[
f(lst[i]),op(res)];\n        end do; \n      end proc:\n##############
##    \n   map(del0,map(del1,redrimrep)),rimhieght;\nend proc:\n#\n# M
urNakRim This is the function which computes the Murnaghan Nakayama ru
le\n#           in terms of the rim representation of a shape. It is i
nternal,\n#           since rim representations of shapes are not supp
orted on the user \n#           side of the package.\n#\nMurNakRim:=pr
oc(rimRep,part2)\n   option `Copyright (c) B. Fauser & R. Ablamowicz 2
004-2009. All rights reserved.`,\n          remember;\n   local pt1,pt
2,lst,sign;\n   if nops(part2)=1 then\n      lst,sign:=removeRimHook(r
imRep,part2[1]);\n      return add((-1)^i,i=sign);\n   else\n      pt1
:=part2[1];\n      pt2:=part2[2..-1];\n      lst,sign:=removeRimHook(r
imRep,pt1);\n      return add((-1)^sign[i]*procname(lst[i],pt2),i=1..n
ops(lst));\n   end if;\nend proc:\n#\n# MurNak This function provides \+
the interface for the function MurNakRim to\n#        compute the Murn
aghan-Nakayama rule. This function returns the character\n#        val
ue of an S_n character with cycletype part1 on an element of S_n\n#   \+
     with cycletype part2.\n#\n# NOTE:  MurNak should be defined as sc
alar(s[part1],p[part2]) which is the\n#        _transpodes_ of the pre
sent MurNak!\n#\nMurNak:=proc(part1,part2)\n  option `Copyright (c) B.
 Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n          r
emember;\n  if `+`(op(part1))<>`+`(op(part2)) then \n    # -- This fun
ction is graded, for different grades return zero \n    return 0;\n  e
lse\n    # -- else use MurNakRim which needs a rim representation in t
he first argument\n    # -- MurNak is _not_ symmetric in its entries\n
    return MurNakRim(makeRimRep(part2),part1);\n  end if;\nend proc:\n
#\n# CharHook compute the character <sfkt,pfkt> if pfkt is a one part \+
partition power\n#          sum. The result is zero unless sfkt=\{a+1,
1^b\} is a Hook in which case\n#          the value of the character i
s (-1)^b, the height of the hook (leglength)\n#\nCharHook:=proc(sfkt,p
fkt)\n   option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. Al
l rights reserved.`,\n          remember;\n   local spart,ppart,ns,np;
\n   spart:=[op(sfkt)];\n   ppart:=[op(pfkt)];\n   np:=ppart[1];\n   n
s:=`+`(op(spart));\n   if ns<>np then return 0 end if;\n## -- check if
 s is a hook\n   if spart[1]+nops(spart)-1<>ns then return 0 end if;\n
   (-1)^(nops(spart)-1);    \nend proc:\n#\n# sq_coeff returns the squ
are of the coefficients of a symmetric\n#          function polynomial
 of a certain type.\n#\n#\nsq_coeff:=proc(x,typ::type)\n  option `Copy
right (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;
\n  local  lst;\n  if x=0 then \n    return 0\n  elif type(x,`+`) then
 \n    lst:=[op(x)];\n  else \n    lst:=[x];\n  end if;\n  lst:=map(x-
>if type(x,`*`) then remove(type,x,typ) else 1 end if,lst);\n  add(i^2
,i=lst);\nend proc:\n#\n#\n#\n# MurNak2 is a function which as a proof
 of concept shows how the Murnaghan Nakayama\n#         rule can be ev
aluatedon base of the Littlewood Richardson rule and the\n#         ch
aracter formula on Hook Shapes \\Chi^\\lambda_n=Scalar(s_\\lambda,p[n]
). It\n#         is much slower than the rimRep based function.\n#\n# \+
WARINING: MurNak2 needs FLAT and MLIN which make functions associative
 and multilinear\n#         This should be replaced by a better versio
n of 'define' which specifies not\n#         the base ring, but the ty
pes of the generating basis elemnts.\n#\nMurNak2:=proc(sfkt,pfkt)\n   \+
option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights \+
reserved.`\n          ,remember;\n   local spart,ppart,ns,np,sw,CH;\n \+
  spart:=[op(sfkt)];\n   ppart:=[op(pfkt)];\n#   sw:=proc() T(args[1],
args[3],args[2],args[4]) end proc:\n#   CH:=proc() CharHook(args[1],ar
gs[2])*MurNak2(args[3],args[4]) end proc:\n   CH:=(a1,a2,a3,a4) -> Cha
rHook(a1,a3)*MurNak2(a2,a4): \n   if nops(pfkt)=1 then \n      return \+
CharHook(sfkt,pfkt);\n   else\n     T(subs(`&t`=T,couter(sfkt)),s[ppar
t[1]],s[op(ppart[2..-1])]);\n     FLAT(eval(subs(T=MLIN,%)));\n#     e
val(subs(T=sw,%));\n     eval(subs(T=CH,%));\n   end if;\nend proc:\n#
#######################################\n#\n# dimSN_mon computes the d
imension of an SN character\n#           according to the hook rule fo
r an Sn character\n#           s[lambda] (Schur function monom)\n#    \+
       ++ dimSN(s[\\lambda]) = \n#           ++   factorial(|\\lambda|
)/\\prod_\{i,j\} h_ij  where\n#           ++   h_ij is the length of t
he hook at position (i,j)\n#           ++   in the Young diagram of \\
lambda \n#\n#\ndimSN_mon:=proc(x)\n  option `Copyright (c) B. Fauser &
 R. Ablamowicz 2004-2009. All rights reserved.`,remember;\n  local par
t,part_conj,np,i,j,hooks;\n  part:=[op(x)];\n  if part=[0] then return
 0 end if;\n  np:=nops(part);\n  part_conj:=conjpart(part);\n  hooks:=
1;\n  for i from 1 to np do\n  for j from 1 to part[i] do\n     hooks:
=hooks *( (part[i]-j+1)+max(part_conj[j]-i , 0) );\n  end do;end do;\n
  factorial(`+`(op(part)))/hooks;\nend proc:\n#\n# dimSN is the multil
inear version of simSN_mon\n#\ndimSN:=proc(x)\n  option `Copyright (c)
 B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;\n  local \+
cf,tm,n1,plst1,plst2,i;\n  if type(x,`+`) then \n    return map(procna
me,x,y);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,sfk
tmonom);\n    return cf*procname(tm,y)\n  else\n    dimSN_mon(x);  \n \+
 end if;\nend proc:\n#\n# dimSNP gives the dimension of S_n-modules in
 the \n#        power sum symmetric function basis\n#\ndimSNP:=proc(x)
\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rig
hts reserved.`;\n  local cf,tm;\n  if x=0 then return 0 end if;\n  if \+
x=p[0] then return 0 end if;\n  if type(x,`+`) then \n    return map(p
rocname,x);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,
pfktmonom);\n    return cf*procname(tm)\n  else\n    if `+`(op(x))=nop
s([op(x)]) then\n      return `+`(op(x))!;\n    else \n      return 0;
\n    end if;  \n  end if;\nend proc:\n#\n# dimSNM gives the dimension
 of S_n-modules in the \n#        monomial symmetric function basis\n#
\ndimSNM:=proc(x)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2
004-2009. All rights reserved.`;\n  local cf,tm;\n  if x=0 then return
 0 end if;\n  if x=m[0] then return 0 end if;\n  if type(x,`+`) then \+
\n    return map(procname,x);\n  elif type(x,`*`) then \n    tm,cf:=se
lectremove(type,x,mfktmonom);\n    return cf*procname(tm)\n  else\n   \+
 if `+`(op(x))=nops([op(x)]) then\n      return 1\n    else \n      re
turn 0;\n    end if;  \n  end if;\nend proc:\n#\n# dimSNH gives the di
mension of S_n-modules in the \n#        compleete symmetric function \+
basis\n#\ndimSNH:=proc(x)\n  option `Copyright (c) B. Fauser & R. Abla
mowicz 2004-2009. All rights reserved.`;\n  local cf,tm;\n  if x=0 the
n return 0 end if;\n  if x=h[0] then return 0 end if;\n  if type(x,`+`
) then \n    return map(procname,x);\n  elif type(x,`*`) then \n    tm
,cf:=selectremove(type,x,hfktmonom);\n    return cf*procname(tm)\n  el
se\n    return combinat:-multinomial(`+`(op(x)),op(x));\n  end if;\nen
d proc:\n#\n# dimSNE gives the dimension of S_n-modules in the \n#    \+
    elementray symmetric function basis\n#\ndimSNE:=proc(x)\n  option \+
`Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserve
d.`;\n  local cf,tm;\n  if x=0 then return 0 end if;\n  if x=e[0] then
 return 0 end if;\n  if type(x,`+`) then \n    return map(procname,x);
\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,efktmonom);
\n    return cf*procname(tm)\n  else\n    return combinat:-multinomial
(`+`(op(x)),op(x));\n  end if;\nend proc:\n###########################
#############\n#\n# dimGL_mon computes the dimension of an GL(N) chara
cter\n#           according to the hook rule for an Sn character\n#   \+
        s[lambda] (Schur function monom)\n#           ++ dimGL(s[\\lam
bda],N) = \n#           ++   content/\\prod_\{i,j\} h_ij  where\n#    \+
       ++   h_ij is the length of the hook at position (i,j)\n#       \+
    ++   in the Young diagram of \\lambda,\n#           ++   content i
s the product of the content of the \n#           ++   boxes x(i,j)=N-
i+j  (i,j = row,column) and N the dim\n#           ++ of the vectorspa
ce underlying GL(N) \n#\n#\ndimGL_mon:=proc(x,N)\n  option `Copyright \+
(c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,remembe
r;\n  local part,part_conj,np,i,j,hooks,content;\n  part:=[op(x)];\n  \+
if part=[0] then return 1 end if;\n  np:=nops(part);\n  part_conj:=con
jpart(part);\n  hooks:=1;\n  content:=1;\n  for i from 1 to np do\n  f
or j from 1 to part[i] do\n     hooks:=hooks *( (part[i]-j+1)+max(part
_conj[j]-i , 0) );\n     content:=content*(N-i+j);\n  end do;end do;\n
  content/hooks;\nend proc:\n#\n# dimGL is the multilinear version of \+
dimGL_mon\n#\ndimGL:=proc(x,N)\n  option `Copyright (c) B. Fauser & R.
 Ablamowicz 2004-2009. All rights reserved.`;\n  local cf,tm,n1,plst1,
plst2,i;\n  if type(x,`+`) then \n    return map(procname,x,N);\n  eli
f type(x,`*`) then \n    tm,cf:=selectremove(type,x,sfktmonom);\n    r
eturn cf*procname(tm,N)\n  else\n    dimGL_mon(x,N);  \n  end if;\nend
 proc:\n################################################\n#\n# dimGLP_
mon gives the dimension of a monomial representing a module in the \n#
        power sum symmetric function basis\n#\n#\ndimGLP_mon:=proc(pfk
t,N)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All
 rights reserved.`;\n  if pfkt=0 then \n    return 0\n  elif pfkt=p[0]
 then \n    return 1\n  else\n    N^(nops([op(pfkt)]));\n  end if;\nen
d proc:\n#\n# dimGLP gives the dimension of a sum of GL-modules in the
 \n#        power sum symmetric function basis\n#\ndimGLP:=proc(x,N)\n
  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All right
s reserved.`;\n  local cf,tm;\n  if x=0 then return 0 end if;\n  if x=
p[0] then return 1 end if;\n  if type(x,`+`) then \n    return map(pro
cname,x,N);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,
pfktmonom);\n    return cf*procname(tm,N)\n  else\n    dimGLP_mon(x,N)
;  \n  end if;\nend proc:\n#\n# dimGLM gives the dimension of a sum of
 GL-modules in the \n#        monomial symmetric function basis\n#\ndi
mGLM:=proc(x,N)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 200
4-2009. All rights reserved.`;\n  local cf,tm;\n  if x=0 then return 0
 end if;\n  if x=m[0] then return 1 end if;\n  if type(x,`+`) then \n \+
   return map(procname,x,N);\n  elif type(x,`*`) then \n    tm,cf:=sel
ectremove(type,x,mfktmonom);\n    return cf*procname(tm,N)\n  else\n  \+
  factor(1/(`*`(op(map(x->x!,part2mset([op(x)])))))*fallingFactorial(N
,nops([op(x)])));\n  end if;\nend proc:\n#\n# dimGLH gives the dimensi
on of a sum of GL-modules in the \n#        compleete symmetric functi
on basis\n#\ndimGLH:=proc(x,N)\n  option `Copyright (c) B. Fauser & R.
 Ablamowicz 2004-2009. All rights reserved.`;\n  local cf,tm;\n  if x=
0 then return 0 end if;\n  if x=h[0] then return 1 end if;\n  if type(
x,`+`) then \n    return map(procname,x,N);\n  elif type(x,`*`) then \+
\n    tm,cf:=selectremove(type,x,hfktmonom);\n    return cf*procname(t
m,N)\n  else\n    factor(1/(`*`(op(map(x->x!,[op(x)])))) * `*`(op(map2
(risingFactorial,N,[op(x)]))));\n end if;\nend proc:\n#\n# dimGLE give
s the dimension of a sum of GL-modules in the \n#        elementray sy
mmetric function basis\n#\ndimGLE:=proc(x,N)\n  option `Copyright (c) \+
B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;\n  local c
f,tm;\n  if x=0 then return 0 end if;\n  if x=e[0] then return 1 end i
f;\n  if type(x,`+`) then \n    return map(procname,x,N);\n  elif type
(x,`*`) then \n    tm,cf:=selectremove(type,x,efktmonom);\n    return \+
cf*procname(tm,N)\n  else\n    factor(1/(`*`(op(map(x->x!,[op(x)])))) \+
* `*`(op(map2(fallingFactorial,N,[op(x)]))));\n end if;\nend proc:\n##
######################################################################
#######\n#\n# G E S S E L T H E T A functions\n#\n####################
###########################################################\n#\n# Gess
elTheta is the Gessel map from a polynomial ring in infinitley many\n#
     (finitely many) variables 'u1,u2,u3,...' into a polynomial ring\n
#     in one variable 'z', say. The map is ussefull for counting purpo
se and\n#     defined as follows:\n#\n# -- i)   \\Theta(1) = 1\n# -- i
i)  \\Theta(p_n(u)) = z if n=1 else 0\n#\n#     we have therefore for \+
S-functiuons\n#\n# -- iii) \\Theta(s_\\lambda(u)) = f^\\lambda z^(|\\l
ambda|) / (|\\lambda|)!\n#\n#    where |\\lambda| is the weight of a p
artition lambda and\n#    f^\\lambda is the number of standard Young t
ableau of shape\n#    \\lambda i.e. SYT(\\lambda)=dimSN(s[\\lambda](u)
)\n#\n################################################################
###############\n#\n# GesselThetaP_mon is the theta function given for
 power sum monomials\n#\nGesselThetaP_mon:=proc(x,var)\n  option `Copy
right (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,
\n  remeber;\n  local n;\n  if (x=p[0] or x=1) then return 1 end if;\n
  n:=nops([op(x)]);\n  if n=`+`(op(x)) then var^n else 0 end if;\nend \+
proc:\n#\n# GesselThetaP is the linear version for the Gessel map thet
a for \n#              power sum polynomials\n#\nGesselThetaP:=proc(x,
var)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All
 rights reserved.`;\n  local cf,tm;\n  if type(x,`+`) then \n    retur
n map(procname,x,var);\n  elif type(x,`*`) then \n    tm,cf:=selectrem
ove(type,x,pfktmonom);\n    return cf*GesselThetaP_mon(tm,var)\n  else
\n    GesselThetaP_mon(x,var);  \n  end if;\nend proc:\n#\n# GesselThe
taS_mon is the theta function given for Schur function monomials\n#\nG
esselThetaS_mon:=proc(x,var)\n  option `Copyright (c) B. Fauser & R. A
blamowicz 2004-2009. All rights reserved.`,\n  remeber;\n  local N;\n \+
 if (x=s[0] or x=1) then return 1 end if;\n  N:=`+`(op(x));\n  dimSN(x
)*var^N/factorial(N); \nend proc:\n#\n# GesselThetaS is the linear ver
sion for the Gessel map theta for \n#              Schur function poly
nomials\n#\nGesselThetaS:=proc(x,var)\n  option `Copyright (c) B. Faus
er & R. Ablamowicz 2004-2009. All rights reserved.`;\n  local cf,tm;\n
  if type(x,`+`) then \n    return map(procname,x,var);\n  elif type(x
,`*`) then \n    tm,cf:=selectremove(type,x,sfktmonom);\n    return cf
*GesselThetaS_mon(tm,var)\n  else\n    GesselThetaS_mon(x,var);  \n  e
nd if;\nend proc:\n\n########################################\n#\n# Fu
nctions for s-functions\n#\n########################################\n
\n\n##################################################################
##############\n#\n# S C A L A R PRODUCTS\n#\n#     for different base
s\n#\n################################################################
################\n#\n# +++ scalar product of schur functions\n#\nScala
r:=proc(x,y)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2
009. All rights reserved.`;\n  local cf,tm,p1,p2;\n  if x=0 or y=0 the
n return 0 end if;\n  if not (type(x,sfktpolynom) and type(y,sfktpolyn
om)) then error \"wrong type\\n\" end if;\n  if type(x,`+`) then \n   \+
 return map(procname,x,y);\n  elif type(x,`*`) then \n    tm,cf:=selec
tremove(type,x,sfktmonom);\n    return cf*procname(tm,y)\n  else\n    \+
if type(y,`+`) then \n      return map2(procname,x,y);\n    elif type(
y,`*`) then\n      tm,cf:=selectremove(type,y,sfktmonom);\n      retur
n cf*procname(x,tm)\n    else\n      p1:=getPart(x):p2:=getPart(y):\n \+
     if   nops(p1)<nops(p2) then p1:=[op(p1),0$(nops(p2)-nops(p1))];\n
      elif nops(p1)>nops(p2) then p2:=[op(p2),0$(nops(p1)-nops(p2))];
\n      end if;\n      if \{op(zip((i,j)->i-j,p1,p2))\}=\{0\} then ret
urn s[0] else return 0 end if;\n    end if;\n  end if;\nend proc:\n###
######################################################################
############\n#\n# ScalarP is the Schur-Hall scalar product on power s
um functions\n#\nScalarP:=proc(x,y)\n  option `Copyright (c) B. Fauser
 & R. Ablamowicz 2004-2009. All rights reserved.`;\n  local cf,tm,p1,p
2;\n  if not (type(x,pfktpolynom) and type(y,pfktpolynom)) then error \+
\"wrong type\\n\" end if;\n  if type(x,`+`) then \n    return map(proc
name,x,y);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,p
fktmonom);\n    return cf*procname(tm,y)\n  else\n    if type(y,`+`) t
hen \n      return map2(procname,x,y);\n    elif type(y,`*`) then\n   \+
   tm,cf:=selectremove(type,y,pfktmonom);\n      return cf*procname(x,
tm)\n    else\n      ###\n      p1:=[op(x)];\n      p2:=[op(y)];\n    \+
  if `+`(op(p1))<>`+`(op(p2)) then return 0 end if;\n      if \{op(zip
((x,y)->x-y,p1,p2))\}=\{0\} then \n        return zee(p1) \n      end \+
if;\n      0;\n      ### \n    end if;\n  end if;\nend proc:\n########
######################################################################
####\n#\n# ScalarMH is the Schur-Hall scalar product for the dual pair
 of complete symmetric \n#          functions and monomial symmetric f
unctions. Alias is ScalarHM\n#\n#\nScalarMH:=proc(x,y)\n   option `Cop
yright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved`;
\n   if x=0 or y=0 then return 0 end if;\n   if type(x,mfktpolynom) an
d type(y,hfktpolynom) then \n      return Scalar(subs(`m`=s,x),subs(`h
`=s,y)) end if;\n      if type(x,hfktpolynom) and type(y,mfktpolynom) \+
then \n      return Scalar(subs(`h`=s,x),subs(`m`=s,y)) end if;\n   er
ror \"unknown type in ScalarHM\";\nend proc:\nScalarHM:=(x,y)->ScalarM
H(y,x);\n#############################################################
########################\n#\n# O U T E R MONOID\n#\n##################
###################################################################\n#
\n#\n# outer product for S functions, this is the default proceedure, \+
alias is outerS\n#\nouter:=proc(x)\n  option `Copyright (c) B. Fauser \+
& R. Ablamowicz 2004-2009. All rights reserved.`;\n  local cf,tm,p1,p2
,y;\n  if nargs=1 then return x end if;\n  y:=args[2];\n  if x=0 or y=
0 then return 0 end if;\n  if nargs>2 then return procname(expand(proc
name(x,y)),args[3..-1]) end if;\n  if not(type(x,sfktpolynom) and type
(args[2],sfktpolynom)) then error \"wrong type\\n\" end if;\n  if type
(x,`+`) then \n    return map(procname,x,y);\n  elif type(x,`*`) then \+
\n    tm,cf:=selectremove(type,x,sfktmonom);\n    return cf*procname(t
m,y)\n  else\n    if type(y,`+`) then \n      return map2(procname,x,y
);\n    elif type(y,`*`) then\n      tm,cf:=selectremove(type,y,sfktmo
nom);\n      return cf*procname(x,tm)\n    else\n      if x=0 or y=0 t
hen return 0 end if;\n      p1:=getPart(x): p2:=getPart(y):\n# +++ it \+
is faster to add fewer boxes\n# --- the product is symmetric\n      if
 `+`(op(p1))<`+`(op(p2)) then \n        return LRR(p2,p1);\n      else
\n        return LRR(p1,p2);\n      end if;\n    end if;\n  end if;\ne
nd proc:\n#\n# +++ alias for outer product in Schur function basis\n#
\nouterS:=outer:\n#\n#\n# outerLS computes the product of two or any n
umber of Schur functions [monoms]\n#     using the Lascoux Schuetzenbe
rger transition algorithm. after some checking\n#     of the input for
 invalid or special input, we produce the permutation\n#     which is \+
isomorphic to the concatenation of the Lehmer codes od the\n#     inpu
t Schur functions. The transition algorithm descomposes this\n#     pe
rmutation into Grassmannian ones which are turned byck into Schur func
tions\n#     and then added up for output.\n#\nouterLS:=proc(x)\n  loc
al perLst,res,res2,per,i,nopsD;\n  #-- nothing to do\n  if nargs=1 the
n return x end if;\n  #-- concattenate the Lehmer codes of inputs and \+
turn into a permutation\n  perLst:= [ lehmerCodeToPermutation( op([ ma
p(op@schurToLehmerCode1,[args])])) ];\n  nopsD:=nops(Descents(op(perLs
t)));\n  #-- deal with special cases 0 descest output s[0], \n  #-- 1 \+
descent=Grassmannian permutation = Schur function\n  if nopsD=0 then \+
\n     return s[0]\n  elif nopsD=1 then \n     return lehmerCodeToSchu
rFkt(permutationToLehmerCode(op(perLst)))\n  end if;\n  # start comput
ation: for all permutations in perlst applay the\n  # transition algor
ithm (possibly increasing the length of the list)\n  # If the number o
f descents for a permutatin is 1 add to result\n  # othewise feed back
 to perLst\n  res:=0;\n  while perLst<>[] do\n    per:=perLst[1];\n   \+
 perLst:=perLst[2..-1];\n    res2:=transition(per);\n    for i from 1 \+
to nops(res2) do \n       if nops(Descents(res2[i]))=1 then \n        \+
  res:=res+lehmerCodeToSchurFkt(permutationToLehmerCode(res2[i]));\n  \+
     else\n          perLst:=[res2[i],op(perLst)];\n       end if;\n  \+
  end do;\n  end do;  \n  res;\nend proc:\n#\n#\n# concatM_mon multipl
ies two monomials (mfktmonom) using the divided power representation o
f \n#             Rota-Stein 94\n# WARNING:    this is _not_ the outer
 product of symmetric functions, but a concatenation \n#             p
roduct in a divided powers algebra!\n#\n#             (Internal use on
ly)\n#\nconcatM_mon:=proc(fkt1,fkt2)\n   option `Copyright (c) B. Faus
er & R. Ablamowicz 2004-2009. All rights reserved.`,\n   remember;\n  \+
 local mset1,mset2,n1,n2,N,lst,cf,res,i;\n   if fkt1=0 or fkt2=0 then \+
return 0 end if;\n   mset1,mset2:=part2mset([op(fkt1)]),part2mset([op(
fkt2)]);\n   n1,n2:=nops(mset1),nops(mset2);\n   if n1>n2 then\n     N
:=n1;\n     mset2:=[op(mset2),0$(n1-n2)];\n   elif n2>n1 then\n     N:
=n2;\n     mset1:=[op(mset1),0$(n2-n1)];\n   else\n     N:=n1;\n   end
 if;\n   lst:=[seq([binomial(mset1[i]+mset2[i],mset1[i]),mset1[i]+mset
2[i]] ,i=1..N)];\n   cf,res:=1,[];\n   for i in lst do\n     cf:=cf*i[
1];\n     res:=[op(res),i[2]];\n   end do;   \n   cf*m[op(mset2part(re
s))];\nend proc:\n#\n# concatM provides the concatemation product of m
-functions (not the outer product of \n#         symmetric functions!)
 This product is needed to produce a 'clifford' type\n#         produc
t for the outer m-function product\n#\n#\nconcatM:=proc(x)\n  option `
Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved
.`,\n  remember;\n  local cf,tm,p1,p2,y;\n  if nargs=1 then return x e
nd if;\n  y:=args[2];\n  if x=0 or y=0 then return 0 end if;\n  if nar
gs>2 then return procname(expand(procname(x,y)),args[3..-1]) end if;\n
  if not(type(x,mfktpolynom) and type(args[2],mfktpolynom)) then error
 \"wrong type\\n\" end if;\n  if type(x,`+`) then \n    return map(pro
cname,x,y);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,
mfktmonom);\n    return cf*procname(tm,y)\n  else\n    if type(y,`+`) \+
then \n      return map2(procname,x,y);\n    elif type(y,`*`) then\n  \+
    tm,cf:=selectremove(type,y,mfktmonom);\n      return cf*procname(x
,tm)\n    else\n      if x=0 or y=0 then return 0 end if;\n      conca
tM_mon(x,y)\n    end if;\n  end if;\nend proc:\n#\n#\n# concat_mon mul
tiplies two monomials (e-, h-, p-function monoms) \n#            This \+
_is_ the outer product! for these bases \n#\n#             (Internal u
se only)\n#\nconcat_mon:=proc(fkt1,fkt2,name)\n   option `Copyright (c
) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n   reme
mber;\n   local lst;\n   lst:=[op(fkt1),op(fkt2)];\n   name[op(sort(ls
t,(i,j)->if i>j then true else false end if))];\nend proc:\n#\n# outer
H,E,P are functions providing the outer product of complete, elementar
y and power sum\n#         symmetric functions. These products are the
 outer products on these bases, since\n#         these particular base
s are multiplicateive bases.\n#\n#\nouterH:=proc(x)\n  option `Copyrig
ht (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n  \+
remember;\n  local cf,tm,p1,p2,y;\n  if nargs=1 then return x end if;
\n  y:=args[2];\n  if x=0 or y=0 then return 0 end if;\n  if nargs>2 t
hen return procname(expand(procname(x,y)),args[3..-1]) end if;\n  if n
ot(type(x,hfktpolynom) and type(y,hfktpolynom)) then error \"wrong typ
e\\n\" end if;\n  if type(x,`+`) then \n    return map(procname,x,y);
\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,hfktmonom);
\n    return cf*procname(tm,y)\n  else\n    if type(y,`+`) then \n    \+
  return map2(procname,x,y);\n    elif type(y,`*`) then\n      tm,cf:=
selectremove(type,y,hfktmonom);\n      return cf*procname(x,tm)\n    e
lse\n      if x=0 or y=0 then return 0 end if;\n      if x=h[0] then r
eturn y end if;\n      if y=h[0] then return x end if;\n      concat_m
on(x,y,`h`)\n    end if;\n  end if;\nend proc:\n#\n#\n#\nouterE:=proc(
x)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All r
ights reserved.`,\n  remember;\n  local cf,tm,p1,p2,y;\n  if nargs=1 t
hen return x end if;\n  y:=args[2];\n  if x=0 or y=0 then return 0 end
 if;\n  if nargs>2 then return procname(expand(procname(x,y)),args[3..
-1]) end if;\n  if not(type(x,efktpolynom) and type(args[2],efktpolyno
m)) then error \"wrong type\\n\" end if;\n  if type(x,`+`) then \n    \+
return map(procname,x,y);\n  elif type(x,`*`) then \n    tm,cf:=select
remove(type,x,efktmonom);\n    return cf*procname(tm,y)\n  else\n    i
f type(y,`+`) then \n      return map2(procname,x,y);\n    elif type(y
,`*`) then\n      tm,cf:=selectremove(type,y,efktmonom);\n      return
 cf*procname(x,tm)\n    else\n      if x=0 or y=0 then return 0 end if
;\n      if x=e[0] then return y end if;\n      if y=e[0] then return \+
x end if;\n      concat_mon(x,y,`e`)\n    end if;\n  end if;\nend proc
:\n#\n#\n#\nouterP:=proc(x)\n  option `Copyright (c) B. Fauser & R. Ab
lamowicz 2004-2009. All rights reserved.`,\n  remember;\n  local cf,tm
,p1,p2,y;\n  if nargs=1 then return x end if;\n  y:=args[2];\n  if x=0
 or y=0 then return 0 end if;\n  if nargs>2 then return procname(expan
d(procname(x,y)),args[3..-1]) end if;\n  if not(type(x,pfktpolynom) an
d type(args[2],pfktpolynom)) then error \"wrong type\\n\" end if;\n  i
f type(x,`+`) then \n    return map(procname,x,y);\n  elif type(x,`*`)
 then \n    tm,cf:=selectremove(type,x,pfktmonom);\n    return cf*proc
name(tm,y)\n  else\n    if type(y,`+`) then \n      return map2(procna
me,x,y);\n    elif type(y,`*`) then\n      tm,cf:=selectremove(type,y,
pfktmonom);\n      return cf*procname(x,tm)\n    else\n      if x=0 or
 y=0 then return 0 end if;\n      if x=p[0] then return y end if;\n   \+
   if y=p[0] then return x end if;\n      concat_mon(x,y,`p`)\n    end
 if;\n  end if;\nend proc:\n##########################################
##############################################\n#\n# O U T E R COMONOI
D\n#\n#\n#############################################################
###########################\n#\n# couterM_mon computes the outer copro
duct of the m-basis m-functions\n#\n# (Internal use only)\n#\ncouterM_
mon:=proc(mfkt)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 200
4-2009. All rights reserved.`,\n  remember;\n  local mset,T,res,nT;\n \+
 if mfkt=0 then return(0) end if;\n  mset:=part2mset([op(mfkt)]);\n  T
:=combinat[cartprod]([seq([seq(k,k=0..mset[i])],i=1..nops(mset))]):\n \+
 res:=[];\n  while not T[finished] do\n    nT:=T[nextvalue](); \n    r
es:=[op(res),[mset-nT,nT]] \n  end do;\n  add(&t(m[op(mset2part(i[1]))
],m[op(mset2part(i[2]))]),i=res);\nend proc:\n#\n#\n# couterM computes
 the outer coproduct in the m-basis. This is essentially a wrapper\n# \+
        function for couterM_mon on monomials, making it multilinear o
ver the\n#         integers.\n#\n#\ncouterM:=proc(x)\n  option `Copyri
ght (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n \+
 remember;\n  local cf,tm,n1,plst1,plst2,i;\n  if x=0 then return(0) e
nd if;\n  if type(x,`+`) then \n    return map(procname,x,y);\n  elif \+
type(x,`*`) then \n    tm,cf:=selectremove(type,x,mfktmonom);\n    ret
urn cf*procname(tm,y)\n  else\n    if x=m[0] then return &t(m[0],m[0])
 end if;\n    couterM_mon(x);  \n  end if;\nend proc:\n#\n# LaplaceMse
t is a internal function which implements the Laplace Pairing of Rota-
Stein\n#             in tha case of monomial symmetric functions. For \+
efficiency reasons, it\n#             uses a third representation of s
parse-multisets M(\\prod_k [i_k,ni_k])\n#             where the zero e
ntries [n,0] are omitted! \n#\n#\nLaplaceMset:=proc(Mset1,Mset2)\n  op
tion `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights re
served.`,\n  remember;\n  local n1,n2,T,nT,res,a,b,c,d;\n  n1,n2:=nops
(Mset1),nops(Mset2);\n  # -- check for m[0]=1 cases directly\n  if n1=
0 and n2=0 then return M() end if;\n  if n1=0 or n2=0 then return 0 en
d if;\n  if n1=1 then\n    if n2=1 then\n      # -- case n1=n2=1 defin
ition applies directly\n      if op(Mset1)[2]=op(Mset2)[2] then \n    \+
    return M([op(Mset1)[1]+op(Mset2)[1],op(Mset1)[2]]);\n      else\n \+
       return 0;\n      end if; \n    else\n      # --n1=1, n2 a produ
ct\n      return add(MCAT(\n                      procname( M([ op(Mse
t1)[1] , k ]) , M( op(Mset2)[1] ) )\n                     ,procname( M
([ op(Mset1)[1] , op(Mset1)[2]-k ]), M( op(Mset2)[2..-1] ) )   \n     \+
                )\n                ,k=0..op(Mset1)[2] );\n    end if;
\n  else\n    # -- n1 a product\n    if n2=1 then\n      # -- n2 not a
 product\n      return add(MCAT(\n                      procname( M([ \+
op(Mset2)[1] , k ]) , M( op(Mset1)[1] ) )\n                     ,procn
ame( M([ op(Mset2)[1] , op(Mset2)[2]-k ]), M( op(Mset1)[2..-1] ) )\n  \+
                   )\n                ,k=0..op(Mset2)[2] );\n    else
\n      # -- n1 and n2 products, expand second argument ...\n      a,b
:=M([op(Mset1)][1]),M(op([op(Mset1)][2..-1]));\n      c:=[seq([op(Mset
2)][i][1],i=1..nops([op(Mset2)]))];\n      d:=[seq([op(Mset2)][i][2],i
=1..nops([op(Mset2)]))];\n      T:=combinat[cartprod]([seq([seq(k,k=0.
.[op(Mset2)][i][2])],i=1..nops([op(Mset2)]))]):\n      res:=[];\n     \+
 while not T[finished] do\n        nT:=T[nextvalue](); \n        res:=
[op(res),[d-nT,nT]] \n      end do;\n      add(MCAT(\n               p
rocname(a,M(seq([c[k],i[1][k]],k=1..nops(c)) ))\n              ,procna
me(b,M(seq([c[k],i[2][k]],k=1..nops(c)) ))\n              )\n         \+
 ,i=res);\n    end if;\n  end if;\nend proc:\n#\n# LaplaceM_mon is the
 wrapper function for LaplaceMset and computes the Laplace pairing\n# \+
         between two _monomials_ in the monoamial symmetric function b
asis. Unless\n#          it is bilinear it is for internal use in the \+
outerM product mainly.\n#\n#\nLaplaceM_mon:=proc(mfkt1,mfkt2)\n   opti
on `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights rese
rved.`,\n   remember;\n   local mset1,mset2,f;\n# -- SPECIAL CASES\n# \+
-- LaplaceM is _not_ graded, by weight of the partitions of the mfkt's
\n# -- However, LaplaceM _is graded_ by the _length_ of the partitions
!!\n# -- The case m[0] is crittical since part2mset does return an emp
ty list\n# -- we deal hence with these cases seperately:\n# -- Laplace
M(m[0],m[0])=m[0]\n# -- LaplaceM(m[0],<any-mfkt>) = 0 = LaplaceM(<any-
mfkt>,m[0])\n   if nops([op(mfkt1)])<>nops([op(mfkt2)]) then return 0 \+
end if;\n   if mfkt1=m[0] and mfkt2=m[0] then return m[0] end if;\n   \+
if mfkt1=m[0] or mfkt2=m[0] then return 0 end if;\n# -- transform part
itions into msets M([i1,ni1],[i2,ni2],...)\n   mset1,mset2:=part2mset(
[op(mfkt1)]),part2mset([op(mfkt2)]);\n# -- f is a helper function whic
h turns M-set representations back into\n# -- a partition representati
on\n   f:=proc()\n      local x,n;\n      x,n:=args,nargs;\n      m[op
( sort([seq([x][k][1]$[x][k][2],k=1..n)]) )];\n   end proc:\n# -- call
 the actual LaplaceMset proceedure\n   LaplaceMset(M(seq([k,mset1[k]],
k=1..nops(mset1))),M(seq([k,mset2[k]],k=1..nops(mset2))));\n# -- Turn \+
the M-set representation output of LaplaceMset into a partition based \+
form\n   eval(subs(M=f,%));\n# -- substitute the unevaluated concatena
tion product MCAT into the actual concatM product\n# -- and return the
 final result \n   eval(subs(MCAT=concatM,%));\nend proc:\n#\n# The wr
apper which makes LaplaceM_mon multilinear\n#\nLaplaceM2:=proc(x,y)\n \+
 option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights
 reserved.`;\n  local cf,tm,p1,p2;\n  if x=0 or y=0 then return 0 end \+
if;\n  if not (type(x,mfktpolynom) and type(y,mfktpolynom)) then error
 \"wrong type\\n\" end if;\n  if type(x,`+`) then \n    return map(pro
cname,x,y);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,
mfktmonom);\n    return cf*procname(tm,y)\n  else\n    if type(y,`+`) \+
then \n      return map2(procname,x,y);\n    elif type(y,`*`) then\n  \+
    tm,cf:=selectremove(type,y,mfktmonom);\n      return cf*procname(x
,tm)\n    else\n#      if x=m[0] then return y end if;\n#      if y=m[
0] then return x end if;\n      LaplaceM_mon(x,y);\n    end if;\n  end
 if;\nend proc:\n#####################################################
###############################\n#\n# Laplace helper functions:\n#\n# \+
----------------------------------------------------------------------
------------\n#\n# LP_l1 computes the LaplaceM pairing for monomials o
f length < 2\n# \nLP_l1:=proc(x,y)\n  option remember;\n  if x=m[0] or
 y=m[0] then\n    if y=x then\n      return m[0]\n    else \n      ret
urn 0\n    end if;\n  end if;\n  return m[op(x)+op(y)];\nend proc:\n#
\n# couterMproper1n computes the proper coproduct slice of length 1,n \+
where\n#                 the original monomial has length n+1\n#\ncout
erMproper1n:=proc(x)\n  option remember;\n  local lst,mset;\n  if x=0 \+
then return 0 end if;\n  if x=m[0] then return &t(m[0],m[0]) end if;\n
  lst:=\{op(x)\};\n  mset:=part2mset([op(x)]);\n  add(&t(m[i],m[op( ms
et2part(mset-[0$(i-1),1,0$(nops(mset)-i)]))]) ,i in lst);\nend proc:\n
#\n# LP_mon is the actual LaplaceM pairing evaluated on arbitrary m-ba
sis monomials\n#        LP_mon is faster and more memory efficient tha
n the old algorithm. It was \n#        seriously tested against the ol
d routine.\n#\nLP_mon:=proc(x,y)\n  option remember;\n  local lx,ly,f0
,beta,res;\n  lx,ly:=nops([op(x)]),nops([op(y)]);\n  if lx<>ly then re
turn 0 end if;\n  if lx<2 then return LP_l1(x,y) end if;\n  # -- the L
aplace property (due to the length constraint we need only one directi
on)\n  # -- we split of a single entry in the second fcator\n  # -- th
e coproduct needs only terms of the length type 1,n, this is provided \+
by\n  # -- the function couterMproper1n\n  # -- beta is a numerical fa
ctor needed to split m-basis monomials into a\n  # -- concatenation pr
oduct of two parts : concatM(A,B)/beta(C) = C\n  beta:=coeff(concatM(m
[[op(y)][1]], m[op([op(y)][2..-1])]),y);\n  f0:=(a,b,c,d)->concatM(LP_
mon(a,c),LP_mon(b,d));\n  eval(1/beta*subs(`&t`=f0, \n     &t( couterM
proper1n(x),  m[[op(y)][1]], m[op([op(y)][2..-1])] )\n  ));   \nend pr
oc:\n#\n# The wrapper which makes LaplaceM_mon multilinear\n#\nLaplace
M:=proc(x,y)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2
009. All rights reserved.`;\n  local cf,tm,p1,p2;\n  if x=0 or y=0 the
n return 0 end if;\n  if not (type(x,mfktpolynom) and type(y,mfktpolyn
om)) then error \"wrong type\\n\" end if;\n  if type(x,`+`) then \n   \+
 return map(procname,x,y);\n  elif type(x,`*`) then \n    tm,cf:=selec
tremove(type,x,mfktmonom);\n    return cf*procname(tm,y)\n  else\n    \+
if type(y,`+`) then \n      return map2(procname,x,y);\n    elif type(
y,`*`) then\n      tm,cf:=selectremove(type,y,mfktmonom);\n      retur
n cf*procname(x,tm)\n    else\n      LP_mon(x,y);\n    end if;\n  end \+
if;\nend proc:\n#\n# outerM the cliffordization of the concatM product
, the outer product in the monomial\n#        symmetric function basis
. This function takes 1,2, or n variables (associactive)\n#        and
 is multilinear over the integers / fractions.\n#\n#\nouterM:=proc(x)
\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rig
hts reserved.`,\n  remember;\n  local cf,tm,p1,p2,y,f;\n  if nargs=1 t
hen return x end if;\n  y:=args[2];\n  if x=0 or y=0 then return 0 end
 if;\n  if nargs>2 then return procname(expand(procname(x,y)),args[3..
-1]) end if;\n  if not(type(x,mfktpolynom) and type(args[2],mfktpolyno
m)) then error \"wrong type\\n\" end if;\n  if type(x,`+`) then \n    \+
return map(procname,x,y);\n  elif type(x,`*`) then \n    tm,cf:=select
remove(type,x,mfktmonom);\n    return cf*procname(tm,y)\n  else\n    i
f type(y,`+`) then \n      return map2(procname,x,y);\n    elif type(y
,`*`) then\n      tm,cf:=selectremove(type,y,mfktmonom);\n      return
 cf*procname(x,tm)\n    else\n      if x=0 or y=0 then return 0 end if
;\n      f:=(a,b,c,d)->concatM(LaplaceM_mon(a,c),concatM_mon(b,d));\n \+
     eval(subs(`&t`=f,&t(couterM(x),couterM(y))));\n    end if;\n  end
 if;\nend proc:\n#####################################################
###################################\n#\n# A D J O I N T OPERATIONS / S
KEWS\n#\n#############################################################
###########################\n#\n#  +++ skew shur functions\n#\n#  skew
LR computes the skew operation by dualiting the outer product based\n#
     on the Littlewood-Richarson rule, this is slow and ineefective, s
ee skewLS below\n#\nskewLR:=proc(x,y)\n  option `Copyright (c) B. Faus
er & R. Ablamowicz 2004-2009. All rights reserved.`;\n  local cf,tm,n1
,n2,n3,plst;\n  if y=s[0] then return x; end if;\n  if type(x,`+`) the
n \n    return map(procname,x,y);\n  elif type(x,`*`) then \n    tm,cf
:=selectremove(type,x,sfktmonom);\n    return cf*procname(tm,y)\n  els
e\n    if type(y,`+`) then \n      return map2(procname,x,y);\n    eli
f type(y,`*`) then\n      tm,cf:=selectremove(type,y,sfktmonom);\n    \+
  return cf*procname(x,tm)\n    else\n      n1:=`+`(op(getPart(x))):n2
:=`+`(op(getPart(y))):\n      n3:=n1-n2;\n      if n3<0 then return 0 \+
\n      elif n3=0 then return Scalar(x,y) \n      else\n        plst:=
map(x->s[op(x)],[op(PartNM(n3,n3))]);\n        return add(outer(Scalar
(x,outer(y,z)),z),z=plst);\n      end if;\n    end if;\n  end if;\nend
 proc:\n#\n# skewLS computes the skew using the Lascoux Schuetzenberge
r transition algorithm\n#     this is by fare the faster skew operatio
n then the above one obtained by \n#     duality and is therefore set \+
as default\n#\nskewLS:=proc(sf1,sf2)\n  local perLst,res,res2,per,i,no
psD;\n  #-- sf2=s[0] then nothing to do\n  if sf2=s[0] then return sf1
 end if;\n  if nops([op(sf1)])<nops([op(sf2)]) then return sf1 end if;
\n  #-- check if sf1 covers sf2, otherwise zero\n  for i in zip((i,j)-
>i-j,[op(sf1)],[op(sf2)]) do\n     if i<0 then return 0 end if;\n  end
 do;\n  #-- construct the permutation of the Lehmer code of the skew d
iagram\n  perLst:=[lehmerCodeToPermutation( skewToLehmerCode(sf1,sf2) \+
)];\n  nopsD:=nops(Descents(op(perLst)));\n  #-- deal with special cas
es 0 descest output s[0], \n  #-- 1 descent=Grassmannian permutation =
 Schur function\n  if nopsD=0 then \n     return s[0]\n  elif nopsD=1 \+
then \n     return lehmerCodeToSchurFkt(permutationToLehmerCode(op(per
Lst)))\n  end if;\n  # start computation: for all permutations in perl
st applay the\n  # transition algorithm (possibly increasing the lengt
h of the list)\n  # If the number of descents for a permutatin is 1 ad
d to result\n  # othewise feed back to perLst\n  res:=0;\n  while perL
st<>[] do\n    per:=perLst[1];\n    perLst:=perLst[2..-1];\n    res2:=
transition(per);\n    for i from 1 to nops(res2) do \n       if nops(D
escents(res2[i]))=1 then \n          res:=res+lehmerCodeToSchurFkt(per
mutationToLehmerCode(res2[i]));\n       else\n          perLst:=[res2[
i],op(perLst)];\n       end if;\n    end do;\n  end do;  \n  res;\nend
 proc:\n#\n# DEFAULT: skewLS made linear\n#\nskew:=proc(x,y)\n  option
 `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserv
ed.`;\n  local cf,tm,n1,n2,n3,plst;\n  if y=s[0] then return x; end if
;\n  if type(x,`+`) then \n    return map(procname,x,y);\n  elif type(
x,`*`) then \n    tm,cf:=selectremove(type,x,sfktmonom);\n    return c
f*procname(tm,y)\n  else\n    if type(y,`+`) then \n      return map2(
procname,x,y);\n    elif type(y,`*`) then\n      tm,cf:=selectremove(t
ype,y,sfktmonom);\n      return cf*procname(x,tm)\n    else\n      ret
urn skewLS(x,y);\n    end if;\n  end if;\nend proc:\n#\n#\n#\ncouter_m
on:=proc(x)\n   local par,parLst,pr;\n   if x=s[0] then return &t(s[0]
,s[0]); end if;\n   if x=s[1] then return &t(s[1],s[0])+&t(s[0],s[1]);
 end if;\n   par:=[op(x)];\n   parLst:=partitionsInShape(par);\n   add
(&t(s[op(pr)],skewLS(x,s[op(pr)])), pr in parLst);\nend proc:\n#\n#\n#
\ncouter:=proc(x)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2
004-2009. All rights reserved.`;\n  local cf,tm,n1,plst1,plst2,i;\n  i
f not type(x,sfktpolynom) then return x*procname(s[0]) end if;\n  if t
ype(x,`+`) then \n    return map(procname,x);\n  elif type(x,`*`) then
 \n    tm,cf:=selectremove(type,x,sfktmonom);\n    return cf*procname(
tm)\n  else\n#----- obsolete code\n#    if x=s[0] then return &t(s[0],
s[0]) end if;\n#    n1:=`+`(op(getPart(x))):\n#    tm:=&t(s[0],x)+&t(x
,s[0]);\n#    for i from 1 to n1-1 do\n#       plst1:=map(x->s[op(x)],
PartNM(n1-i,n1));\n#       plst2:=map(x->s[op(x)],PartNM(i,n1));\n#   \+
    tm:=tm+add(add(subs(s[0]=1,Scalar(x,outer(y,z)))*&t(y,z),y=plst1),
z=plst2);\n#    end do;\n#    return tm;\n    return couter_mon(x);\n \+
 end if;\nend proc:\n#\n#\n# couterH_monom is the internal function co
mputing the outer product on complete\n#              symmetric functi
ons monoms\n#\n#\ncouterH_mon:=proc(x)\n   option `Copyright (c) B. Fa
user & R. Ablamowicz 2004-2009. All rights reserved.`,\n          reme
mber;\n   local prtx,p1,f,g,l;\n   prtx:=[op(x)];\n   if prtx=[] or pr
tx=[0] then return &t(h[0],h[0]) end if;\n   if nops(prtx)=1 then retu
rn add(&t(h[prtx[1]-i],h[i]),i=0..prtx[1]) end if;\n   p1:=prtx[1];\n \+
  prtx:=prtx[2..-1];\n   f:=(x,y,z)->&t(x,z,y):\n   l:=proc(x)\n      \+
h[op(subs(0=NULL,[op(x)]))]; \n      if %=h[] then h[0] else % end if:
\n   end proc:\n   g:=(x,y,s,t)->&t(l(outerH(x,y)),l(outerH(s,t))):\n \+
  eval(subs(`&t`=g,\n          add(f(h[p1-i],h[i],procname(h[op(prtx)]
)) ,i=0..p1) ));\nend proc:\n#\n#\n# couterH computes the outer coprod
uct in the h-basis. This is essentially a wrapper\n#         function \+
for couterH_mon on monomials, making it multilinear over the\n#       \+
  integers.\n#\n#\ncouterH:=proc(x)\n  option `Copyright (c) B. Fauser
 & R. Ablamowicz 2004-2009. All rights reserved.`,\n  remember;\n  loc
al cf,tm,n1,plst1,plst2,i;\n  ####if not type(x,efktpolynom) then retu
rn x*procname(h[0]) end if;#####<<<<<BUG\n  if not type(x,hfktpolynom)
 then return x*procname(h[0]) end if;\n  if type(x,`+`) then \n    ret
urn map(procname,x,y);\n  elif type(x,`*`) then \n    tm,cf:=selectrem
ove(type,x,hfktmonom);\n    return cf*procname(tm,y)\n  else\n    if t
ype(y,`+`) then \n      return map2(procname,x,y);\n    elif type(y,`*
`) then\n      cf,tm:=selectremove(type,y,integer);\n      return cf*p
rocname(x,tm)\n    else\n      if x=h[0] then return &t(h[0],h[0]) end
 if;\n      couterH_mon(x);  \n    end if;\n  end if;\nend proc:\n#\n#
\n# couterE_mon is the internal function computing the outer product o
n elementary\n#              symmetric functions monoms\n#\n#\ncouterE
_mon:=proc(x)\n   option `Copyright (c) B. Fauser & R. Ablamowicz 2004
-2009. All rights reserved.`,\n          remember;\n   local prtx,p1,f
,g,l;\n   prtx:=[op(x)];\n   if prtx=[] or prtx=[0] then return &t(e[0
],e[0]) end if;\n   if nops(prtx)=1 then return add(&t(e[prtx[1]-i],e[
i]),i=0..prtx[1]) end if;\n   p1:=prtx[1];\n   prtx:=prtx[2..-1];\n   \+
f:=(x,y,z)->&t(x,z,y):\n   l:=proc(x)\n      e[op(subs(0=NULL,[op(x)])
)]; \n      if %=e[] then e[0] else % end if:\n   end proc:\n   g:=(x,
y,s,t)->&t(l(outerE(x,y)),l(outerE(s,t))):\n   eval(subs(`&t`=g,\n    \+
      add(f(e[p1-i],e[i],procname(e[op(prtx)])) ,i=0..p1) ));\nend pro
c:\n#\n#\n# couterE computes the outer coproduct in the e-basis. This \+
is essentially a wrapper\n#         function for couterE_mon on monomi
als, making it multilinear over the\n#         integers.\n#\n#\ncouter
E:=proc(x)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-200
9. All rights reserved.`,\n  remember;\n  local cf,tm,n1,plst1,plst2,i
;\n  if not type(x,efktpolynom) then return x*procname(e[0]) end if;\n
  if type(x,`+`) then \n    return map(procname,x,y);\n  elif type(x,`
*`) then \n    tm,cf:=selectremove(type,x,efktmonom);\n    return cf*p
rocname(tm,y)\n  else\n    couterE_mon(x);  \n  end if;\nend proc:\n#
\n#\n# couterP_mon is the internal function computing the outer produc
t on power sum\n#              symmetric functions monoms\n#\n#\ncoute
rP_mon:=proc(x)\n   option `Copyright (c) B. Fauser & R. Ablamowicz 20
04-2009. All rights reserved.`,\n          remember;\n   local prtx,p1
,f,g,l;\n   prtx:=[op(x)];\n   if prtx=[] or prtx=[0] then return &t(p
[0],p[0]) end if;\n   if nops(prtx)=1 then return &t(x,p[0])+&t(p[0],x
) end if;\n   p1:=prtx[1];\n   prtx:=prtx[2..-1];\n   f:=(x,y,z)->&t(x
,z,y):\n   l:=proc(x)\n      p[op(subs(0=NULL,[op(x)]))]; \n      if %
=p[] then p[0] else % end if:\n   end proc:\n   g:=(x,y,s,t)->&t(l(out
erP(x,y)),l(outerP(s,t))):\n   eval(subs(`&t`=g,\n          f(p[p1],p[
0],procname(p[op(prtx)]))\n         +f(p[0],p[p1],procname(p[op(prtx)]
)) ));\nend proc:\n#\n#\n# couterP computes the outer coproduct in the
 p-basis. This is essentially a wrapper\n#         function for couter
P_mon on monomials, making it multilinear over the\n#         integers
.\n#\n#\ncouterP:=proc(x)\n  option `Copyright (c) B. Fauser & R. Abla
mowicz 2004-2009. All rights reserved.`,\n  remember;\n  local cf,tm,n
1,plst1,plst2,i;\n  if not type(x,pfktpolynom) then error \"Power sum \+
polynom expected....\"; end if;\n  if x=0 then return 0 end if;\n  if \+
type(x,`+`) then \n    return map(procname,x,y);\n  elif type(x,`*`) t
hen \n    tm,cf:=selectremove(type,x,pfktmonom);\n    return cf*procna
me(tm,y)\n  else\n    couterP_mon(x);  \n  end if;\nend proc:\n#\n# an
tipode for the Sfunctions\n#\n#\nantipS_mon:=proc(sfkt)\n  option `Cop
yright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;
 \n  local p1,Lambda,i,k,N;\n  p1:=[op(sfkt)];\n  if `+`(op(p1))=0 the
n return s[0] end if;\n  Lambda:=[0$`+`(op(p1))]:\n  for i from 1 to n
ops(p1) do\n  for k from 1 to p1[i] do\n    Lambda[k]:=Lambda[k]+1;\n \+
 end do: end do:\n  Lambda:=map(x-> if x=0 then NULL else x end if ,La
mbda);   \n  (-1)^(`+`(op(p1)))*s[op(Lambda)]; \nend proc:\n#\n# linea
r version for the antipode of the Sfunctions\n#\n#\nantipS:=proc(x)\n \+
 option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights
 reserved.`,\n  remember;\n  local cf,tm,n1,plst1,plst2,i;\n  if x=0 t
hen return 0 end if;\n  if x=s[0] then return s[0] end if;\n  if type(
x,`+`) then \n    return map(procname,x);\n  elif type(x,`*`) then \n \+
   tm,cf:=selectremove(type,x,sfktmonom);\n    return cf*procname(tm)
\n  else\n    antipS_mon(x);  \n  end if;\nend proc:\n#\n# antipode in
 the power sum basis\n#\n#\nantipP_mon:=proc(pfkt)\n  option `Copyrigh
t (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;\n  (
-1)^(nops([op(pfkt)]))*pfkt; \nend proc:\n#\n# linear form of the powe
r sum antipode\n#\n#\nantipP:=proc(x)\n  option `Copyright (c) B. Faus
er & R. Ablamowicz 2004-2009. All rights reserved.`,\n  remember;\n  l
ocal cf,tm,n1,plst1,plst2,i;\n  if x=0 then return 0 end if;\n  if x=p
[0] then return p[0] end if;\n  if type(x,`+`) then \n    return map(p
rocname,x);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,
pfktmonom);\n    return cf*procname(tm)\n  else\n    antipP_mon(x);  \+
\n  end if;\nend proc:\n#\n# antipH_mon is the recursively defined ant
ipode for the complete symmetric \n#            functions (internal us
e only)\n#\nantipH_mon:=proc(hfktmonom)\n  option `Copyright (c) B. Fa
user & R. Ablamowicz 2004-2009. All rights reserved.`,\n         remem
ber;\n  local f;\n  if op(hfktmonom)=0 then return h[0] end if;\n  f:=
(x,y)->outerH(antipH_mon(x),y):\n  eval(subs(`&t`=f,-couterH(hfktmonom
)+&t(hfktmonom,h[0])));\nend proc:\n#\n# antipH is the linear version \+
of antiH_mon\n#\nantipH:=proc(x)\n  option `Copyright (c) B. Fauser & \+
R. Ablamowicz 2004-2009. All rights reserved.`,\n  remember;\n  local \+
cf,tm,n1,plst1,plst2,i;\n  if x=0 then return 0 end if;\n  if x=h[0] t
hen return h[0] end if;\n  if type(x,`+`) then \n    return map(procna
me,x);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,hfktm
onom);\n    return cf*procname(tm)\n  else\n    antipH_mon(x);  \n  en
d if;\nend proc:\n#\n# antipE_mon is the recursively defined antipode \+
for the elementary symmetric \n#            functions (internal use on
ly)\n#\nantipE_mon:=proc(efktmonom)\n  option `Copyright (c) B. Fauser
 & R. Ablamowicz 2004-2009. All rights reserved.`,\n         remember;
\n  local f;\n  if op(efktmonom)=0 then return e[0] end if;\n  f:=(x,y
)->outerE(antipE_mon(x),y):\n  eval(subs(`&t`=f,-couterE(efktmonom)+&t
(efktmonom,e[0])));\nend proc:\n#\n# antipE is the linear version of a
ntiE_mon\n#\nantipE:=proc(x)\n  option `Copyright (c) B. Fauser & R. A
blamowicz 2004-2009. All rights reserved.`,\n  remember;\n  local cf,t
m,n1,plst1,plst2,i;\n  if x=0 then return 0 end if;\n  if x=e[0] then \+
return e[0] end if;\n  if type(x,`+`) then \n    return map(procname,x
);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,efktmonom
);\n    return cf*procname(tm)\n  else\n    antipE_mon(x);  \n  end if
;\nend proc:\n#\n# antipM_mon is the recursively defined antipode for \+
the monomial symmetric \n#            functions (internal use only)\n#
\nantipM_mon:=proc(mfktmonom)\n  option `Copyright (c) B. Fauser & R. \+
Ablamowicz 2004-2009. All rights reserved.`,\n         remember;\n  lo
cal f;\n  if op(mfktmonom)=0 then return m[0] end if;\n  f:=(x,y)->out
erM(antipM_mon(x),y):\n  eval(subs(`&t`=f,-couterM(mfktmonom)+&t(mfktm
onom,m[0])));\nend proc:\n#\n# antipM is the linear version of antipM_
mon\n#\nantipM:=proc(x)\n  option `Copyright (c) B. Fauser & R. Ablamo
wicz 2004-2009. All rights reserved.`,\n  remember;\n  local cf,tm,n1,
plst1,plst2,i;\n  if x=0 then return 0 end if;\n  if x=m[0] then retur
n m[0] end if;\n  if type(x,`+`) then \n    return map(procname,x);\n \+
 elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,mfktmonom);\n \+
   return cf*procname(tm)\n  else\n    antipM_mon(x);  \n  end if;\nen
d proc:\n#\n# linear version for the antipode of the Hopf algebra of o
uter coproduct and concatenation\n#   -- in the monomial basis...\n#\n
#\nantipMC:=proc(x)\n  option `Copyright (c) B. Fauser & R. Ablamowicz
 2004-2009. All rights reserved.`,\n  remember;\n  local cf,term;\n  i
f x=0 then return 0 end if;\n  if x=m[0] then return m[0] end if;\n  i
f type(x,`+`) then \n    return map(procname,x);\n  elif type(x,`*`) t
hen \n    term,cf:=selectremove(type,x,mfktmonom);\n    return cf*proc
name(term)\n  else\n    return (-1)^nops(op([x]))*x;  \n  end if;\nend
 proc:\n##############################################################
##########################\n#\n# T A B L E S\n#\n#####################
###################################################################\n#
\n# KostkaTable returns an equation Kostka'N'=matrix where matrix is t
he matrix of\n#             Kostka numbers in the anti lexicographic o
rdering of partitions\n#\nKostkaTable:=proc(N::integer)\n  option `Cop
yright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;
 \n  local part,sn,mks;\n  mks:=(lst)->map(i->s[op(i)],lst);\n  part:=
PartNM(N,N);\n  sn:=map(i->mks(i),part);\n  cat(Kostka,N)=subs(s[0]=1,
evalm(linalg[matrix](nops(part),nops(part),(i,j)->Scalar( s[op(part[i]
)],outer(op(sn[j]))))));\nend proc:\n#\n# LaplaceTable returns the mat
rix of the Rota-Stein Laplace pairing for the monomial\n#             \+
 symmetric function deformation. It is presented in the graded anti\n#
              lexicographic ordering, which respects the grading of th
e Laplace\n#              pairing (block diagonal form). First row and
 colums show the basis \n#              partitions\n#\nLaplaceTable:=p
roc(N,M)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009.
 All rights reserved.`;\n  local prtN,prtM;\n  prtN,prtM:=sort(PartNM(
N,N),grAlexComp),sort(PartNM(M,M),grAlexComp);\n  linalg[matrix](nops(
prtN)+1,nops(prtM)+1,\n       (i,j)->if i=1 and j=1 then \n           \+
     `<x|y>` elif j=1 then \n                prtN[i-1] elif i=1 then \+
\n                prtM[j-1] else   \n                LaplaceM_mon(prtN
[i-1],prtM[j-1]) \n              end if);\nend proc:\n\n##############
############################################################\n#\n# I N
 N E R MONOID and COMONOID\n#\n#           Power Sum Basis \n#\n######
####################################################################\n
\n####################################################################
######\n#\n# innerH_mon the inner product of symmetric functions in th
e h-basis\n#     -- it is based on the Laplace property of the inner a
nd outer products\n#     -- i)  (a.b) o c = \\sum_(c)  (a o c_(1)) . (
b o c_(2))\n#     -- ii) c o (a.b) = \\sum_(c)  (c_(1) o a) . (c_(2) o
 b)\n#     -- where we have used:\n#     --  . outer product\n#     --
  \\Delta(c)= \\sum_(c) c_(1) otimes c_(2) outer coproduct\n#     --  \+
o inner product \n#\ninnerH_mon:=proc(hfktmon1,hfktmon2)\n  local n,m,
coh,f;\n  n,m:=nops([op(hfktmon1)]),nops([op(hfktmon2)]);\n  if `+`(op
(hfktmon1))<> `+`(op(hfktmon2)) then\n     return 0;\n  elif n=1 then
\n     return hfktmon2;\n  elif m=1 then\n     return hfktmon1;\n  eli
f n<m then\n     f:=(a,b,x,y)->outerH(innerH_mon(a,x),innerH_mon(b,y))
; \n     coh:=&t(couterH(hfktmon1),h[[op(hfktmon2)][1]],h[op([op(hfktm
on2)][2..-1])]);\n     return eval(subs(`&t`=f,coh));\n  else\n     f:
=(a,b,x,y)->outerH(innerH_mon(a,x),innerH_mon(b,y)); \n     coh:=&t(co
uterH(hfktmon2),h[[op(hfktmon1)][1]],h[op([op(hfktmon1)][2..-1])]);\n \+
    return eval(subs(`&t`=f,coh));\n  end if;\nend proc:\n#\n# innerH \+
is the linear version of innerH_mon\n#\n#\ninnerH:=proc(x)\n  option `
Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved
.`,\n  remember;\n  local cf,tm,p1,p2,y,f;\n  if nargs=1 then return x
 end if;\n  y:=args[2];\n  if x=0 or y=0 then return 0 end if;\n  if n
args>2 then return procname(expand(procname(x,y)),args[3..-1]) end if;
\n  if not(type(x,hfktpolynom) and type(args[2],hfktpolynom)) then err
or \"wrong type\\n\" end if;\n  if type(x,`+`) then \n    return map(p
rocname,x,y);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,
x,hfktmonom);\n    return cf*procname(tm,y)\n  else\n    if type(y,`+`
) then \n      return map2(procname,x,y);\n    elif type(y,`*`) then\n
      tm,cf:=selectremove(type,y,hfktmonom);\n      return cf*procname
(x,tm)\n    else\n      innerH_mon(x,y);\n    end if;\n  end if;\nend \+
proc:\n###############################################################
########################\n#\n# inner is the inner product on Schur fun
ctions. It establishes the tensor product\n#    of S_n representations
 in terms of their characters under the Frobenius \n#    characteristi
c map.\n#\ninner_mon := proc(sfkt1,sfkt2)\n  option `Copyright (c) B. \+
Fauser & R. Ablamowicz 2004-2009. All rights reserved.`; \n  local n1,
n2,prt,mat,i,k,lst1,lst2,m;\n  lst1:=[op(sfkt1)];\n  lst2:=[op(sfkt2)]
;\n  n1:=`+`(op(lst1));\n  n2:=`+`(op(lst2));\n  if n1<>n2 then return
 0 end if;\n  if op(sfkt1)=0 and op(sfkt2)=0 then return s[0] end if;
\n  prt:=PartNM(n1,n1);\n  n2:=nops(prt);\n  mat:=matrix(n2,n2,(i,j)->
MurNak(prt[j],prt[i]));\n # -- find position of lst1, and lst2 in prt
\n  i:=1:while prt[i]<>lst1 do i:=i+1; end do;\n  k:=1:while prt[k]<>l
st2 do k:=k+1; end do;\n # -- use the characters to generate the multp
. table\n  add(add(\n    zee(prt[l])^(-1)*mat[i,l]*mat[k,l]*mat[m,l]*s
[op(prt[m])]\n      ,l=1..nops(prt)),m=1..n2);\n######################
##################################\n##\n##  this is a direct way to co
mpute the inner product, needs to be tested\n##  in speed against the \+
above version, rsults are the same.\n##  Note: in MurNak seems to be a
 transposition, so that here\n##        MurNak(par1,par2) = scalarPS(p
[par1],s[par2])\n##\n##  add(add(\n##    zee(rho)^(-1)*MurNak(rho,lst1
)*MurNak(rho,lst2)*MurNak(rho,lambda)*s[op(lambda)]\n##      ,rho in p
rt),lambda in prt)\n\nend proc:\n#\n#\ninner:=proc(x)\n  option `Copyr
ight (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n
  remember;\n  local cf,tm,p1,p2,y,f;\n  if nargs=1 then return x end \+
if;\n  y:=args[2];\n  if x=0 or y=0 then return 0 end if;\n  if nargs>
2 then return procname(procname(x,y),args[3..-1]) end if;\n  if not(ty
pe(x,sfktpolynom) and type(args[2],sfktpolynom)) then error \"wrong ty
pe\\n\" end if;\n  if type(x,`+`) then \n    return map(procname,x,y);
\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,sfktmonom);
\n    return cf*procname(tm,y)\n  else\n    if type(y,`+`) then \n    \+
  return map2(procname,x,y);\n    elif type(y,`*`) then\n      tm,cf:=
selectremove(type,y,sfktmonom);\n      return cf*procname(x,tm)\n    e
lse\n      if x=0 or y=0 then return 0 end if;\n      inner_mon(x,y)\n
    end if;\n  end if;\nend proc:\n###################################
##################################################\n#\n# innerM implem
ents the inner product for monomial symmetric function bases\n#\n#####
######################################################################
##########\ninnerM:=proc(x)\n   local y,lst;\n   if nargs=1 then retur
n x end if;\n   if nargs>2 then\n     y:=args[2];\n     lst:=args[3..-
1];\n     return procname(expand(procname(x,y)),lst); \n   else\n     \+
y:=args[2];\n     p_to_m(innerP(m_to_p(x),m_to_p(y)));\n   end if;\nen
d proc:\n#\n# cinner_mon is the inner coproduct on monomials, it is th
e Schur-Hall dual of \n#            the inner product of Schur functio
ns and is computed by using that\n#            particular fact.\n#\nci
nner_mon:=proc(sfkt)\n  option `Copyright (c) B. Fauser & R. Ablamowic
z 2004-2009. All rights reserved.`; \n  local n1,n2,prt,lst;\n  if sfk
t=0 then return 0 end if;\n  lst:=[op(sfkt)];\n  if sfkt=s[0] then ret
urn &t(s[0],s[0]) end if;\n  n1:=`+`(op(lst));\n  prt:=SchurFkt:-PartN
M(n1,n1);\n  add(&t(s[op(i)],inner(s[op(i)],s[op(lst)])),i=prt);\nend \+
proc:\n#\n# cinner is the linear version of cinner_mon\n#\ncinner:=pro
c(x)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All
 rights reserved.`,\n  remember;\n  local cf,tm,n1,plst1,plst2,i;\n  i
f type(x,`+`) then \n    return map(procname,x);\n  elif type(x,`*`) t
hen \n    tm,cf:=selectremove(type,x,sfktmonom);\n    return cf*procna
me(tm)\n  else\n    cinner_mon(x);  \n  end if;\nend proc:\n#\n# couni
tInnerS computes the counit of the inner coporduct in the\n#        Sc
hur function basis\n#\ncounitInnerS:=proc(x)\n  option `Copyright (c) \+
B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n  remembe
r;\n  local cf,tm;\n  if type(x,`+`) then \n    return map(procname,x,
serName);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,sf
ktmonom);\n    return cf*procname(tm,serName)\n  else\n    subs(s[0]=1
,Scalar(x,s[`+`(op(x))]));\n  end if;\nend proc:\n#\n# innerP_mon comp
uter the inner product of power sum functions. \n#\ninnerP_mon := proc
(pfkt1,pfkt2)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-
2009. All rights reserved.`; \n  local n1,n2,bool,lst1,lst2;\n  n1:=`+
`(op(pfkt1));\n  n2:=`+`(op(pfkt2));\n  if n1<>n2 then return 0 end if
;\n  bool:=map(x->if x=0 then true else false end if,zip((x,y)->x-y,[o
p(pfkt1)],[op(pfkt2)]));\n  if convert(bool,set)=\{true\} then\n    re
turn zee([op(pfkt1)])*pfkt1;\n  else \n    return 0;\n  end if; \nend \+
proc:\n#\n# innerP is the multilinear version of the inner product in \+
power sum basis\n#\ninnerP:=proc(x)\n  option `Copyright (c) B. Fauser
 & R. Ablamowicz 2004-2009. All rights reserved.`,\n  remember;\n  loc
al cf,tm,p1,p2,y,f;\n  if nargs=1 then return x end if;\n  y:=args[2];
\n  if x=0 or y=0 then return 0 end if;\n  if nargs>2 then return proc
name(expand(procname(x,y)),args[3..-1]) end if;\n  if not(type(x,pfktp
olynom) and type(args[2],pfktpolynom)) then error \"wrong type\\n\" en
d if;\n  if type(x,`+`) then \n    return map(procname,x,y);\n  elif t
ype(x,`*`) then \n    tm,cf:=selectremove(type,x,pfktmonom);\n    retu
rn cf*procname(tm,y)\n  else\n    if type(y,`+`) then \n      return m
ap2(procname,x,y);\n    elif type(y,`*`) then\n      tm,cf:=selectremo
ve(type,y,pfktmonom);\n      return cf*procname(x,tm)\n    else\n     \+
 innerP_mon(x,y);\n    end if;\n  end if;\nend proc:\n#\n# cinnerP_mon
 computes the inner coproduct on monomials in the power sum\n#        \+
     basis, this coproduct is grouplike on all basis elements\n#      \+
       x |-->  &t(x,x) \n#\ncinnerP_mon:=proc(x)\n  &t(x,x);\nend proc
:\n#\n# cinnerP linear version of the inner coproduct in the power sum
 basis\n#\n#\ncinnerP:=proc(x)\n  option `Copyright (c) B. Fauser & R.
 Ablamowicz 2004-2008. All rights reserved.`,\n  remember;\n  local cf
,tm;\n  if type(x,`+`) then \n    return map(procname,x);\n  elif type
(x,`*`) then \n    tm,cf:=selectremove(type,x,pfktmonom);\n    return \+
cf*procname(tm)\n  else\n    cinnerP_mon(x);\n  end if;\nend proc:\n#
\n# cinnerP linear version of the inner coproduct in the power sum bas
is\n#\n#\ncounitInnerP:=proc(x)\n  option `Copyright (c) B. Fauser & R
. Ablamowicz 2004-2008. All rights reserved.`,\n  remember;\n  local c
f,tm;\n  if type(x,`+`) then \n    return map(procname,x);\n  elif typ
e(x,`*`) then \n    tm,cf:=selectremove(type,x,sfktmonom);\n    return
 cf*procname(tm)\n  else\n    return 1;\n  end if;\nend proc:\n#######
##########################################################\n#\n#  cdia
g implements the diagonalization coproduc in all 5 standard\n#        \+
bases the default basis is the 'p-basis' of power sums\n#        This \+
implements (if based on power sums) effectively the\n#        inner co
product.\n#  NOTE: The cdiag(x,TYPE) functions are _different_ if anot
her\n#        basis is chosen. cdiag(x,s) <> cdiag(x,m) etc. \n#\n####
#############################################################\ncdiag:=
proc(x)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2006. \+
All rights reserved.`;\n  local cf,term,TYPE;\n  if nargs=2 then\n    \+
TYPE:=args[2];\n    if not member(TYPE,\{s,p,m,h,f,e\}) then\n      er
ror \"You picked a type '%1' which is not in my list of known types\\n
 's,p,m,h,f,e' !\",TYPE;\n    end if;\n  else \n    TYPE:='p';\n  end \+
if;\n  if x=0 then return 0; end if;\n  if type(x,cat(TYPE,fktpolynom)
) then\n    if type(x,`+`) then\n      return map(procname,x,TYPE);\n \+
   elif type(x,`*`) then\n      term,cf:=selectremove(type,x,cat(TYPE,
fktmonom));\n      return cf*procname(term,TYPE);\n    else\n      ret
urn &t(x,x);\n    end if;\n  else\n    error \"No basis monom of type \+
`%1` found, allowed types are in \{s,p,h,m,e,f\}!\\n\",TYPE;\n  end if
;\nend proc:\n########################################################
############################\n#\n# Plethysms\n#\n#####################
###############################################################\n#\n# \+
list_divisors(n::posint) -> a list of all natrural numbers which divid
e n \n#\nlist_divisors:=proc(x)\n  option `Copyright (c) B. Fauser & R
. Ablamowicz 2004-2009. All rights reserved.`; \n  local i,t,res;\n  i
f x=1 then return [1] end if;\n  res:=[];\n  for i from 1 to floor(x/2
) do\n    t:=irem(x,i);\n    if t = 0 then\n      res:=[op(res),i];\n \+
   end if;\n  end do;  \n  [op(res),x];\nend:\n#######################
#############################################################\n#\n# pl
ethysm coproduct of a single part power sum \n#\n#####################
###############################################################\npleth
PsingleP:=proc(pfkt)\n   option `Copyright (c) B. Fauser & R. Ablamowi
cz 2004-2009. All rights reserved.`; \n   local part,ld;\n   part:=[op
(pfkt)];\n   ld:=list_divisors(op(part));\n   add(&t(p[i],p[op(part)/i
]),i=ld);\nend proc:\n#\n# plethP_mon computes the plethysm between tw
o power sum basis monoms. We have\n#       -- p_0[p\\mu]=p[0]\n#      \+
 -- p_\\mu[p_0]=p_0\n#       -- p_n[p_m]=p_n.m\n#       -- p_n[p_mu]=p
_\\mu[p_n] and hence\n#       -- p_\\mu[p_\\nu] = \\prod_(i,j) p_[\\mu
_i.\\nu_j]\n#\n# NOTE: THIS VERSION SEEMS TO BE SLOWER THAN THE BELOW \+
GIVEN BY A FACTOR 1.5\n#\n#plethP_mon:=proc(x,y)\n#  option `Copyright
 (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n#   \+
      remember;\n#  local p1,p2;\n#  p1,p2:=[op(x)],[op(y)];\n#  if p1
=[0] or p2=[0] then return p[0] end if;\n#  if nops(p1)=1 then\n#    i
f nops(p2)=1 then\n#       return p[op(p1)*op(p2)]\n#    else\n#      \+
 return p[op(map(x->op(p1)*x,p2))]\n#    end if\n#  else\n#    outerP(
seq(procname(p[l],y),l in p1));\n#  end if;\n#end proc:\n#############
#####################################################################
\n# plethP_mon is the plethysm product on power sum symmetric monomial
 functions\n#   -- nonrecursive version\n#\n#\nplethP_mon:=proc(pfkt1,
pfkt2)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. A
ll rights reserved.`;\n  local part1,part2;\n  part1:=[op(pfkt1)];\n  \+
part2:=[op(pfkt2)];\n     p[op(sort(\n         [seq(seq(part1[i]*part2
[j],i=1..nops(part1)),j=1..nops(part2))],\n         (i,j)->if i>j then
 true else false end if\n           ))];\nend proc:\n#\n# plethysm of \+
power sum polynomials ...\n#\n# plethP(P,Q) = P[Q]\n#  -- linear in P \+
  (P1+P2)[Q]=P1[Q]+P2[Q]\n#  -- not linear in Q, that is\n#  -- P[Q1+Q
2]=P_(1)[Q1].P_(2)[Q2]  where \\Delta(P)=P_(1) \\otimes P_(2) is the o
uter coproduct\n#  -- P[Q1.Q2]=P_[1][Q1].P_[2][Q2]  where \\delta(P)=P
_[1] \\otimes P_[2] is the inner corpoduct\n#                         \+
          (this case is trated in plethP_mon\n#  -- P[-Q]=(antipP(P))[
Q]          hence we need to split Q in to a positive and negative\n# \+
                                  part\n#\nplethP:=proc(x,y)\n  option
 `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserv
ed.`,\n         remember;\n  local cf,term,term2,cout,sgn,f0,f1,a,b;\n
  if type(x,pfktmonom) then\n    if x=p[0] then return p[0] end if;\n \+
   if x=p[1] then return y end if;\n    if type(y,pfktmonom) then\n   \+
   if y=p[0] then return p[0] end if;\n      if y=p[1] then return x e
nd if;\n      return plethP_mon(x,y)\n    elif type(y,`*`) then\n#  --
 note that cf*term = term+term+...+term is the additive case!!\n      \+
term,cf:=selectremove(type,y,pfktmonom);\n      if type(cf,integer) th
en\n        if cf<0 then\n          return (-1)^nops([op(x)])*procname
(x,-cf*term);\n        end if;\n#  -- put a bracket [cf-1] to prevent \+
linear expansion in the tensor &t(...)\n        cout:=&t(couterP(x),[c
f-1],term); \n        f0:=(u,v,c,t)->outerP(plethP(u,t),plethP(v,op(c)
*t));\n        return eval(subs(`&t`=f0,cout));\n      else\n#  -- put
 a bracket [cf] to prevent linear expansion in the tensor &t(...)\n   \+
#  -- works but is slower than a direct computation...\n   #     cout:
=&t(cinnerP(x),[cf],term);\n   #     f1:=(x1,x2,cf,term)->dimGLP(x1,op
(cf))*plethP_mon(x2,term);\n   #     return eval(subs(`&t`=f1,cout ));
\n   #     error(\"2nd argument need to be a polynomial over the integ
ers but received: %1\\n\",y);\n        return cf^nops([op(x)])*plethP_
mon(x,term);\n      end if;\n    else\n      cout:=[op(y)];\n      a,b
:=cout[1],cout[2..-1];\n      cout:=&t(couterP(x),[a],b);\n      f0:=(
u,v,c,t)->outerP(plethP(u,op(c)),plethP(v,`+`(op(t)))):\n         retu
rn eval(subs(`&t`=f0,cout));   \n    end if;\n  elif type(x,`*`) then
\n    term,cf:=selectremove(type,x,pfktmonom);\n    return cf*procname
(term,y);\n  else\n    return map(procname,x,y);\n  end if;\nend proc:
\n" }{MPLTEXT 1 0 17368 "#\n# cplethP is the plethystic coproduct on p
ower sum functions\n#\n#\ncplethP:=proc(pfkt)\n  option `Copyright (c)
 B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;\n  local \+
cf,term,llst,dlst,res,i,Npi,pi,dPi;\n##\n  if type(pfkt,`+`) then \n  \+
  return map(procname,pfkt)\n  elif type(pfkt,`*`) then\n    term,cf:=
selectremove(type,pfkt,pfktmonom);\n    return cf*procname(term)\n  el
se\n  ######\n    pi:=[op(pfkt)];\n    Npi:=`+`(op(pi));\n    dPi:=lis
t_divisors(Npi);\n    res:=0;\n    for i in dPi do\n       llst:=PartN
M(i,i);\n       dlst:=PartNM(Npi/i,Npi/i);\n       res:=res+\n        \+
 add(add(\n            1/(zee(l)*zee(d))\n            *ScalarP(p[op(pi
)],plethP(p[op(l)],p[op(d)]))*&t(p[op(l)],p[op(d)])\n            ,l=ll
st),d=dlst);\n    end do;\n    res;\n  ######\n  end if; \nend proc:\n
######################################################################
###########\n#\n#    SFunction PLETHYSMS\n#\n#########################
########################################################\n#\n# plethys
m of two complete symmetric functions aka s[n],s[m]\n#\n#   -- we use \+
the notation P[Q]=pleth(P,Q), hence the plethysm is linear in P (first
 variable)\n#   -- the plethysm is not linear in the second variable Q
, it distributes with the inner\n#   -- coproduct over the the second \+
argument:\n#   -- P[Q1.Q2]=P_\{[1]\}[Q1].P_\{[2]\}[Q2]\n#   -- if P is
 given in a power sum basis, then \\delta P = P_[1]\\otimes P_[2] = P \+
\\otimes P\n#\n#  +++ plethsp(sfkt,pfkt) -> sfkt\n#   --         this \+
function is based on the transition s_to_p and the power sum plethysm
\n#   --         of pfktmonomials, followed by a transformation back i
nto sfunctions!\n#   --         plethP_mon computes pfktmonom[pfktmono
m] plethysms \n#   --         Since x=s[n] is a one row sfkt (complete
 function), the characters in the\n#   --         expansions are all 1
 and dissapear from the computation.\n#\nplethsp:=proc(x,y)\n  option \+
`Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserve
d.`,\n  remember;\n  local n;\n  n:=op(x);\n  p_to_s(add(1/zee(i)*plet
hP(y,p[op(i)]),i in PartNM(n,n)));\nend proc:\n#\n# +++ plethSnm(sfkt,
sfkt) -> sfkt\n#  --      this function expands the outer one row Sfun
ction into power sums (without\n#  --      characters as in plethsp ab
ove) and uses afterwards the fact that \n#  --      p_n[Q] = Q[p_n] fo
r one part (primitive) power sum functions. The remaining\n#  --      \+
plethysms are of the form s_n[p_k] which can be computed via the funct
ion\n#  --      plethsp defined above.\n#  --      This function does \+
not make use of a possible cancellation of terms due\n#  --      to th
e finiteness of dimenions (the alphabet involved)\n#  --      This fun
ction is by fare not optimal (see Axel Kohnert's algorithm)\n#\nplethS
nm:=proc(x,y)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-
2009. All rights reserved.`,\n  remember;\n  local n,m;\n  n,m:=op(x),
op(y);\n  if n=0 then \n    return s[0]\n  elif m=0 then \n    return \+
s[0]\n  elif n=1 then\n    return y\n  elif m=1 then \n    return x\n \+
 end if; \n  add(1/zee(i)*outer(op(map((k)->plethsp(s[m],p[k]),[op(i)]
))) ,i in PartNM(n,n));\nend proc:\n#\n# plethSP: sfkt x pfkt --> sfkt
\n# +++   plethSP realized the pletysm of an Sfucntion monom by a pfkt
monom for general\n#  --   partitions \\lambda,\\mu. This time we need
 to insert the characters of the\n#  --   s_to_p transition computed v
ia the Murnaghan Nakayama rule.\n#\n#  ++   plethSP shows that\n#  ++ \+
  plethSP(s[n],p[0]) = s[0]\n#  ++   plethSP(s[lambda],p[0]) = 0  for \+
\\length(lambda)>1\n#\nplethSP:=proc(x,y)\n  option `Copyright (c) B. \+
Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n  remember;
\n  local i,n;\n  n:=`+`(op(x));\n  p_to_s(add(1/zee(i)*MurNak(i,[op(x
)])*plethP(y,p[op(i)]),i in PartNM(n,n)));\nend proc:\n#\n#\n# plethS_
mon : sfkt x sfkt --> sfkt\n# +++ plethS_mon computes the pletysm of t
wo SFunction monoms. It uses the expansion \n#  -- s_to_p and thereby \+
the Murnaghan Nakayama coefficients. The second step is once \n#  -- m
ore to use p_n[s_\\lambda] = s_\\lambda[p_n] and compute these plethys
ms via\n#  -- plethSP\n#\nplethS_mon:=proc(x,y)\n  option `Copyright (
c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n      \+
   remember;\n  local n,m,i;\n  n,m:=`+`(op(x)),`+`(op(y));\n  if n=0 \+
then \n    return s[0]\n  elif m=0 then\n    # -- according to SCHUR (
and plethSP see above)\n    # -- plethS(s[n],s[0]) = s[0]\n    # -- pl
ethS(s[lambda],s[0]) = 0 if length(lambda)>1\n    if nops([op(x)]) > 1
 then  \n      return 0\n    else\n      return s[0]\n    end if;\n  e
lif n=1 then\n    return y\n  elif m=1 then \n    return x\n  end if; \+
\n  expand(\n     add(1/zee(i)*MurNak(i,[op(x)])*outer(op(map((k)->ple
thSP(y,p[k]),[op(i)]))) \n         ,i in PartNM(n,n))  );\nend proc:\n
######################################################################
##\n#\n# plethSAxNB computes the plethysm of a Schur function A with t
he\n#    n-fold multiple of a Schur function B  A[n.B] using the inner
\n#    coproduct. This can be used to produce q-deformed symmetric\n# \+
   functions [see Francesco Brenti, A Class of q-Symmetric Functions\n
#    Arising from Plethysm, J. Comb.Theor. Series A 91, 2000:137-170]
\n#\n#################################################################
#######\nplethSAxNB:=proc(sfkta,sfktb,N)\n  option `Copyright (c) B. F
auser & R. Ablamowicz 2004-2009. All rights reserved.`;\n  local f;\n \+
 if N=1 then return plethS(sfkta,sfktb) end if;\n  if N=0 then return \+
0 end if;\n  f:=(x,y,n,sb)->dimGL(x,op(n))*plethS(y,sb):\n  eval(subs(
`&t`=f,  &t(cinner(sfkta),[N],sfktb)  ));\nend proc:\n#\n#  X[Y] is li
near in X and not linear in Y\n#  -- (X+Y)[Z] = X[Z] + Y[Z]\n#  -- X[Y
+Z] = X(1)[Y] . X(2)[Z]   where . = outer, couter(X)=X(1) x X(2)\n#  -
- X[YZ] = X[1] . X[2]  where . = outer, cinner(X) =X[1] x X[2]\n#  -- \+
        this case does not appear in the function, since unevaluated\n
#  --         outer products YZ do not appear.\n#\nplethS:=proc(x,y)\n
  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All right
s reserved.`,\n         remember;\n  local cf,tm,p1,p2,a,b,f;\n# ++ sp
ecial cases\n# -- one argument numerical zero\n  if x=0 then \n     re
turn 0\n  elif y=0 then \n     return 0\n  end if;\n# ++ typecheck\n  \+
if not(type(x,sfktpolynom) and type(y,sfktpolynom)) then \n     error \+
\"wrong type\\n\" \n  end if;\n  if x=s[0] then \n  #-- s_(0)[s_(lambd
a)] = s_(0) for all lambda\n    return s[0]\n  # -- the case y=s[0] ne
eds a more sophisticated treatment\n  # -- which is done in plethS_mon
\n  # ++ s[1] is left and right unit of plethS\n  elif x=s[1] then\n  \+
  return y\n  elif y=s[1] then\n    return x\n  end if;\n## -- end of \+
special cases\n## -- plethS is linear in x but _not_ linear in y\n## +
+ linearity in x \n  if type(x,`+`) then \n    return map(procname,x,y
);\n  elif type(x,`*`) then \n    tm,cf:=selectremove(type,x,sfktmonom
);\n    return cf*procname(tm,y)\n  else\n## -- the y argument distrib
utes using coproducts\n## -- outer roducts do not happen, so we need t
o distinguish\n## -- two types of additive terms y = a+b and y = a+a =
 2a\n## -- different terms have type `+`\n##\n## -- the following code
 cures a subtle error in the plethysm routine\n## -- found via computi
ng a problem of Ralf Holtkamp\n## -- one needs to make sure that the `
+`(op(b_)) is only evaluated\n## -- after the expansion has taken plac
e!\n## -- change this part of teh code only with care and severe check
ig\n## -- of at least 3 summand entries for x,y\n    if type(y,`+`) th
en \n      b:=[op(y)];\n      a:=&t(couter(x),[b[1]],b[2..-1]);\n     \+
 f:=(x_,y_,a_,b_)->outer( plethS(x_,op(a_)),expand( plethS(y_,`+`(op(b
_))) ) );\n      return eval(subs(`&t`=f,a));\n## -- numerical multipl
es of the same term\n    elif type(y,`*`) then\n      tm,cf:=selectrem
ove(type,y,sfktmonom);\n##//// here we could use plethSAxNB to allow e
ven symbolic prefactors\n      if not type(cf,integer) then\n         \+
return expand(plethSAxNB(x,tm,cf));\n##//// we do not put this error m
essage any longer  \n##       error \"Second input must be a polynomia
l over the integers, but received \",y; \n      end if;\n      if cf>0
 then\n        return expand(plethSAxNB(x,tm,cf));\n        #-- obsole
te code\n        #--a:=&t(couter(x),tm,[cf-1]);\n        #--f:=(x_,y_,
a_,b_)->outer(plethS_mon(x_,a_),plethS(y_,op(b_)*a_));\n        #--ret
urn eval(subs(`&t`=f,a));\n      else\n        return procname(antipS(
x),-y);\n      end if;\n    else\n## ++ if neither x nor y has type `+
` or `*` then we have tow sfktmonomials \n      plethS_mon(x,y)\n    e
nd if;\n  end if;\nend proc:\n########################################
###################################\n#\n# cplethS_mon is the plethysm \+
coproduct of a sfktmonom\n#    -- the plethysm coproduct is obtained b
y dualizing the plethysm operation w.r.t\n#    -- the Schur-Hall scala
r product:\n#    -- cplethS(x) = \\sum_(y,z)  < x ,plethS(y,z) > (y &t
 z)\n#    -- where <,> is teh scalar product and plethS is the pelthys
m of sfunctions\n#    -- note that this is a noncocommutative operatio
n and the order of y,z matters.\n#\ncplethS_mon:=proc(x)\n  local n,di
vx,prta,prtb;\n  n:=`+`(op(x));\n  divx:=list_divisors(n);\n  add(add(
add(\n     eval(subs(s[0]=1,Scalar(x,plethS(s[op(a)],s[op(b)]))))*&t(s
[op(a)],s[op(b)]), \n    b in PartNM(n/i,n/i)), a in PartNM(i,i)), i i
n divx);\nend proc:\n#\n# cplethS is the linear version of cplethS_mon
 establishing the plethysm coproduct of \n#    -- SFunctions.  \n#\n#
\ncplethS:=proc(x)\n  option `Copyright (c) B. Fauser & R. Ablamowicz \+
2004-2009. All rights reserved.`,\n  remember;\n  local cf,tm,n1,plst1
,plst2,i;\n  if x=0 then return 0 end if;\n  if type(x,`+`) then \n   \+
 return map(procname,x);\n  elif type(x,`*`) then \n    tm,cf:=selectr
emove(type,x,sfktmonom);\n    return cf*procname(tm)\n  else\n    if x
=s[0] then return &t(s[0],s[0]) end if;\n    cplethS_mon(x);  \n  end \+
if;\nend proc:\n######################################################
#####################\n#\n#\n#########\n######### Orthogonal Hopf alge
bra\n#########\n#\n# outerON_monom outer product on s-function monoms \+
of the orthogonal group\n#\n#\nouterON_monom:=proc(x,y)\n  option `Cop
yright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;
\n  local N,prt;\n  N:=min(`+`(op(x)),`+`(op(y)));\n  prt:=[s[0],op(ma
p(x->s[op(x)],[seq(op(PartNM(i,i)),i=1..N)]))];\n  add(outer(skew(x,s[
op(i)]),skew(y,s[op(i)])),i=prt);\nend proc:\n#\n# outerON outer produ
ct of s-function polynoms fro orthogonal groups\n#\n#\n#\nouterON:=pro
c(x)\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All
 rights reserved.`,\n  remember;\n  local cf,tm,p1,p2,y,f;\n  if nargs
=1 then return x end if;\n  y:=args[2];\n  if x=0 or y=0 then return 0
 end if;\n  if nargs>2 then return procname(expand(procname(x,y)),args
[3..-1]) end if;\n  if not(type(x,sfktpolynom) and type(args[2],sfktpo
lynom)) then error \"wrong type\\n\" end if;\n  if type(x,`+`) then \n
    return map(procname,x,y);\n  elif type(x,`*`) then \n    tm,cf:=se
lectremove(type,x,sfktmonom);\n    return cf*procname(tm,y)\n  else\n \+
   if type(y,`+`) then \n      return map2(procname,x,y);\n    elif ty
pe(y,`*`) then\n      tm,cf:=selectremove(type,y,sfktmonom);\n      re
turn cf*procname(x,tm)\n    else\n      outerON_monom(x,y);\n    end i
f;\n  end if;\nend proc:\n#\n# couterON_monom outer coproduct of s-fun
ction monoms for the orthogonal groups \n#\n#\ncouterON_monom:=proc(x)
\n  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rig
hts reserved.`;\n  local prt, del;\n  prt:=[[0],seq(op(PartNM(i,i)),i=
1..`+`(op(x)))];\n  del:=map(x->2*x,[[0],seq(op(PartNM(i,i)),i=1..floo
r(`+`(op(x)))/2)]);\n  add(&t(skew(x,outer(add(s[op(k)],k=del),s[op(i)
])),s[op(i)]),i=prt); \nend proc:\n#\n# couterON outer coproduct of sf
unction polynoms for the orthogonal groups \n#\ncouterON:=proc(x)\n  o
ption `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights r
eserved.`,\n         remember;\n  local cf,tm;\n  if type(x,`+`) then \+
\n    return map(procname,x);\n  elif type(x,`*`) then \n    tm,cf:=se
lectremove(type,x,sfktmonom);\n    return cf*procname(tm)\n  else\n   \+
 couterON_monom(x);  \n  end if;\nend proc:\n#########################
###############################################################\n##\n#
# S-function Series facilities\n##\n##################################
######################################################\n#\n#  getSfktS
eries returns a sum of S-functions of a known Schur function series\n#
\n#  -- currently known series are M,L,D,B,F\n#\ngetSfktSeries:=proc(n
ame)\n   option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. Al
l rights reserved.`,\n          remember;\n   local N,prt,serFlag,t,f,
m,i,j;\n   if nargs=1 then\n      if args[1]='names' then \n        re
turn \"Known Series are: A,B,C,D,E,F,L,M\";\n      else\n        error
 \"Usage: either give one argument 'names' or [2|3] arguments, see hel
p page\";\n      end if;\n   end if; \n   if nargs>=2 then N:=args[2] \+
end if;\n   if nargs=3 then serFlag:=true; t:=args[3] else serFlag:=fa
lse end if;\n   ## ///////////////////////////\n   ## M-series = \\sum
 \{m\} t^m\n   ##\n   if name='M' then\n      if serFlag=false then\n \+
        return [seq(s[m],m=0..N)];\n      else\n         add(s[m]*t^m,
m=0..N);\n      end if;\n   ## ///////////////////////////\n   ## L-se
ries = \\sum (-1)^m \{1^m\} t^m\n   ##\n   ## (special care for zero p
artition)\n   ##\n   elif name='L' then\n      if serFlag=false then\n
         return [seq((-1)^m*s[m],m=0..N)];\n      else\n         f:=m-
>if m=0 then 0 else 1$m end if:\n         add((-1)^m*s[f(m)]*t^m,m=0..
N);\n      end if;\n   ## ///////////////////////////\n   ## C-series \+
= \\sum \{\} (inverse of the D series)\n   ##\n   ## (we scale the par
ameter t also!)\n   elif name='C' then\n      prt:=[s[0],op(\n        \+
      map(x->if \{1\}=\{op(zip((i,j)->i-j,op(part2Frob([op(x)]))))\} t
hen \n                  (-1)^(`+`(op(x))/2)*x else   NULL end if,procn
ame(F,N))  )];\n      if serFlag=false then\n         return prt;\n   \+
   else\n        ## --- take care of the sign\n        f:=proc(x,t)\n \+
          local cf,term;\n           cf:=1:\n           if type(x,`*`)
 then\n             term,cf:=selectremove(type,x,sfktmonom);\n        \+
     return (cf*t)^(`+`(op(term)))\n           else\n             retu
rn (cf*t)^(`+`(op(x)))\n           end if;\n         end proc:\n      \+
   ## ---        \n         add(i*f(i,t),i=prt);\n      end if;\n   ##
 ///////////////////////////\n   ## D-series = \\sum \{delta\}   delta
=even parts only\n   ##\n   ## (we scale the parameter t also!)\n   el
if name='D' then\n      prt:=map(x->2*x,[[0],seq(op(PartNM(i,i)),i=1..
floor(N/2))]);\n      if serFlag=false then\n         return map(x->s[
op(x)],prt);\n      else\n         add(s[op(i)]*t^(`+`(op(i))),i=prt);
\n      end if;\n   ## ///////////////////////////   \n   ## B-series \+
= \\sum \{beta\}   conjpart(beta)=even parts only\n   ##\n   ## (we sc
ale the parameter t also!)\n   elif name='B' then\n      prt:=map(x->2
*x,[[0],seq(op(PartNM(i,i)),i=1..floor(N/2))]);\n      prt:=map(x->con
jpart(x),prt);\n      if serFlag=false then\n         return map(x->s[
op(x)],prt);\n      else\n         add(s[op(i)]*t^(`+`(op(i))),i=prt);
\n      end if;\n   ## ///////////////////////////\n   ## A-series  \n
   ##\n   elif name='A' then \n      prt:=[s[0],op(\n              map
(x->if \{1\}=\{op(zip((i,j)->j-i,op(part2Frob([op(x)]))))\} then \n   \+
               (-1)^(`+`(op(x))/2)*x else   NULL end if,procname(F,N))
  )];\n      if serFlag=false then\n         return prt;\n      else\n
        ## --- take care of the sign\n        f:=proc(x,t)\n          \+
 local cf,term;\n           cf:=1:\n           if type(x,`*`) then\n  \+
           term,cf:=selectremove(type,x,sfktmonom);\n             retu
rn (cf*t)^(`+`(op(term)))\n           else\n             return (cf*t)
^(`+`(op(x)))\n           end if;\n         end proc:\n         ## ---
        \n         add(i*f(i,t),i=prt);\n      end if;\n   ## ////////
///////////////////\n   ## E-series  = \\sum_self conj part (-)^(|x|+r
) *s[prt]\n   ##              r = Frobenius rank of the partition\n   \+
##\n   elif name='E' then \n      prt:=[s[0],op(\n              map(x-
>if \{0\}=\{op(zip((i,j)->j-i,op(part2Frob([op(x)]))))\} then \n      \+
               x else NULL end if,procname(F,N))  )];\n      if serFla
g=false then\n         return map(x->(-1)^((`+`(op(x))+nops(part2Frob(
[op(x)])[1]))/2)*x ,prt);\n      else\n         add((-1)^((`+`(op(i))+
nops(part2Frob([op(i)])[1]))/2)*i\n             *t^(`+`(op(i))),i=prt)
;\n      end if;\n   ## ///////////////////////////\n   ## F-series = \+
\\sum \{zeta\}  all partitions \n   ##\n   elif name='F' then\n      p
rt:=[[0],seq(op(PartNM(i,i)),i=1..N)];\n      if serFlag=false then\n \+
        return map(x->s[op(x)],prt);\n      else\n         add(s[op(i)
]*t^(`+`(op(i))),i=prt);\n      end if;\n    else\n      error \"unrec
ognized series name: use getSfktSeries(names) to see which names are k
nown!\";\n   end if;\nend proc:\n#\n# branch_monom internal function f
or branchings on monoms\n#\n# +++ !!!! this function should be already
 multilinear !!!!\n# +++ remove branch and rename this one after a tes
t!\nbranch_monom:=proc(x,serName)\n   option `Copyright (c) B. Fauser \+
& R. Ablamowicz 2004-2009. All rights reserved.`;\n  local ser;\n  ser
:=getSeries(serName,`+`(op(x)),1);\n  skew(x,ser);\nend proc:\n#\n# br
anch computes the reduction of induction of characters with respect to
\n#        certain S-function series\n#\nbranch:=proc(x,serName)\n  op
tion `Copyright (c) B. Fauser & R. Ablamowicz 2004-2006. All rights re
served.`,\n  remember;\n  local ser,cf,tm,n1,plst1,plst2,i;\n  if type
(x,`+`) then \n    return map(procname,x,serName);\n  elif type(x,`*`)
 then \n    tm,cf:=selectremove(type,x,sfktmonom);\n    return cf*proc
name(tm,serName)\n  else\n    ser:=SchurFkt:-getSfktSeries(serName,`+`
(op(x)),1);\n    skew(x,ser);  \n  end if;\nend proc:\n\n" }{MPLTEXT 
1 207 14 "end module:\n##" }}{PARA 6 "" 1 "" {TEXT -1 41 "SchurFkt Ver
sion 1.0.4 says 'Good bye...'" }}{PARA 6 "" 1 "" {TEXT -1 50 "SchurFkt
 Version 1.0.4 (2 xi 2009) at your service" }}{PARA 6 "" 1 "" {TEXT 
-1 58 "(c) 2003-2009 BF&RA, no warranty, no fitness for anything!" }}
{PARA 6 "" 1 "" {TEXT -1 83 "Increase verbosity by infolevel[`function
`]=val -- use online help > ?Bigebra[help]" }}}{EXCHG {PARA 227 "> " 
0 "" {MPLTEXT 1 206 77 "libname:=\"/usr/local/maple/maple13/Cliffordli
b\",libname;\nsavelib('SchurFkt');" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#
>%(libnameG6&QE/usr/local/maple/maple13/Cliffordlib6\"F&Q@/usr/local/m
aple/maple13/FGblibF'Q=/usr/local/maple/maple13/libF'" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "restart:restart:" }}{PARA 6 "" 1 "
" {TEXT -1 41 "SchurFkt Version 1.0.4 says 'Good bye...'" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "restart:with(SchurFkt);nops(%);" }}
{PARA 6 "" 1 "" {TEXT -1 50 "SchurFkt Version 1.0.4 (2 xi 2009) at you
r service" }}{PARA 6 "" 1 "" {TEXT -1 58 "(c) 2003-2009 BF&RA, no warr
anty, no fitness for anything!" }}{PARA 6 "" 1 "" {TEXT -1 83 "Increas
e verbosity by infolevel[`function`]=val -- use online help > ?Bigebra
[help]" }}{PARA 12 "" 1 "" {XPPMATH 20 "6#7fr%)AlexCompG%)CharHookG%'C
ompNMG%)DescentsG%%FLATG%*Frob2partG%-GesselThetaPG%-GesselThetaSG%)Ko
stkaPCG%,KostkaTableG%'LP_monG%)LaplaceMG%*LaplaceM2G%-LaplaceM_monG%-
LaplaceTableG%%MLING%'MurNakG%(MurNak2G%'PartNMG%'ScalarG%)ScalarHMG%)
ScalarMHG%(ScalarPG%'antipEG%'antipHG%'antipMG%(antipMCG%'antipPG%'ant
ipSG%'branchG%&cdiagG%'cinnerG%(cinnerPG%)cmp2partG%,cmp2prtMultG%-col
lect_sfktG%(concatMG%)conjpartG%-counitInnerPG%-counitInnerSG%'couterG
%(couterEG%(couterHG%(couterMG%)couterONG%(couterPG%(cplethPG%(cplethS
G%&dimGLG%'dimGLEG%'dimGLHG%'dimGLMG%'dimGLPG%&dimSNG%'dimSNEG%'dimSNH
G%'dimSNMG%'dimSNPG%'e_to_hG%'e_to_mG%'e_to_sG%6evalJacobiTrudiMatrixG
%1fallingFactorialG%.getSfktSeriesG%+grAlexCompG%'h_to_mG%'h_to_pG%'h_
to_sG%&innerG%'innerHG%'innerMG%'innerPG%*isLatticeG%8lehmerCodeToPerm
utationG%5lehmerCodeToSchurFktG%'m_to_eG%'m_to_hG%'m_to_pG%*m_to_pMatG
%'m_to_sG%0maxlengthSymFktG%*mset2partG%&outerG%'outerEG%'outerHG%(out
erLSG%'outerMG%(outerONG%'outerPG%'outerSG%'p_to_mG%'p_to_sG%*part2Fro
bG%*part2msetG%2partitionsInShapeG%8permutationToLehmerCodeG%'plethPG%
'plethSG%+plethSAxNBG%)plethSnmG%0risingFactorialG%'s_to_eG%'s_to_hG%)
s_to_hJTG%*s_to_hMatG%*s_to_hmatG%'s_to_mG%'s_to_pG%'s_to_xG%2schurToL
ehmerCodeG%3schurToLehmerCode1G%+sfkt_termsG%%skewG%'skewLRG%'skewLSG%
1skewToLehmerCodeG%)sq_coeffG%+transitionG%)truncLENG%(truncWTG%'x_to_
sG%$zeeG" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#\"$A\"" }}}{EXCHG {PARA 0 
"> " 0 "" {MPLTEXT 1 0 16 "&t(s[2],s[1,1]);" }}{PARA 11 "" 1 "" 
{XPPMATH 20 "6#-%#&tG6$&%\"sG6#\"\"#&F'6$\"\"\"F," }}}{EXCHG {PARA 0 "
> " 0 "" {MPLTEXT 1 0 204 "basS:=PartNM(4,4);\nmatrix(nops(basS)+1,nop
s(basS)+1,\n  (i,j)->if i=1 and j=1 then \"MurNak\" elif i=1 then s[op
(basS[j-1])] elif j=1 then s[op(basS[i-1])] else\n         MurNak(basS
[j-1],basS[i-1]) end if); " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 11 "" 1 "" {XPPMATH 20 "6#>%%basSG7'7#\"\"%7$\"\"$\"\"\"7$\"\"#F
,7%F,F*F*7&F*F*F*F*" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#K%'matrixG6#7(7
(Q'MurNak6\"&%\"sG6#\"\"%&F+6$\"\"$\"\"\"&F+6$\"\"#F4&F+6%F4F1F1&F+6&F
1F1F1F17(F*F1F1F1F1F17(F.!\"\"\"\"!F;F1F07(F2F<F;F4F<F47(F5F1F<F;F;F07
(F7F;F1F1F;F1Q(pprint0F)" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
211 "basS:=PartNM(4,4);\nmatrix(nops(basS)+1,nops(basS)+1,\n  (i,j)->i
f i=1 and j=1 then \"*\" elif i=1 then s[op(basS[j-1])] elif j=1 then \+
s[op(basS[i-1])] else\n         inner(s[op(basS[j-1])],s[op(basS[i-1])
]) end if);" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#>%%basSG7'7#\"\"%7$\"\"
$\"\"\"7$\"\"#F,7%F,F*F*7&F*F*F*F*" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#
K%'matrixG6#7(7(Q\"*6\"&%\"sG6#\"\"%&F+6$\"\"$\"\"\"&F+6$\"\"#F4&F+6%F
4F1F1&F+6&F1F1F1F17(F*F*F.F2F5F77(F.F.,*F*F1F.F1F2F1F5F1,&F.F1F5F1,*F.
F1F2F1F5F1F7F1F57(F2F2F<,(F*F1F2F1F7F1F<F27(F5F5F=F<F;F.7(F7F7F5F2F.F*
Q(pprint0F)" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "KostkaTable(
4);" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#/%(Kostka4GK%'matrixG6#7'7'\"\"
\"F*F*F*F*7'\"\"!F*F*\"\"#\"\"$7'F,F,F*F*F-7'F,F,F,F*F.7'F,F,F,F,F*Q(p
print06\"" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "LaplaceTable(4
,6);" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#K%'matrixG6#7(7.%&<x|gry>G7#\"
\"'7$\"\"&\"\"\"7$\"\"%\"\"#7%F/F-F-7$\"\"$F37%F3F0F-7&F3F-F-F-7%F0F0F
07&F0F0F-F-7'F0F-F-F-F-7(F-F-F-F-F-F-7.7#F/&%\"mG6#\"#5\"\"!F@F@F@F@F@
F@F@F@F@7.7$F3F-F@,&&F=6$\"\")F0F-&F=6$F*F/F-,&&F=6$\"\"(F3F-*&F0F-&F=
6$F,F,F-F-F@FGF@F@F@F@F@F@7.7$F0F0F@FJFGF@FNF@F@F@F@F@F@7.7%F0F-F-F@F@
F@,&&F=6%F*F0F0F-&F=6%F,F3F0F-F@,(FWF-*&F0F-&F=6%F/F/F0F-F-*&F0F-&F=6%
F/F3F3F-F-F@FhnF@F@F@7.7&F-F-F-F-F@F@F@F@F@F@&F=6&F/F0F0F0F@&F=6&F3F3F
0F0F@F@Q(pprint06\"" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "getS
fktSeries(E,6);\ncollect(getSfktSeries(F,6,t),t);\ndimSN(expand(%));" 
}}{PARA 11 "" 1 "" {XPPMATH 20 "6#7(&%\"sG6#\"\"!,$&F%6#\"\"\"!\"\"&F%
6$\"\"#F+,$&F%6$F/F/F,,$&F%6%\"\"$F+F+F,&F%6%F6F/F+" }}{PARA 12 "" 1 "
" {XPPMATH 20 "6#,0*&,8&%\"sG6#\"\"'\"\"\"&F'6$\"\"&F*F*&F'6$\"\"%\"\"
#F*&F'6%F0F*F*F*&F'6$\"\"$F6F*&F'6%F6F1F*F*&F'6&F6F*F*F*F*&F'6%F1F1F1F
*&F'6&F1F1F*F*F*&F'6'F1F*F*F*F*F*&F'6(F*F*F*F*F*F*F*F*)%\"tGF)F*F**&,0
&F'6#F-F*&F'6$F0F*F*&F'6$F6F1F*&F'6%F6F*F*F*&F'6%F1F1F*F*&F'6&F1F*F*F*
F*&F'6'F*F*F*F*F*F*F*)FDF-F*F**&,,&F'6#F0F*&F'6$F6F*F*&F'6$F1F1F*&F'6%
F1F*F*F*&F'6&F*F*F*F*F*F*)FDF0F*F**&,(&F'6#F6F*&F'6$F1F*F*&F'6%F*F*F*F
*F*)FDF6F*F**&,&&F'6#F1F*&F'6$F*F*F*F*)FDF1F*F**&&F'6#F*F*FDF*F*&F'6#
\"\"!F*" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#,.%\"tG\"\"\"*&\"\"#F%)F$F'
F%F%*&\"\"%F%)F$\"\"$F%F%*&\"#5F%)F$F*F%F%*&\"#EF%)F$\"\"&F%F%*&\"#wF%
)F$\"\"'F%F%" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "" 0 "" {TEXT 
-1 3 "End" }}}}{MARK "4 0 0" 0 }{VIEWOPTS 1 1 0 1 1 1803 1 1 1 1 }
{PAGENUMBERS 0 1 2 33 1 1 }
