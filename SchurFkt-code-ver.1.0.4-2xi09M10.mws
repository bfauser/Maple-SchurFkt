{VERSION 6 0 "Linux" "6.0" }
{USTYLETAB {PSTYLE "Ordered List 1" -1 200 1 {CSTYLE "" -1 -1 "Times"
 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 3 3 2 0 2 0 2 2 -1 1 }
{PSTYLE "Ordered List 2" -1 201 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 
1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 3 3 2 36 2 0 2 2 -1 1 }{PSTYLE "Ordered
 List 3" -1 202 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 
0 0 1 }1 1 0 0 3 3 2 72 2 0 2 2 -1 1 }{PSTYLE "Ordered List 4" -1 203 
1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 3
 3 2 108 2 0 2 2 -1 1 }{PSTYLE "Ordered List 5" -1 204 1 {CSTYLE "" -1
 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 3 3 2 144 2 0 2 
2 -1 1 }{PSTYLE "Author" -1 19 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1
 2 2 2 2 2 2 1 0 0 1 }3 1 0 0 8 8 2 0 2 0 2 2 -1 1 }{PSTYLE "Warning" 
-1 7 1 {CSTYLE "" -1 -1 "Courier" 1 10 0 0 255 1 2 2 2 2 2 1 1 0 0 1 }
1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Annotation Title" -1 205 1 
{CSTYLE "" -1 -1 "Times" 1 18 0 0 0 1 2 1 2 2 2 2 1 0 0 1 }3 1 0 0 12 
12 2 0 2 0 2 2 -1 1 }{PSTYLE "Fixed Width" -1 17 1 {CSTYLE "" -1 -1 "C
ourier" 1 10 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }3 1 0 0 0 0 2 0 2 0 2 2 -1 1
 }{PSTYLE "Maple Plot" -1 13 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2
 2 2 2 2 2 1 0 0 1 }3 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Line Printe
d Output" -1 6 1 {CSTYLE "" -1 -1 "Courier" 1 12 0 0 255 1 2 2 2 2 2 1
 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Help" -1 10 1 {CSTYLE
 "" -1 -1 "Courier" 1 9 0 0 255 1 2 2 2 2 2 1 1 0 0 1 }1 1 0 0 0 0 2 0
 2 0 2 2 -1 1 }{PSTYLE "Text Output" -1 2 1 {CSTYLE "" -1 -1 "Courier"
 1 10 0 0 255 1 2 2 2 2 2 1 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }
{PSTYLE "Diagnostic" -1 9 1 {CSTYLE "" -1 -1 "Courier" 1 10 64 128 64 
1 2 2 2 2 2 1 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Normal" 
-1 0 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 
0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Maple Output" -1 11 1 {CSTYLE "" -1
 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }3 1 0 0 0 0 2 0 2 0 2 2 
-1 1 }{PSTYLE "Dash Item" -1 16 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 
1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 3 3 2 0 2 0 2 2 -1 1 }{PSTYLE "_pstyle1
38" -1 206 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1
 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "HyperlinkError" -1 207 1 
{CSTYLE "" -1 -1 "Courier" 1 12 255 0 255 1 2 2 1 2 2 1 1 0 0 1 }1 1 0
 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "_pstyle135" -1 208 1 {CSTYLE "" -1 
-1 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2
 2 -1 1 }{PSTYLE "Error" -1 8 1 {CSTYLE "" -1 -1 "Courier" 1 10 255 0 
255 1 2 2 2 2 2 1 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Titl
e" -1 18 1 {CSTYLE "" -1 -1 "Times" 1 18 0 0 0 1 2 1 1 2 2 2 1 0 0 1 }
3 1 0 0 12 12 2 0 2 0 2 2 -1 1 }{PSTYLE "_pstyle134" -1 209 1 {CSTYLE 
"" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 0 0 2 0 2 0
 2 2 -1 1 }{PSTYLE "Heading 1" -1 3 1 {CSTYLE "" -1 -1 "Times" 1 18 0 
0 0 1 2 1 2 2 2 2 1 0 0 1 }1 1 0 0 8 4 2 0 2 0 2 2 -1 1 }{PSTYLE "Bull
et Item" -1 15 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0
 0 1 }1 1 0 0 3 3 2 0 2 0 2 2 -1 1 }{PSTYLE "Heading 4" -1 20 1 
{CSTYLE "" -1 -1 "Times" 1 10 0 0 0 1 1 1 2 2 2 2 1 0 0 1 }1 1 0 0 0 0
 2 0 2 0 2 2 -1 1 }{PSTYLE "Heading 3" -1 5 1 {CSTYLE "" -1 -1 "Times"
 1 12 0 0 0 1 1 1 2 2 2 2 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }
{PSTYLE "Heading 2" -1 4 1 {CSTYLE "" -1 -1 "Times" 1 14 0 0 0 1 2 1 2
 2 2 2 1 0 0 1 }1 1 0 0 8 2 2 0 2 0 2 2 -1 1 }{PSTYLE "HyperlinkWarnin
g" -1 210 1 {CSTYLE "" -1 -1 "Courier" 1 12 0 0 255 1 2 2 1 2 2 1 1 0 
0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Left Justified Maple Outpu
t" -1 12 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }
1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "List Item" -1 14 1 {CSTYLE "" 
-1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 3 3 2 0 2 0 2 
2 -1 1 }{CSTYLE "Annotation Text" -1 200 "Times" 1 12 0 0 0 1 2 2 2 2 
2 2 0 0 0 1 }{CSTYLE "Help Maple Name" -1 35 "Times" 1 12 104 64 92 1 
2 1 2 2 2 2 0 0 0 1 }{CSTYLE "2D Math Bold" -1 5 "Times" 1 12 0 0 0 1 
2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Help Menus" -1 36 "Times" 1 12 0 0 0 1 2
 1 2 2 2 2 0 0 0 1 }{CSTYLE "2D Math Italic" -1 3 "Times" 1 12 0 0 0 1
 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "Help Normal" -1 30 "Times" 1 12 0 0 0 1
 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Plot Text" -1 28 "Times" 1 8 0 0 0 1 2 
2 2 2 2 2 0 0 0 1 }{CSTYLE "Help Nonterminal" -1 24 "Courier" 1 12 0 0
 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Help Heading" -1 26 "Times" 1 14 0 
0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Help Italic" -1 42 "Times" 1 12 0 
0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "Help Variable" -1 25 "Courier" 1 
12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Help Italic Bold" -1 40 "Time
s" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "Default" -1 38 "Times" 1
 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Help Underlined Italic" -1 
43 "Times" 1 12 0 0 0 1 1 2 1 2 2 2 0 0 0 1 }{CSTYLE "_cstyle69" -1 
201 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 0 0 0 1 }{CSTYLE "Maple Input
" -1 0 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 0 0 0 1 }{CSTYLE "2D Outpu
t" -1 20 "Times" 1 12 0 0 255 1 2 2 2 2 2 1 0 0 0 1 }{CSTYLE "2D Math \+
Bold Small" -1 10 "Times" 1 1 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "2D
 Math Small" -1 7 "Times" 1 1 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Pa
ge Number" -1 33 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Ou
tput Labels" -1 29 "Times" 1 8 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "P
lot Title" -1 27 "Times" 1 10 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "He
lp Emphasized" -1 22 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE
 "_cstyle67" -1 202 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 0 0 0 1 }
{CSTYLE "_cstyle66" -1 203 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 0 0 0 
1 }{CSTYLE "2D Math Symbol 2" -1 16 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0
 0 0 1 }{CSTYLE "Maple Comment" -1 21 "Courier" 1 12 0 0 0 1 2 1 2 2 2
 2 0 0 0 1 }{CSTYLE "Maple Input Placeholder" -1 204 "Courier" 1 12 
200 0 200 1 2 1 2 2 1 2 0 0 0 1 }{CSTYLE "Code" -1 205 "Courier" 1 12 
255 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "2D Inert Output" -1 206 "Times
" 1 12 144 144 144 1 2 2 2 2 1 2 0 0 0 1 }{CSTYLE "2D Math Italic Smal
l" -1 207 "Times" 1 1 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "2D Comment
" -1 18 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Help Underl
ined Bold" -1 41 "Times" 1 12 0 0 0 1 1 1 2 2 2 2 0 0 0 1 }{CSTYLE "Co
pyright" -1 34 "Times" 1 10 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Hype
rlink" -1 17 "Times" 1 12 0 128 128 1 2 2 1 2 2 2 0 0 0 1 }{CSTYLE "He
lp Underlined" -1 44 "Times" 1 12 0 0 0 1 2 2 1 2 2 2 0 0 0 1 }{CSTYLE
 "Prompt" -1 1 "Courier" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "2D
 Math" -1 2 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "2D Inpu
t" -1 19 "Times" 1 12 255 0 0 1 2 2 2 2 1 2 0 0 0 1 }{CSTYLE "Header a
nd Footer" -1 208 "Times" 1 10 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "T
ext" -1 209 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Help No
tes" -1 37 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Help Bol
d" -1 39 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Equation L
abel" -1 210 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "LaTeX"
 -1 32 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Popup" -1 31
 "Times" 1 12 0 128 128 1 1 2 1 2 2 2 0 0 0 1 }{CSTYLE "Dictionary Hyp
erlink" -1 45 "Times" 1 12 147 0 15 1 2 2 1 2 2 2 0 0 0 1 }{CSTYLE "He
lp Fixed" -1 23 "Courier" 1 10 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }}
{SECT 0 {EXCHG {PARA 209 "> " 0 "" {MPLTEXT 1 203 2 "#\n" }{MPLTEXT 
1 203 57 "# This is the source code file of the \"SchurFkt\" package\n
" }{MPLTEXT 1 203 80 "# SchurFkt Version 1.0.4 (2 xi 2009) file SchurF
kt-code-ver.1.0.4-2xi09_M10.mws\n" }{MPLTEXT 1 203 22 "# date:   Nov 2
, 2009\n" }{MPLTEXT 1 203 2 "#\n" }{MPLTEXT 1 203 53 "# copyright (c) \+
Bertfried Fauser, & Rafal Ablamowicz\n" }{MPLTEXT 1 203 63 "#         \+
      June 2003-September 2009, all rights reserved.\n" }{MPLTEXT 1 
203 2 "#\n" }{MPLTEXT 1 203 78 "######################################
#######################################\n" }{MPLTEXT 1 203 78 "#      \+
                                                                     #
\n" }{MPLTEXT 1 203 78 "#  DISCLAIMER:                                \+
                              #\n" }{MPLTEXT 1 203 78 "#              \+
                                                             #\n" }
{MPLTEXT 1 203 78 "#  THERE IS NO WARRANTY FOR THE SCHURFKT PACKAGE TO
 THE EXTENT PERMITTED    #\n" }{MPLTEXT 1 203 78 "#  BY APPLICABLE LAW
. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT #\n" }{MPLTEXT
 1 203 78 "#  HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS
\" WITHOUT         #\n" }{MPLTEXT 1 203 78 "#  WARRANTY OF ANY KIND, E
ITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT    #\n" }{MPLTEXT 1 
203 78 "#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND F
ITNESS FOR    #\n" }{MPLTEXT 1 203 78 "#  A PARTICULAR PURPOSE. THE EN
TIRE RISK AS TO THE QUALITY AND PERFORMANCE  #\n" }{MPLTEXT 1 203 78 "
#  OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU
      #\n" }{MPLTEXT 1 203 78 "#  ASSUME THE COST OF ALL NECESSARY SER
VICING, REPAIR OR CORRECTION.        #\n" }{MPLTEXT 1 203 78 "#       \+
                                                                    #
\n" }{MPLTEXT 1 203 78 "##############################################
###############################\n" }{MPLTEXT 1 203 2 "#\n" }{MPLTEXT 
1 203 75 "#  If you want to use this code or parts of it under a GPL L
ICENCE, please\n" }{MPLTEXT 1 203 24 "#  contact the authors:\n" }
{MPLTEXT 1 203 51 "#  rablamowicz <at> tntech.edu                 or \+
\n" }{MPLTEXT 1 203 41 "#  Bertfried.Fauser <at> uni-konstanz.de\n" }
{MPLTEXT 1 203 2 "#\n" }{MPLTEXT 1 203 2 "#\n" }{MPLTEXT 1 203 76 "# +
++ The package computes some products and coproducts for Schur functio
ns\n" }{MPLTEXT 1 203 7 "# --- \n" }{MPLTEXT 1 203 59 "# --- Remember:
 elementary symmetric functions are s[1^r] \n" }{MPLTEXT 1 203 54 "# -
--           complete symmetric functions are s[r]\n" }{MPLTEXT 1 203 
33 "# ---           m[r] equals p[r]\n" }{MPLTEXT 1 203 49 "# ---     \+
      m[1,...,1] equals e[r]  (r-ones)\n" }{MPLTEXT 1 203 2 "#\n" }
{MPLTEXT 1 203 26 "# +++ Main functions are:\n" }{MPLTEXT 1 203 79 "# \+
--- outer      : the outer product of Schur functions outer(s[3,2],s[1
],...)\n" }{MPLTEXT 1 203 81 "# --- inner      : the inner product of \+
Schur functions inner(s[2,2],s[3,1],...)\n" }{MPLTEXT 1 203 87 "# --- \+
skew       : the (outer) skew product of two Schur functions skew(s[3,
2,1],s[2])\n" }{MPLTEXT 1 203 74 "# --- couter     : the outer coprodu
ct of a Schur function couter(s[4,2])\n" }{MPLTEXT 1 203 76 "# --- cin
ner     : the inner coproduct of a Schur function cinner(s[4,2,2])\n" 
}{MPLTEXT 1 203 96 "# --- antipS     : the antipode of a Schur functio
n AntipS(s[lambda])= (-1)^|lambda|*s[lambda']\n" }{MPLTEXT 1 203 52 "#
                  w.r.t. the outer(!) Hopf algebra\n" }{MPLTEXT 1 203 
88 "# --- plethS     : the plethysm of two Schur function polynomials \+
over a ring extension\n" }{MPLTEXT 1 203 63 "#                  i.e. o
ne can compute plethysms of the form \n" }{MPLTEXT 1 203 53 "#        \+
          plethS(a*s[3]+s[1],q*s[2,1]+s[2])\n" }{MPLTEXT 1 203 2 "#\n"
 }{MPLTEXT 1 203 56 "# --- KostkaTable: computes the Kostka matrix of \+
rank n\n" }{MPLTEXT 1 203 86 "# --- isLattice  : returns true is a You
ng tableau filled with letters (0) 1..n is a \n" }{MPLTEXT 1 203 39 "#
                  lattice permutation\n" }{MPLTEXT 1 203 91 "#        \+
          the tableau has to be given as [[row1 list ,...],[row2 list,
 ...],...] \n" }{MPLTEXT 1 203 41 "#                  (mainly internal
 use)\n" }{MPLTEXT 1 203 2 "#\n" }{MPLTEXT 1 203 13 "# +++ TYPES:\n" }
{MPLTEXT 1 203 83 "#           Are exposed globally to Maple via the i
nit routine of the package, any\n" }{MPLTEXT 1 203 83 "#           new
 basis requires an own type. Later versions of Schur may allow the \n"
 }{MPLTEXT 1 203 38 "#           user to create own types!\n" }
{MPLTEXT 1 203 2 "#\n" }{MPLTEXT 1 203 53 "# --- s-functions come in m
onoms, terms and polynoms\n" }{MPLTEXT 1 203 53 "# --- m-functions com
e in monoms, terms and polynoms\n" }{MPLTEXT 1 203 53 "# --- p-functio
ns come in monoms, terms and polynoms\n" }{MPLTEXT 1 203 53 "# --- e-f
unctions come in monoms, terms and polynoms\n" }{MPLTEXT 1 203 53 "# -
-- h-functions come in monoms, terms and polynoms\n" }{MPLTEXT 1 203 
53 "# --- f-functions come in monoms, terms and polynoms\n" }{MPLTEXT 
1 203 3 "# \n" }{MPLTEXT 1 203 93 "#     There is a need to introduce \+
orthogonal and symplectic Schur functions and other bases\n" }{MPLTEXT
 1 203 93 "#     currently these are dealt with using the _same_ names
 but _different_ algebraic maps!!\n" }{MPLTEXT 1 203 2 "#\n" }{MPLTEXT
 1 203 95 "# ===> some symmetric function bases and or operations in s
everal bases are not yet available \n" }{MPLTEXT 1 203 1 "#" }}{PARA 
208 "> " 0 "" {MPLTEXT 1 0 9 "restart:\n" }{MPLTEXT 1 202 19 "SchurFkt
:=module()\n" }{MPLTEXT 1 202 21 "   export MLIN,FLAT,\n" }{MPLTEXT 1 
202 44 "          fallingFactorial,risingFactorial,\n" }{MPLTEXT 1 
202 59 "          lehmerCodeToPermutation,permutationToLehmerCode,\n" 
}{MPLTEXT 1 202 69 "          lehmerCodeToSchurFkt,schurToLehmerCode,s
churToLehmerCode1,\n" }{MPLTEXT 1 202 28 "          skewToLehmerCode,
\n" }{MPLTEXT 1 202 22 "          transition,\n" }{MPLTEXT 1 202 20 " \+
         Descents,\n" }{MPLTEXT 1 202 21 "          isLattice,\n" }
{MPLTEXT 1 202 71 "          concatM,LaplaceM,LaplaceM2,LP_mon,Laplace
M_mon,LaplaceTable,\n" }{MPLTEXT 1 202 60 "          outer,outerLS,out
erS,outerM,outerH,outerE,outerP,\n" }{MPLTEXT 1 202 30 "          skew
,skewLR,skewLS,\n" }{MPLTEXT 1 202 50 "          couter,couterM,couter
H,couterE,couterP,\n" }{MPLTEXT 1 202 54 "          antipS,antipP,anti
pH,antipE,antipM,antipMC,\n" }{MPLTEXT 1 202 32 "          KostkaTable
,KostkaPC,\n" }{MPLTEXT 1 202 44 "          Scalar,ScalarP,ScalarMH,Sc
alarHM,\n" }{MPLTEXT 1 202 67 "          AlexComp,grAlexComp,PartNM,pa
rtitionsInShape,CompNM,zee,\n" }{MPLTEXT 1 202 62 "          truncWT,t
runcLEN,truncPART,collect_sfkt,sfkt_terms,\n" }{MPLTEXT 1 202 81 "    \+
      part2mset,mset2part,conjpart,cmp2prtMult,cmp2part,Frob2part,part
2Frob,\n" }{MPLTEXT 1 202 44 "          MurNak,MurNak2,CharHook,sq_coe
ff,\n" }{MPLTEXT 1 202 45 "          dimSN,dimSNP,dimSNM,dimSNH,dimSNE
,\n" }{MPLTEXT 1 202 45 "          dimGL,dimGLP,dimGLM,dimGLH,dimGLE,
\n" }{MPLTEXT 1 202 37 "          GesselThetaP,GesselThetaS,\n" }
{MPLTEXT 1 202 38 "          inner,innerP,innerH,innerM,\n" }{MPLTEXT 
1 202 52 "          cinner,counitInnerS,cinnerP,counitInnerP,\n" }
{MPLTEXT 1 202 17 "          cdiag,\n" }{MPLTEXT 1 202 61 "          p
lethP,cplethP,plethSAxNB,plethS,plethSnm,cplethS,\n" }{MPLTEXT 1 202 
25 "          p_to_m,p_to_s,\n" }{MPLTEXT 1 202 49 "          m_to_p,m
_to_pMat,m_to_e,m_to_h,m_to_s,\n" }{MPLTEXT 1 202 75 "          s_to_p
,s_to_x,s_to_h,s_to_hMat,s_to_hJT,s_to_e,s_to_hmat,s_to_m,\n" }
{MPLTEXT 1 202 32 "          h_to_s,h_to_m,h_to_p,\n" }{MPLTEXT 1 202 
32 "          e_to_h,e_to_s,e_to_m,\n" }{MPLTEXT 1 202 18 "          x
_to_s,\n" }{MPLTEXT 1 202 49 "          evalJacobiTrudiMatrix,maxlengt
hSymFkt,\n" }{MPLTEXT 1 202 49 "          outerON,couterON,getSfktSeri
es,branch;\n" }{MPLTEXT 1 202 45 "   global `type/cliscalar`, `type/my
domain`,\n" }{MPLTEXT 1 202 65 "          `type/hfktmonom`, `type/hfkt
term`, `type/hfktpolynom`,\n" }{MPLTEXT 1 202 65 "          `type/efkt
monom`, `type/efktterm`, `type/efktpolynom`,\n" }{MPLTEXT 1 202 65 "  \+
        `type/sfktmonom`, `type/sfktterm`, `type/sfktpolynom`,\n" }
{MPLTEXT 1 202 65 "          `type/pfktmonom`, `type/pfktterm`, `type/
pfktpolynom`,\n" }{MPLTEXT 1 202 65 "          `type/ffktmonom`, `type
/ffktterm`, `type/ffktpolynom`,\n" }{MPLTEXT 1 202 65 "          `type
/mfktmonom`, `type/mfktterm`, `type/mfktpolynom`,\n" }{MPLTEXT 1 202 
71 "          `type/symfktmonom`, `type/symfktterm`, `type/symfktpolyn
om`;\n" }{MPLTEXT 1 202 71 "   local init,exit,ADD,LRR,getPart,makeRim
Rep,removeRimHook,MurNakRim,\n" }{MPLTEXT 1 202 32 "         partition
sInShape_gen,\n" }{MPLTEXT 1 202 41 "         dimSN_mon,dimGL_mon,dimG
LP_mon,\n" }{MPLTEXT 1 202 67 "         LaplaceMset,couterMproper1n,LP
_l1,concatM_mon,concat_mon,\n" }{MPLTEXT 1 202 65 "         inner_mon,
cinner_mon,innerP_mon,cinnerP_mon,innerH_mon,\n" }{MPLTEXT 1 202 69 " \+
        couter_mon,couterM_mon,couterH_mon,couterE_mon,couterP_mon,\n"
 }{MPLTEXT 1 202 65 "         antipS_mon,antipP_mon,antipH_mon,antipE_
mon,antipM_mon,\n" }{MPLTEXT 1 202 26 "         p_to_mM,m_to_pM,\n" }
{MPLTEXT 1 202 71 "         list_divisors,truncLEN_mon,GesselThetaP_mo
n,GesselThetaS_mon,\n" }{MPLTEXT 1 202 24 "         plethPsingleP,\n" 
}{MPLTEXT 1 202 18 "         x_to_sM,\n" }{MPLTEXT 1 202 34 "         \+
s_to_xM,s_to_hM,s_to_mM,\n" }{MPLTEXT 1 202 34 "         h_to_sM,h_to_
mM,h_to_pM,\n" }{MPLTEXT 1 202 26 "         m_to_hM,m_to_sM,\n" }
{MPLTEXT 1 202 39 "         etoh,e_to_hM,e_to_sM,e_to_mM,\n" }{MPLTEXT
 1 202 60 "         plethP_mon,plethsp,plethSP,plethS_mon,cplethS_mon,
\n" }{MPLTEXT 1 202 29 "         sfktmon_to_hmatrix,\n" }{MPLTEXT 1 
202 54 "         outerON_monom,couterON_monom,branch_monom;  \n" }
{MPLTEXT 1 202 19 "   option package,\n" }{MPLTEXT 1 202 21 "         \+
 load=init,\n" }{MPLTEXT 1 202 23 "          unload=exit;\n" }{MPLTEXT
 1 202 82 "###########################################################
######################\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 75 "
#  init exposes several types in the global name space, it greets the \+
user\n" }{MPLTEXT 1 202 44 "#       and initialized the tensor product
.\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 13 "init:=proc()\n" }
{MPLTEXT 1 202 16 "  global FIELD;\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 127 "pr
intf(\"SchurFkt Version 1.0.4 (2 xi 2009) at your service\\n(c) 2003-2
009 BF&RA, no warranty, no fitness for anything!\\n\",%s);\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 80 "# set the global variable F
IELD to specify the ground field of the ring /\\ and \n" }{MPLTEXT 1 
202 60 "#     sepcify the linearity of the tensor product &t in use\n"
 }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 80 "# overwirte a possibly se
t type cliscalar, which is to radical in its linearity\n" }{MPLTEXT 1 
202 28 "  `type/cliscalar`:=proc(x)\n" }{MPLTEXT 1 202 29 "         ty
pe(x,'rational');\n" }{MPLTEXT 1 202 12 "  end proc:\n" }{MPLTEXT 1 
202 2 "#\n" }{MPLTEXT 1 202 42 "  FIELD := radalgfun(rational,[q,t,u,v
]);\n" }{MPLTEXT 1 202 28 "  `type/mydomain`:=proc(x) \n" }{MPLTEXT 1 
202 48 "         type(x,radalgfun(rational,[q,t,u,v]));\n" }{MPLTEXT 
1 202 12 "  end proc:\n" }{MPLTEXT 1 202 48 "  if assigned(`&t`) then \+
unassign(`&t`) end if;\n" }{MPLTEXT 1 202 51 "  define(`&t`,multilinea
r,flat,domain='mydomain');\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 
52 "# type:   SYM-Fkt (general symmetric function type)\n" }{MPLTEXT 
1 202 2 "#\n" }{MPLTEXT 1 202 30 "  `type/symfktmonom`:=proc(a)\n" }
{MPLTEXT 1 202 89 "     option `Copyright (c) B. Fauser & R. Ablamowic
z 2004-2009. All rights reserved.`;  \n" }{MPLTEXT 1 202 36 "     memb
er(op(0,a),\{s,p,h,m,e,f\});\n" }{MPLTEXT 1 202 12 "  end proc:\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 29 "  `type/symfktterm`:=proc(a
)\n" }{MPLTEXT 1 202 89 "     option `Copyright (c) B. Fauser & R. Abl
amowicz 2004-2009. All rights reserved.`;  \n" }{MPLTEXT 1 202 52 "   \+
  if type(a,`symfktmonom`) then return true fi; \n" }{MPLTEXT 1 202 
61 "     if type(a,`*`) and 1<>select(type,a,`symfktmonom`) then\n" }
{MPLTEXT 1 202 13 "       true;\n" }{MPLTEXT 1 202 10 "     else\n" }
{MPLTEXT 1 202 15 "       false; \n" }{MPLTEXT 1 202 9 "     fi;\n" }
{MPLTEXT 1 202 12 "  end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 33 "  `type/symfktpolynom`:=proc(a) \n" }{MPLTEXT 1 202 89 "     o
ption `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights r
eserved.`;  \n" }{MPLTEXT 1 202 50 "     if type(a,`symfktterm`) then \+
return true fi:\n" }{MPLTEXT 1 202 26 "     if type(a,`+`) then \n" }
{MPLTEXT 1 202 57 "       return evalb(map(type,\{op(a)\},symfktterm)=
\{true\})\n" }{MPLTEXT 1 202 10 "     else\n" }{MPLTEXT 1 202 21 "    \+
   return false;\n" }{MPLTEXT 1 202 8 "     fi\n" }{MPLTEXT 1 202 12 "
  end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 36 "# type:   S
-Fkt\{monom,term,polynom\}\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 
28 "  `type/sfktmonom`:=proc(a)\n" }{MPLTEXT 1 202 89 "     option `Co
pyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`
;  \n" }{MPLTEXT 1 202 25 "     evalb(`s`=op(0,a));\n" }{MPLTEXT 1 
202 12 "  end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 27 "  `
type/sfktterm`:=proc(a)\n" }{MPLTEXT 1 202 89 "     option `Copyright \+
(c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;  \n" }
{MPLTEXT 1 202 50 "     if type(a,`sfktmonom`) then return true fi; \n
" }{MPLTEXT 1 202 59 "     if type(a,`*`) and 1<>select(type,a,`sfktmo
nom`) then\n" }{MPLTEXT 1 202 13 "       true;\n" }{MPLTEXT 1 202 10 "
     else\n" }{MPLTEXT 1 202 15 "       false; \n" }{MPLTEXT 1 202 9 "
     fi;\n" }{MPLTEXT 1 202 12 "  end proc:\n" }{MPLTEXT 1 202 2 "#\n"
 }{MPLTEXT 1 202 31 "  `type/sfktpolynom`:=proc(a) \n" }{MPLTEXT 1 
202 89 "     option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009
. All rights reserved.`;  \n" }{MPLTEXT 1 202 48 "     if type(a,`sfkt
term`) then return true fi:\n" }{MPLTEXT 1 202 26 "     if type(a,`+`)
 then \n" }{MPLTEXT 1 202 55 "       return evalb(map(type,\{op(a)\},s
fktterm)=\{true\})\n" }{MPLTEXT 1 202 10 "     else\n" }{MPLTEXT 1 
202 21 "       return false;\n" }{MPLTEXT 1 202 8 "     fi\n" }
{MPLTEXT 1 202 12 "  end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 36 "# type:   p-Fkt\{monom,term,polynom\}\n" }{MPLTEXT 1 202 2 "#
\n" }{MPLTEXT 1 202 28 "  `type/pfktmonom`:=proc(a)\n" }{MPLTEXT 1 
202 89 "     option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009
. All rights reserved.`;  \n" }{MPLTEXT 1 202 25 "     evalb(`p`=op(0,
a));\n" }{MPLTEXT 1 202 12 "  end proc:\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 27 "  `type/pfktterm`:=proc(a)\n" }{MPLTEXT 1 202 89 " \+
    option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rig
hts reserved.`;  \n" }{MPLTEXT 1 202 50 "     if type(a,`pfktmonom`) t
hen return true fi; \n" }{MPLTEXT 1 202 59 "     if type(a,`*`) and 1<
>select(type,a,`pfktmonom`) then\n" }{MPLTEXT 1 202 13 "       true;\n
" }{MPLTEXT 1 202 10 "     else\n" }{MPLTEXT 1 202 15 "       false; \+
\n" }{MPLTEXT 1 202 9 "     fi;\n" }{MPLTEXT 1 202 12 "  end proc:\n" 
}{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 31 "  `type/pfktpolynom`:=proc
(a) \n" }{MPLTEXT 1 202 89 "     option `Copyright (c) B. Fauser & R. \+
Ablamowicz 2004-2009. All rights reserved.`;  \n" }{MPLTEXT 1 202 48 "
     if type(a,`pfktterm`) then return true fi:\n" }{MPLTEXT 1 202 26 
"     if type(a,`+`) then \n" }{MPLTEXT 1 202 55 "       return evalb(
map(type,\{op(a)\},pfktterm)=\{true\})\n" }{MPLTEXT 1 202 10 "     els
e\n" }{MPLTEXT 1 202 21 "       return false;\n" }{MPLTEXT 1 202 8 "  \+
   fi\n" }{MPLTEXT 1 202 12 "  end proc:\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 36 "# type:   m-Fkt\{monom,term,polynom\}\n" }{MPLTEXT 
1 202 2 "#\n" }{MPLTEXT 1 202 28 "  `type/mfktmonom`:=proc(a)\n" }
{MPLTEXT 1 202 89 "     option `Copyright (c) B. Fauser & R. Ablamowic
z 2004-2009. All rights reserved.`;  \n" }{MPLTEXT 1 202 25 "     eval
b(`m`=op(0,a));\n" }{MPLTEXT 1 202 12 "  end proc:\n" }{MPLTEXT 1 202 
2 "#\n" }{MPLTEXT 1 202 27 "  `type/mfktterm`:=proc(a)\n" }{MPLTEXT 1 
202 89 "     option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009
. All rights reserved.`;  \n" }{MPLTEXT 1 202 50 "     if type(a,`mfkt
monom`) then return true fi; \n" }{MPLTEXT 1 202 59 "     if type(a,`*
`) and 1<>select(type,a,`mfktmonom`) then\n" }{MPLTEXT 1 202 13 "     \+
  true;\n" }{MPLTEXT 1 202 10 "     else\n" }{MPLTEXT 1 202 15 "      \+
 false; \n" }{MPLTEXT 1 202 9 "     fi;\n" }{MPLTEXT 1 202 12 "  end p
roc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 31 "  `type/mfktpolyno
m`:=proc(a) \n" }{MPLTEXT 1 202 89 "     option `Copyright (c) B. Faus
er & R. Ablamowicz 2004-2009. All rights reserved.`;  \n" }{MPLTEXT 1 
202 48 "     if type(a,`mfktterm`) then return true fi:\n" }{MPLTEXT 
1 202 26 "     if type(a,`+`) then \n" }{MPLTEXT 1 202 55 "       retu
rn evalb(map(type,\{op(a)\},mfktterm)=\{true\})\n" }{MPLTEXT 1 202 10 
"     else\n" }{MPLTEXT 1 202 21 "       return false;\n" }{MPLTEXT 1 
202 8 "     fi\n" }{MPLTEXT 1 202 12 "  end proc:\n" }{MPLTEXT 1 202 
2 "#\n" }{MPLTEXT 1 202 36 "# type:   h-Fkt\{monom,term,polynom\}\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 28 "  `type/hfktmonom`:=proc(a)
\n" }{MPLTEXT 1 202 89 "     option `Copyright (c) B. Fauser & R. Abla
mowicz 2004-2009. All rights reserved.`;  \n" }{MPLTEXT 1 202 25 "    \+
 evalb(`h`=op(0,a));\n" }{MPLTEXT 1 202 12 "  end proc:\n" }{MPLTEXT 
1 202 2 "#\n" }{MPLTEXT 1 202 27 "  `type/hfktterm`:=proc(a)\n" }
{MPLTEXT 1 202 89 "     option `Copyright (c) B. Fauser & R. Ablamowic
z 2004-2009. All rights reserved.`;  \n" }{MPLTEXT 1 202 50 "     if t
ype(a,`hfktmonom`) then return true fi; \n" }{MPLTEXT 1 202 59 "     i
f type(a,`*`) and 1<>select(type,a,`hfktmonom`) then\n" }{MPLTEXT 1 
202 13 "       true;\n" }{MPLTEXT 1 202 10 "     else\n" }{MPLTEXT 1 
202 15 "       false; \n" }{MPLTEXT 1 202 9 "     fi;\n" }{MPLTEXT 1 
202 12 "  end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 31 "  `
type/hfktpolynom`:=proc(a) \n" }{MPLTEXT 1 202 89 "     option `Copyri
ght (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;  \+
\n" }{MPLTEXT 1 202 48 "     if type(a,`hfktterm`) then return true fi
:\n" }{MPLTEXT 1 202 26 "     if type(a,`+`) then \n" }{MPLTEXT 1 202 
55 "       return evalb(map(type,\{op(a)\},hfktterm)=\{true\})\n" }
{MPLTEXT 1 202 10 "     else\n" }{MPLTEXT 1 202 21 "       return fals
e;\n" }{MPLTEXT 1 202 8 "     fi\n" }{MPLTEXT 1 202 12 "  end proc:\n"
 }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 36 "# type:   e-Fkt\{monom,te
rm,polynom\}\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 28 "  `type/ef
ktmonom`:=proc(a)\n" }{MPLTEXT 1 202 89 "     option `Copyright (c) B.
 Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;  \n" }
{MPLTEXT 1 202 25 "     evalb(`e`=op(0,a));\n" }{MPLTEXT 1 202 12 "  e
nd proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 27 "  `type/efktte
rm`:=proc(a)\n" }{MPLTEXT 1 202 89 "     option `Copyright (c) B. Faus
er & R. Ablamowicz 2004-2009. All rights reserved.`;  \n" }{MPLTEXT 1 
202 50 "     if type(a,`efktmonom`) then return true fi; \n" }{MPLTEXT
 1 202 59 "     if type(a,`*`) and 1<>select(type,a,`efktmonom`) then
\n" }{MPLTEXT 1 202 13 "       true;\n" }{MPLTEXT 1 202 10 "     else
\n" }{MPLTEXT 1 202 15 "       false; \n" }{MPLTEXT 1 202 9 "     fi;
\n" }{MPLTEXT 1 202 12 "  end proc:\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 31 "  `type/efktpolynom`:=proc(a) \n" }{MPLTEXT 1 202 
89 "     option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. Al
l rights reserved.`;  \n" }{MPLTEXT 1 202 48 "     if type(a,`efktterm
`) then return true fi:\n" }{MPLTEXT 1 202 26 "     if type(a,`+`) the
n \n" }{MPLTEXT 1 202 55 "       return evalb(map(type,\{op(a)\},efktt
erm)=\{true\})\n" }{MPLTEXT 1 202 10 "     else\n" }{MPLTEXT 1 202 21 
"       return false;\n" }{MPLTEXT 1 202 8 "     fi\n" }{MPLTEXT 1 
202 12 "  end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n"
 }{MPLTEXT 1 202 36 "# type:   f-Fkt\{monom,term,polynom\}\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 28 "  `type/ffktmonom`:=proc(a)
\n" }{MPLTEXT 1 202 89 "     option `Copyright (c) B. Fauser & R. Abla
mowicz 2004-2009. All rights reserved.`;  \n" }{MPLTEXT 1 202 25 "    \+
 evalb(`f`=op(0,a));\n" }{MPLTEXT 1 202 12 "  end proc:\n" }{MPLTEXT 
1 202 2 "#\n" }{MPLTEXT 1 202 27 "  `type/ffktterm`:=proc(a)\n" }
{MPLTEXT 1 202 89 "     option `Copyright (c) B. Fauser & R. Ablamowic
z 2004-2009. All rights reserved.`;  \n" }{MPLTEXT 1 202 50 "     if t
ype(a,`ffktmonom`) then return true fi; \n" }{MPLTEXT 1 202 59 "     i
f type(a,`*`) and 1<>select(type,a,`ffktmonom`) then\n" }{MPLTEXT 1 
202 13 "       true;\n" }{MPLTEXT 1 202 10 "     else\n" }{MPLTEXT 1 
202 15 "       false; \n" }{MPLTEXT 1 202 9 "     fi;\n" }{MPLTEXT 1 
202 12 "  end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 31 "  `
type/ffktpolynom`:=proc(a) \n" }{MPLTEXT 1 202 89 "     option `Copyri
ght (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;  \+
\n" }{MPLTEXT 1 202 48 "     if type(a,`ffktterm`) then return true fi
:\n" }{MPLTEXT 1 202 26 "     if type(a,`+`) then \n" }{MPLTEXT 1 202 
55 "       return evalb(map(type,\{op(a)\},ffktterm)=\{true\})\n" }
{MPLTEXT 1 202 10 "     else\n" }{MPLTEXT 1 202 21 "       return fals
e;\n" }{MPLTEXT 1 202 8 "     fi\n" }{MPLTEXT 1 202 12 "  end proc:\n"
 }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 76 "# -- we protect the labes
l for the various Schur function bases, so that no\n" }{MPLTEXT 1 202 
26 "# -- mischieve can happen\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 38 "# protect the names of basis elements\n" }{MPLTEXT 1 202 36 " \+
 protect('h','m','e','f','s','p');\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 18 "end proc: # init \n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n"
 }{MPLTEXT 1 202 13 "exit:=proc()\n" }{MPLTEXT 1 202 86 "  option `Cop
yright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;
  \n" }{MPLTEXT 1 202 60 "  printf(\"SchurFkt Version 1.0.4 says 'Good
 bye...'\\n\",%s);\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 
202 83 "##############################################################
####################\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 70 "# \+
Actual package starts here with some helper and internal functions \n"
 }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 83 "#########################
#########################################################\n" }{MPLTEXT
 1 202 83 "###########################################################
#######################\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 19 
"# Helper functions\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 83 "###
######################################################################
#########\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 86 "# MLIN is a f
unction which allows to make a procedure multilinear w.r.t. the intege
rs\n" }{MPLTEXT 1 202 66 "#      or any ground field specified in the \+
global variable FIELD\n" }{MPLTEXT 1 202 28 "#      Mostly internal us
e!\n" }{MPLTEXT 1 202 78 "# +++ (warning may be replaced in future rel
eases, don't use it in own code!)\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT
 1 202 13 "MLIN:=proc()\n" }{MPLTEXT 1 202 86 "  option `Copyright (c)
 B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;  \n" }
{MPLTEXT 1 202 23 "  local i,P,pt,res,sg;\n" }{MPLTEXT 1 202 27 "  for
 i from 1 to nargs do\n" }{MPLTEXT 1 202 21 "    lst||i:=args[i];\n" }
{MPLTEXT 1 202 80 "    if type(lst||i,`+`) then lst||i:=[op(lst||i)] e
lse lst||i:=[lst||i] end if;\n" }{MPLTEXT 1 202 10 "  end do:\n" }
{MPLTEXT 1 202 14 "  sg:=proc(x)\n" }{MPLTEXT 1 202 17 "    local cf,t
m;\n" }{MPLTEXT 1 202 33 "    if type(x,symfktmonom) then \n" }
{MPLTEXT 1 202 16 "      return 1 \n" }{MPLTEXT 1 202 34 "    elif typ
e(x,symfktterm) then \n" }{MPLTEXT 1 202 47 "      tm,cf:=selectremove
(type,x,symfktmonom);\n" }{MPLTEXT 1 202 18 "      return cf; \n" }
{MPLTEXT 1 202 10 "    else \n" }{MPLTEXT 1 202 39 "      error \"this
 should not happen\"; \n" }{MPLTEXT 1 202 13 "    end if; \n" }
{MPLTEXT 1 202 12 "  end proc:\n" }{MPLTEXT 1 202 10 "  res:=0:\n" }
{MPLTEXT 1 202 51 "  P:=combinat[cartprod]([seq(lst||i,i=1..nargs)]):
\n" }{MPLTEXT 1 202 28 "  while not P[finished] do \n" }{MPLTEXT 1 
202 24 "    pt:=P[nextvalue]();\n" }{MPLTEXT 1 202 82 "    res:=res+mu
l(sg(pt[i]),i=1..nops(pt))*_T(seq(pt[i]/sg(pt[i]),i=1..nops(pt)));\n" 
}{MPLTEXT 1 202 10 "  end do;\n" }{MPLTEXT 1 202 29 "  eval(subs(_T=`&
t`, res ));\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n
" }{MPLTEXT 1 202 76 "# FLAT is a function which allows to impose the \+
associativity of functions \n" }{MPLTEXT 1 202 49 "#      (flaten expr
essions) Mostly internal use.\n" }{MPLTEXT 1 202 79 "# +++  (warning m
ay be replaced in future releases, don't use it in own code!)\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 13 "FLAT:=proc()\n" }{MPLTEXT 
1 202 86 "  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009.
 All rights reserved.`;  \n" }{MPLTEXT 1 202 27 "  local x,lst,drp,cf,
term;\n" }{MPLTEXT 1 202 30 "  x:=eval(subs(T=MLIN,args));\n" }
{MPLTEXT 1 202 29 "  drp:=proc() args end proc:\n" }{MPLTEXT 1 202 23 
"  if type(x,`+`) then \n" }{MPLTEXT 1 202 46 "    return eval(subs(T=
MLIN,map(procname,x)))\n" }{MPLTEXT 1 202 25 "  elif type(x,`*`) then \+
\n" }{MPLTEXT 1 202 45 "    cf,term:=selectremove(type,x,'integer');\n
" }{MPLTEXT 1 202 60 "    return cf*eval(subs(T=MLIN,T(eval(subs(T=drp
,term)))));\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 54 "    re
turn eval(subs(T=MLIN,T(eval(subs(T=drp,x)))));\n" }{MPLTEXT 1 202 10 
"  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 81 "###
######################################################################
#######\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 84 "# fallingFactor
ial is the polynomial Pochhammer symbol (for nonnegative integral N)\n
" }{MPLTEXT 1 202 56 "# risingFactorial  seems not to be implemented i
n Maple\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 46 "fallingFactoria
l:=(x,N)->mul((x-k),k=0..N-1):\n" }{MPLTEXT 1 202 45 "risingFactorial:
=(x,N)->mul((x+k),k=0..N-1):\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 2 "#\n" }{MPLTEXT 1 202 27 "##########################\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 26 "# Combinatorial functions\n
" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 27 "########################
##\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 82 "# KostkaPC computes \+
the Kostka coefficient between a partition and a composition.\n" }
{MPLTEXT 1 202 78 "#          Every composition lies in a symmetric gr
oup orbit of a particular \n" }{MPLTEXT 1 202 76 "#          partition
, on which the Kostka coefficient is actually constant.\n" }{MPLTEXT 
1 202 82 "#          KostkaPC is defined as the Schur-Hall scalar prod
uct of the h[comp[i]]\n" }{MPLTEXT 1 202 84 "#          (=s[comp[i]) a
nd the Schur function with partition part. Since the outer\n" }
{MPLTEXT 1 202 84 "#          product is commutative and since zero pa
rts of the composition turn into\n" }{MPLTEXT 1 202 81 "#          the
 multiplicative unit, we compute just the outer product of the one\n" 
}{MPLTEXT 1 202 61 "#          part Schurfunctions and then the scalar
 product. \n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 28 "KostkaPC:=pr
oc(part1,part2)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Faus
er & R. Ablamowicz 2004-2009. All rights reserved.`;\n" }{MPLTEXT 1 
202 13 "  local mks;\n" }{MPLTEXT 1 202 36 "  mks:=(lst)->map(i->s[op(
i)],lst);\n" }{MPLTEXT 1 202 15 "  subs(s[0]=1,\n" }{MPLTEXT 1 202 59 
"      Scalar(outer(op(map(i->mks(i),part2))),s[op(part1)])\n" }
{MPLTEXT 1 202 9 "      );\n" }{MPLTEXT 1 202 10 "end proc:\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 89 "# grAlexcomp establishes th
e graded (by parts) anti lexicographical ordering on integer \n" }
{MPLTEXT 1 202 41 "#            partitions or compositions.\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 22 "grAlexComp:=proc(x,y)\n" }
{MPLTEXT 1 202 86 "  option `Copyright (c) B. Fauser & R. Ablamowicz 2
004-2009. All rights reserved.`;  \n" }{MPLTEXT 1 202 27 "  if nops(x)
<nops(y) then \n" }{MPLTEXT 1 202 9 "    true\n" }{MPLTEXT 1 202 7 "  \+
else\n" }{MPLTEXT 1 202 19 "     AlexComp(x,y)\n" }{MPLTEXT 1 202 10 "
  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" 
}{MPLTEXT 1 202 83 "# AlexComp  establishes the anti lexicographical o
rdering on integer partitions or\n" }{MPLTEXT 1 202 26 "#           co
mpositions.\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 20 "AlexComp:=p
roc(x,y)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R.
 Ablamowicz 2004-2009. All rights reserved.`;\n" }{MPLTEXT 1 202 16 " \+
 local i,bool;\n" }{MPLTEXT 1 202 8 "  i:=1;\n" }{MPLTEXT 1 202 37 "  \+
while i <= min(nops(x),nops(y)) do\n" }{MPLTEXT 1 202 75 "    if x[i]>
y[i] then return true elif x[i]<y[i] then return false end if;\n" }
{MPLTEXT 1 202 12 "    i:=i+1;\n" }{MPLTEXT 1 202 10 "  end do;\n" }
{MPLTEXT 1 202 11 "  true;   \n" }{MPLTEXT 1 202 10 "end proc:\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 85 "# isLattice checks if a tab
leaux (Young diagram or shape filled with (non negative) \n" }{MPLTEXT
 1 202 64 "#           integers is a Lattice permutation (ballot seque
nce)\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 21 "isLattice:=proc(tb
l)\n" }{MPLTEXT 1 202 83 "  option `Copyright (c) B. Fauser & R. Ablam
owicz 2004-2009. All rights reserved.`\n" }{MPLTEXT 1 202 22 "        \+
 ,remember;  \n" }{MPLTEXT 1 202 23 "  local cl,lst,i,nl,T;\n" }
{MPLTEXT 1 202 17 "  cl:=nops(tbl);\n" }{MPLTEXT 1 202 78 "  lst:=map(
x->if x=0 then NULL else x end if,[seq(op(tbl[cl+1-i]),i=1..cl)]);\n" 
}{MPLTEXT 1 202 20 "  nl:=max(op(lst));\n" }{MPLTEXT 1 202 24 "  for i
 from 1 to nl do\n" }{MPLTEXT 1 202 13 "    T[i]:=0:\n" }{MPLTEXT 1 
202 10 "  end do:\n" }{MPLTEXT 1 202 37 "  for i from nops(lst) by -1 \+
to 1 do\n" }{MPLTEXT 1 202 28 "    T[lst[i]]:=T[lst[i]]+1;\n" }
{MPLTEXT 1 202 64 "    if member(false,\{seq(evalb(T[i]>=T[i+1]),i=1..
nl-1)\}) then \n" }{MPLTEXT 1 202 20 "      return false;\n" }{MPLTEXT
 1 202 12 "    end if;\n" }{MPLTEXT 1 202 10 "  end do;\n" }{MPLTEXT 
1 202 9 "  true; \n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 
2 "#\n" }{MPLTEXT 1 202 85 "# ADD (internal use) adds a single letter \+
named 'let' (integer) to a tableau in such\n" }{MPLTEXT 1 202 86 "#   \+
  a way, that the resulting word is a lattice permutation (i.e. in a w
ay which is\n" }{MPLTEXT 1 202 86 "#     allowed by the Littlewood Ric
hardson rule). This is the function which actually\n" }{MPLTEXT 1 202 
87 "#     implements the Littlewood Richardson rule. It tries to be cl
ever about summation\n" }{MPLTEXT 1 202 78 "#     but might be greatly
 improved on speed still, but uses option remember.\n" }{MPLTEXT 1 
202 7 "#     \n" }{MPLTEXT 1 202 19 "ADD:=proc(tbl,let)\n" }{MPLTEXT 
1 202 83 "  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009.
 All rights reserved.`\n" }{MPLTEXT 1 202 20 "         ,remember;\n" }
{MPLTEXT 1 202 28 "  local cl,rl,ad,min,res,i;\n" }{MPLTEXT 1 202 6 "#
####\n" }{MPLTEXT 1 202 24 "# +++ preliminary stuff\n" }{MPLTEXT 1 
202 18 "  cl:=nops(tbl); \n" }{MPLTEXT 1 202 27 "  rl:=map(x->nops(x),
tbl);\n" }{MPLTEXT 1 202 24 "  ad:=(x,y)->[op(x),y]:\n" }{MPLTEXT 1 
202 11 "  res:=[]:\n" }{MPLTEXT 1 202 8 "# ---  \n" }{MPLTEXT 1 202 6 
"#####\n" }{MPLTEXT 1 202 39 "# +++ find first row with letter 'let'\n
" }{MPLTEXT 1 202 24 "# --- descending search\n" }{MPLTEXT 1 202 13 " \+
 min:=cl+1:\n" }{MPLTEXT 1 202 46 "  if member(let,\{op(map(x->op(x),t
bl))\}) then\n" }{MPLTEXT 1 202 32 "    for i from cl by -1 to 1 do\n"
 }{MPLTEXT 1 202 62 "      if member(let,\{op(tbl[i])\}) then min:=i: \+
break; end if;\n" }{MPLTEXT 1 202 12 "    end do:\n" }{MPLTEXT 1 202 
25 "  else # -- no let 'let'\n" }{MPLTEXT 1 202 12 "    min:=1;\n" }
{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 6 "#####\n" }{MPLTEXT 
1 202 64 "# +++ find first row with more letters let-1 than letters 'l
et'\n" }{MPLTEXT 1 202 29 "# +++ but start at row 'min'\n" }{MPLTEXT 
1 202 23 "# --- ascending search\n" }{MPLTEXT 1 202 17 "  if let>1 the
n \n" }{MPLTEXT 1 202 37 "    for i from max(1,min-1) to cl do\n" }
{MPLTEXT 1 202 99 "      if `+`(op( map(x->op(x),[seq( map( x->if x=le
t-1 then -1 elif x=let then 1 else NULL end if,\n" }{MPLTEXT 1 202 72 
"                       tbl[k]), k=1..i)]) )) < 0 then min:=i+1: break
; \n" }{MPLTEXT 1 202 14 "      end if;\n" }{MPLTEXT 1 202 12 "    end
 do:\n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 7 "##### \n" 
}{MPLTEXT 1 202 4 "  #\n" }{MPLTEXT 1 202 58 "  # +++ now start to put
 the letter in any possible place\n" }{MPLTEXT 1 202 33 "  # --- begin
ning with row 'min'\n" }{MPLTEXT 1 202 4 "  #\n" }{MPLTEXT 1 202 26 " \+
 for i from min to cl do\n" }{MPLTEXT 1 202 4 "  #\n" }{MPLTEXT 1 202 
30 "  # +++ case i=1 is different\n" }{MPLTEXT 1 202 4 "  #\n" }
{MPLTEXT 1 202 17 "    if i=1 then \n" }{MPLTEXT 1 202 50 "      if (t
bl[i][-1]<=let or tbl[i][-1]=0) then  \n" }{MPLTEXT 1 202 57 "        \+
if isLattice(subsop(i=ad(tbl[i],let),tbl)) then \n" }{MPLTEXT 1 202 
55 "          res:=[op(res),subsop(i=ad(tbl[i],let),tbl)];\n" }
{MPLTEXT 1 202 17 "        end if; \n" }{MPLTEXT 1 202 14 "      end i
f;\n" }{MPLTEXT 1 202 9 "    else\n" }{MPLTEXT 1 202 22 "  # +++ cases
 i=2..cl\n" }{MPLTEXT 1 202 31 "      if (rl[i-1]>rl[i]) then \n" }
{MPLTEXT 1 202 50 "        if (tbl[i][-1]<=let or tbl[i][-1]=0) then\n
" }{MPLTEXT 1 202 65 "          if (tbl[i-1][rl[i]+1]<let or tbl[i-1][
rl[i]+1]=0) then\n" }{MPLTEXT 1 202 61 "            if isLattice(subso
p(i=ad(tbl[i],let),tbl)) then \n" }{MPLTEXT 1 202 59 "              re
s:=[op(res),subsop(i=ad(tbl[i],let),tbl)];\n" }{MPLTEXT 1 202 26 "    \+
        end if;      \n" }{MPLTEXT 1 202 18 "          end if;\n" }
{MPLTEXT 1 202 16 "        end if;\n" }{MPLTEXT 1 202 14 "      end if
;\n" }{MPLTEXT 1 202 12 "    end if;\n" }{MPLTEXT 1 202 10 "  end do:
\n" }{MPLTEXT 1 202 17 "  # +++ last row\n" }{MPLTEXT 1 202 43 "  if (
tbl[cl][1]<let or tbl[cl][1]=0) then\n" }{MPLTEXT 1 202 40 "    if isL
attice([op(tbl),[let]]) then \n" }{MPLTEXT 1 202 44 "          res:=[o
p(res), [op(tbl),[let]] ];\n" }{MPLTEXT 1 202 18 "    end if;      \n"
 }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 11 "  op(res);\n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 83 "# LLR (internal use) is the Littlewood Richardson rule. This f
unction is based on \n" }{MPLTEXT 1 202 87 "#     the functionality of
 ADD adding one letter at a time. LLR evacuates one tableau \n" }
{MPLTEXT 1 202 82 "#     by adding its letters successively to the (li
st of) tableaux emerging from \n" }{MPLTEXT 1 202 22 "#     previous a
dds. \n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 21 "LRR:=proc(lst1,ls
t2)\n" }{MPLTEXT 1 202 83 "  option `Copyright (c) B. Fauser & R. Abla
mowicz 2004-2009. All rights reserved.`\n" }{MPLTEXT 1 202 20 "       \+
  ,remember;\n" }{MPLTEXT 1 202 22 "  local i,j,k,TT,srt;\n" }{MPLTEXT
 1 202 4 "  #\n" }{MPLTEXT 1 202 46 "  if lst1=[0] then return s[op(ls
t2)] end if;\n" }{MPLTEXT 1 202 46 "  if lst2=[0] then return s[op(lst
1)] end if;\n" }{MPLTEXT 1 202 4 "  #\n" }{MPLTEXT 1 202 44 "  TT:=[[s
eq([0$lst1[j]],j=1..nops(lst1))]]:\n" }{MPLTEXT 1 202 32 "  for i from
 1 to nops(lst2) do\n" }{MPLTEXT 1 202 29 "  for j from 1 to lst2[i] d
o\n" }{MPLTEXT 1 202 34 "    TT:=map(ADD,TT,i);    end do;\n" }
{MPLTEXT 1 202 10 "  end do;\n" }{MPLTEXT 1 202 73 "  `+`(op(map(x->s[
op(x)],[seq(map(x->nops(x),TT[k]),k=1..nops(TT))]))); \n" }{MPLTEXT 1 
202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 41 "# (ob
solete function, internal use only)\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 91 "# getPart strips of the name of a symmetric functio
n n[a,b,c] returning the indexing list.\n" }{MPLTEXT 1 202 67 "# +++  \+
   no longer used, inline use in code as [op(x)] directly. \n" }
{MPLTEXT 1 202 17 "getPart:=proc(x)\n" }{MPLTEXT 1 202 86 "  option `C
opyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.
`;  \n" }{MPLTEXT 1 202 11 "  [op(x)];\n" }{MPLTEXT 1 202 10 "end proc
:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 57 "# PartNM returns a li
st of partitions of N with M parts.\n" }{MPLTEXT 1 202 71 "#        Pa
rtNM returns a list ordered inversely to teh standard Maple\n" }
{MPLTEXT 1 202 28 "#        combinat package! \n" }{MPLTEXT 1 202 2 "#
\n" }{MPLTEXT 1 202 21 "PartNM := proc(n, m)\n" }{MPLTEXT 1 202 84 "  \+
option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights \+
reserved.`,\n" }{MPLTEXT 1 202 19 "         remember;\n" }{MPLTEXT 1 
202 20 "  local i, p, s, t;\n" }{MPLTEXT 1 202 16 "  if n = 0 then\n" 
}{MPLTEXT 1 202 16 "    return [[]]\n" }{MPLTEXT 1 202 18 "  elif m = \+
1 then\n" }{MPLTEXT 1 202 24 "    return [[`$`(1,n)]]\n" }{MPLTEXT 1 
202 7 "  else\n" }{MPLTEXT 1 202 18 "    for i to m do\n" }{MPLTEXT 1 
202 37 "      t := procname(n-i,min(n-i,i));\n" }{MPLTEXT 1 202 36 "  \+
    p[i] := seq([i, op(s)],s = t)\n" }{MPLTEXT 1 202 12 "    end do;\n
" }{MPLTEXT 1 202 32 "    [seq](p[m+1-i],i = 1 .. m);\n" }{MPLTEXT 1 
202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 
2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 93 "# partitionsInShap
e_gen(par) produces a _set_ of all partitions which fit into the shape
 par\n" }{MPLTEXT 1 202 91 "#         these are partitions of all weig
hts wt, 0 <= wt <= weight(par). These partitions\n" }{MPLTEXT 1 202 
87 "#         form the set of possibly non-trivial skews, and generate
 a minimal number of\n" }{MPLTEXT 1 202 97 "#         partitions for t
he Schur outer coproduct. This routine is not optimal as it internally
\n" }{MPLTEXT 1 202 99 "#         produces some partitions with a mult
iplicity, this is removed by the set data structure.\n" }{MPLTEXT 1 
202 30 "#         (internal use only)\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 33 "partitionsInShape_gen:=proc(par)\n" }{MPLTEXT 1 
202 29 "   local res,i,newpar,min,k;\n" }{MPLTEXT 1 202 39 "   if par=
[] then return [[0]] end if;\n" }{MPLTEXT 1 202 69 "   if nops(par)=1 \+
then return [seq([par[1]-i],i=0..par[1])] end if; \n" }{MPLTEXT 1 202 
15 "   res:=\{par\};\n" }{MPLTEXT 1 202 37 "   #-- for all descents de
lete a box\n" }{MPLTEXT 1 202 34 "   for i from 1 to nops(par)-1 do\n"
 }{MPLTEXT 1 202 30 "      if par[i]>par[i+1] then\n" }{MPLTEXT 1 202 
22 "         newpar:=par;\n" }{MPLTEXT 1 202 33 "         newpar[i]:=n
ewpar[i]-1;\n" }{MPLTEXT 1 202 46 "         res:=\{op(res),op(procname
(newpar))\};\n" }{MPLTEXT 1 202 14 "      end if;\n" }{MPLTEXT 1 202 
11 "   end do;\n" }{MPLTEXT 1 202 50 "   #-- last index, i points alre
ady to last index\n" }{MPLTEXT 1 202 20 "   if par[i]>1 then\n" }
{MPLTEXT 1 202 19 "      newpar:=par;\n" }{MPLTEXT 1 202 30 "      new
par[i]:=newpar[i]-1;\n" }{MPLTEXT 1 202 43 "      res:=\{op(res),op(pr
ocname(newpar))\};\n" }{MPLTEXT 1 202 8 "   else\n" }{MPLTEXT 1 202 
26 "      newpar:=par[1..-2];\n" }{MPLTEXT 1 202 43 "      res:=\{op(r
es),op(procname(newpar))\};\n" }{MPLTEXT 1 202 11 "   end if;\n" }
{MPLTEXT 1 202 9 "   res; \n" }{MPLTEXT 1 202 10 "end proc:\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 91 "# partitionsInShape(par) re
turns a sorted (wrt AlexComp) list of all partitions, including\n" }
{MPLTEXT 1 202 95 "#         the emty one and the input partition par \+
of partitions mu such that mu in par. These\n" }{MPLTEXT 1 202 90 "#  \+
       are the pertitions which potentially occure in the skew (and he
nce in the outer\n" }{MPLTEXT 1 202 22 "#         coproduct).\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 95 "partitionsInShape:=(par)->s
ort(ListTools:-Reverse([op(partitionsInShape_gen(par))]),AlexComp):\n"
 }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#
\n" }{MPLTEXT 1 202 58 "# CompNM returns a list of compositions of N w
ith M parts\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 18 "CompNM:=pro
c(N,M)\n" }{MPLTEXT 1 202 85 "   option `Copyright (c) B. Fauser & R. \+
Ablamowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 20 "  \+
        remember;\n" }{MPLTEXT 1 202 16 "   local res,i;\n" }{MPLTEXT 
1 202 33 "   if M<1 then return [] end if;\n" }{MPLTEXT 1 202 34 "   i
f M=1 then return [N] end if;\n" }{MPLTEXT 1 202 52 "   if M=2 then re
turn [seq([N-i,i],i=0..N)] end if;\n" }{MPLTEXT 1 202 12 "   res:=[];
\n" }{MPLTEXT 1 202 30 "   for i from N to 0 by -1 do\n" }{MPLTEXT 1 
202 61 "     res:=[op(res),op(map(x->[i,op(x)],procname(N-i,M-1)))];\n
" }{MPLTEXT 1 202 11 "   end do;\n" }{MPLTEXT 1 202 8 "   res;\n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 79 "# part2mset transforms a partition into multiset format, that \+
is a composition\n" }{MPLTEXT 1 202 77 "#           which gives the mu
ltiplicities of parts [4,4,2,1,1] -> [2,1,0,2]\n" }{MPLTEXT 1 202 2 "#
\n" }{MPLTEXT 1 202 22 "part2mset:=proc(part)\n" }{MPLTEXT 1 202 84 " \+
 option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights
 reserved.`,\n" }{MPLTEXT 1 202 20 "          remember;\n" }{MPLTEXT 
1 202 18 "  local m,mset,i;\n" }{MPLTEXT 1 202 37 "  if part=[0] then \+
return [] end if;\n" }{MPLTEXT 1 202 20 "  m:=max(op(part));\n" }
{MPLTEXT 1 202 25 "  mset:=[seq(0,i=1..m)];\n" }{MPLTEXT 1 202 32 "  f
or i from 1 to nops(part) do\n" }{MPLTEXT 1 202 36 "    mset[part[i]]:
=mset[part[i]]+1;\n" }{MPLTEXT 1 202 10 "  end do;\n" }{MPLTEXT 1 202 
9 "  mset; \n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n
" }{MPLTEXT 1 202 90 "# mset2part transforms a partition in multi set \+
representation into an ordinary partition\n" }{MPLTEXT 1 202 53 "#    \+
       represented by nonnegative integer parts\n" }{MPLTEXT 1 202 2 "
#\n" }{MPLTEXT 1 202 22 "mset2part:=proc(mset)\n" }{MPLTEXT 1 202 84 "
  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All right
s reserved.`,\n" }{MPLTEXT 1 202 20 "          remember;\n" }{MPLTEXT 
1 202 15 "  local prt,i;\n" }{MPLTEXT 1 202 11 "  prt:=[];\n" }
{MPLTEXT 1 202 32 "  for i from 1 to nops(mset) do\n" }{MPLTEXT 1 202 
29 "    prt:=[i$mset[i],op(prt)]\n" }{MPLTEXT 1 202 10 "  end do;\n" }
{MPLTEXT 1 202 36 "  if prt=[] then return [0] end if;\n" }{MPLTEXT 1 
202 7 "  prt;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#
\n" }{MPLTEXT 1 202 64 "# conjpart gives the conjugated partition of t
he partition part\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 21 "conjp
art:=proc(part)\n" }{MPLTEXT 1 202 83 "  option `Copyright (c) B. Faus
er & R. Ablamowicz 2004-2009. All rights reserved.`\n" }{MPLTEXT 1 
202 20 "         ,remember;\n" }{MPLTEXT 1 202 23 "  local len,res,ppa
rt;\n" }{MPLTEXT 1 202 49 "  if part=[] or part=[0] then return [0] en
d if;\n" }{MPLTEXT 1 202 19 "  len:=nops(part);\n" }{MPLTEXT 1 202 15 
"  ppart:=part;\n" }{MPLTEXT 1 202 11 "  res:=[];\n" }{MPLTEXT 1 202 
21 "  while ppart<>[] do\n" }{MPLTEXT 1 202 34 "    res:=[op(res),len$
ppart[-1]];\n" }{MPLTEXT 1 202 75 "    ppart:=map(x->if x=ppart[-1] th
en NULL else x-ppart[-1] end if,ppart);\n" }{MPLTEXT 1 202 22 "    len
:=nops(ppart);\n" }{MPLTEXT 1 202 10 "  end do;\n" }{MPLTEXT 1 202 7 "
  res;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 76 "# zee gives the factor z(lambda) in the schur scala
r product of power sums.\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 
"#\n" }{MPLTEXT 1 202 16 "zee:=proc(part)\n" }{MPLTEXT 1 202 83 "  opt
ion `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights res
erved.`\n" }{MPLTEXT 1 202 20 "         ,remember;\n" }{MPLTEXT 1 202 
14 "  local mset;\n" }{MPLTEXT 1 202 25 "  mset:=part2mset(part);\n" }
{MPLTEXT 1 202 43 "  mul(i^mset[i]*mset[i]!,i=1..nops(mset));\n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 68 "#  cmp2prtMult gives the multiplicity of the orbit of a compos
ition\n" }{MPLTEXT 1 202 57 "#              of its associated partitio
n under the S_n\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 24 "cmp2prt
Mult:=proc(comp)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fau
ser & R. Ablamowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 
202 20 "          remember;\n" }{MPLTEXT 1 202 24 "  local nc,part,f,c
nt0;\n" }{MPLTEXT 1 202 18 "  nc:=nops(comp);\n" }{MPLTEXT 1 202 11 " \+
 cnt0:=0;\n" }{MPLTEXT 1 202 61 "  part:=map(x->if x=0 then cnt0:=cnt0
+1; NULL else x end if,\n" }{MPLTEXT 1 202 69 "            sort(comp,(
i,j)->if i>=j then true else false end if) );\n" }{MPLTEXT 1 202 64 " \+
 part:=map(x->if x=0 then NULL else x end if,part2mset(part));\n" }
{MPLTEXT 1 202 43 "  if cnt0=0 then part:=part[1..-2] end if;\n" }
{MPLTEXT 1 202 20 "  #################\n" }{MPLTEXT 1 202 37 "  f:=(ri
,N)->mul(N-k,k=0..ri-1)/ri!;\n" }{MPLTEXT 1 202 20 "  ################
#\n" }{MPLTEXT 1 202 66 "  mul(f(part[k],nc+part[1]-add(part[m],m=1..k
)),k=1..nops(part));\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 
202 2 "#\n" }{MPLTEXT 1 202 67 "# cmp2part takes a composition and tra
nsforms it into a partition.\n" }{MPLTEXT 1 202 63 "#          This is
 a projection and a 'base point projection'.\n" }{MPLTEXT 1 202 2 "#\n
" }{MPLTEXT 1 202 21 "cmp2part:=proc(comp)\n" }{MPLTEXT 1 202 85 "   o
ption `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights r
eserved.`,\n" }{MPLTEXT 1 202 20 "          remember;\n" }{MPLTEXT 1 
202 42 "   map(x->if x=0 then NULL else x end if,\n" }{MPLTEXT 1 202 
60 "   sort(comp,(i,j)->if i>=j then true else false end if) );\n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 71 "# part2Frob (internal usage) maps a partition into Frobenius n
otation.\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 22 "part2Frob:=pro
c(Part)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. \+
Ablamowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 20 "  \+
        remember;\n" }{MPLTEXT 1 202 18 "  local res,part;\n" }
{MPLTEXT 1 202 53 "  if Part=[0] or Part=[] then return [[],[]] end if
;\n" }{MPLTEXT 1 202 26 "  part,res:=Part,[[],[]];\n" }{MPLTEXT 1 202 
20 "  while part<>[] do\n" }{MPLTEXT 1 202 36 "    res[1]:=[op(res[1])
,part[1]-1];\n" }{MPLTEXT 1 202 39 "    res[2]:=[op(res[2]),nops(part)
-1];\n" }{MPLTEXT 1 202 64 "    part:=map(x->if x>1 then x-1 else NULL
 end if,part[2..-1]);\n" }{MPLTEXT 1 202 10 "  end do;\n" }{MPLTEXT 1 
202 7 "  res;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#
\n" }{MPLTEXT 1 202 74 "# Frob2part (internal use) maps a partition in
 Frobenius notation into a \n" }{MPLTEXT 1 202 31 "#           standar
d partition\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 23 "Frob2part:=
proc(LList)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser &
 R. Ablamowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 
20 "          remember;\n" }{MPLTEXT 1 202 23 "  local res,llist,row;
\n" }{MPLTEXT 1 202 43 "  if LList=[[],[]] then return [0] end if;\n" 
}{MPLTEXT 1 202 40 "  res:=[LList[1][-1]+1,1$LList[2][-1]];\n" }
{MPLTEXT 1 202 46 "  if nops(LList[1])=1 then return res end if;\n" }
{MPLTEXT 1 202 44 "  llist:=[LList[1][1..-2],LList[2][1..-2]];\n" }
{MPLTEXT 1 202 26 "  while llist<>[[],[]] do\n" }{MPLTEXT 1 202 28 "  \+
   row:=[1$llist[2][-1]];\n" }{MPLTEXT 1 202 58 "     res:=[llist[1][-
1]+1,op(zip((i,j)->i+j,row,res,0))];\n" }{MPLTEXT 1 202 49 "     llist
:=[llist[1][1..-2],llist[2][1..-2]];  \n" }{MPLTEXT 1 202 10 "  end do
;\n" }{MPLTEXT 1 202 7 "  res;\n" }{MPLTEXT 1 202 10 "end proc:\n" }
{MPLTEXT 1 202 84 "###################################################
################################\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 
1 202 22 "# T R U N C functions\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 
1 202 84 "############################################################
#######################\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 82 
"# truncWT truncates the input to partitions of weight less or equal t
o the seond \n" }{MPLTEXT 1 202 21 "#         argument N\n" }{MPLTEXT 
1 202 2 "#\n" }{MPLTEXT 1 202 19 "truncWT:=proc(x,N)\n" }{MPLTEXT 1 
202 84 "  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2006. A
ll rights reserved.`,\n" }{MPLTEXT 1 202 12 "  remember;\n" }{MPLTEXT 
1 202 32 "  local cf,tm,n1,plst1,plst2,i;\n" }{MPLTEXT 1 202 23 "  if \+
type(x,`+`) then \n" }{MPLTEXT 1 202 30 "    return map(procname,x,N);
\n" }{MPLTEXT 1 202 25 "  elif type(x,`*`) then \n" }{MPLTEXT 1 202 
45 "    tm,cf:=selectremove(type,x,symfktmonom);\n" }{MPLTEXT 1 202 
29 "    return cf*procname(tm,N)\n" }{MPLTEXT 1 202 7 "  else\n" }
{MPLTEXT 1 202 56 "    if `+`(op(x))>N then return 0 else return x end
 if;\n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:
\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 77 "# truncLEN_mon truncat
es partitions of any type of symmetric function monoms\n" }{MPLTEXT 1 
202 37 "#       to length less or equal to L\n" }{MPLTEXT 1 202 2 "#\n
" }{MPLTEXT 1 202 27 "truncLEN_mon:=proc(sfkt,L)\n" }{MPLTEXT 1 202 
84 "  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2006. All r
ights reserved.`;\n" }{MPLTEXT 1 202 31 "   if nops([op(sfkt)])<=L the
n\n" }{MPLTEXT 1 202 17 "     return sfkt\n" }{MPLTEXT 1 202 8 "   els
e\n" }{MPLTEXT 1 202 14 "     return 0\n" }{MPLTEXT 1 202 11 "   end i
f;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 68 "# truncLEN truncates the partitions of a symmetric \+
function polynom\n" }{MPLTEXT 1 202 65 "#       to length smaller or e
uqlt to L, it is a linear function\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 25 "truncLEN:=proc(symfkt,L)\n"
 }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ablamowicz
 2004-2006. All rights reserved.`;\n" }{MPLTEXT 1 202 17 "  local cf,t
erm;\n" }{MPLTEXT 1 202 34 "if symfkt=0 then return 0 end if;\n" }
{MPLTEXT 1 202 35 "  if type(symfkt,symfktmonom) then\n" }{MPLTEXT 1 
202 27 "    truncLEN_mon(symfkt,L)\n" }{MPLTEXT 1 202 29 "  elif type(
symfkt,`*`) then\n" }{MPLTEXT 1 202 52 "    term,cf:=selectremove(type
,symfkt,symfktmonom);\n" }{MPLTEXT 1 202 36 "    return cf*truncLEN_mo
n(term,L);\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 28 "    map
(procname,symfkt,L);\n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 
202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 76 "# tru
ncPART projects on symmetric functions where the parts of the involved
\n" }{MPLTEXT 1 202 50 "#           partitions is less than or equal t
o N\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 21 "truncPART:=proc(x,N
)\n" }{MPLTEXT 1 202 21 "  local cf,term,prt;\n" }{MPLTEXT 1 202 22 " \+
 if type(x,`+`) then\n" }{MPLTEXT 1 202 31 "     return map(procname,x
,N);\n" }{MPLTEXT 1 202 24 "  elif type(x,`*`) then\n" }{MPLTEXT 1 
202 48 "     term,cf:=selectremove(type,x,symfktmonom);\n" }{MPLTEXT 
1 202 33 "     return cf*procname(term,N);\n" }{MPLTEXT 1 202 7 "  els
e\n" }{MPLTEXT 1 202 27 "     if max(op(x))>N then \n" }{MPLTEXT 1 
202 17 "       return 0;\n" }{MPLTEXT 1 202 10 "     else\n" }{MPLTEXT
 1 202 17 "       return x;\n" }{MPLTEXT 1 202 18 "     end if;     \n
" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }
{MPLTEXT 1 202 1 "\n" }{MPLTEXT 1 202 66 "############################
#####################################\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 67 "# collect_sfkt collects a polynomial with respect t
o an sfunction \n" }{MPLTEXT 1 202 66 "#      basis 's,p,m,h,f,e' and \+
returns the prefactors factorized.\n" }{MPLTEXT 1 202 67 "#      The b
asis is by default the Schur function basis and may be\n" }{MPLTEXT 1 
202 64 "#      altered by giving a letter from the set 's,p,m,h,f,e' a
s\n" }{MPLTEXT 1 202 24 "#      second argument.\n" }{MPLTEXT 1 202 2 
"#\n" }{MPLTEXT 1 202 66 "############################################
#####################\n" }{MPLTEXT 1 202 22 "collect_sfkt:=proc(X)\n" 
}{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ablamowicz \+
2004-2006. All rights reserved.`;\n" }{MPLTEXT 1 202 41 "  local x,lst
,i,term,terms,termTbl,TYPE;\n" }{MPLTEXT 1 202 18 "  if nargs=2 then\n
" }{MPLTEXT 1 202 19 "    TYPE:=args[2];\n" }{MPLTEXT 1 202 43 "    if
 not member(TYPE,\{s,p,m,h,f,e\}) then\n" }{MPLTEXT 1 202 77 "      er
ror \"You picked a type '%1' which is not in my list of known types\\n
\n" }{MPLTEXT 1 202 36 "             's,p,m,h,f,e' !\",TYPE;\n" }
{MPLTEXT 1 202 12 "    end if;\n" }{MPLTEXT 1 202 8 "  else \n" }
{MPLTEXT 1 202 15 "    TYPE:='s';\n" }{MPLTEXT 1 202 10 "  end if;\n" 
}{MPLTEXT 1 202 31 "  if x=0 then return 0 end if;\n" }{MPLTEXT 1 202 
16 "  x:=expand(X);\n" }{MPLTEXT 1 202 14 "  terms:=\{\}; \n" }
{MPLTEXT 1 202 38 "  if type(x,cat(TYPE,fktmonom)) then \n" }{MPLTEXT 
1 202 15 "     return x;\n" }{MPLTEXT 1 202 38 "  elif type(x,cat(TYPE
,fktterm)) then\n" }{MPLTEXT 1 202 16 "      return x;\n" }{MPLTEXT 1 
202 24 "  elif type(x,`+`) then\n" }{MPLTEXT 1 202 20 "      lst:=[op(
x)];\n" }{MPLTEXT 1 202 35 "      for i from 1 to nops(lst) do\n" }
{MPLTEXT 1 202 48 "        if type(lst[i],cat(TYPE,fktmonom)) then\n" 
}{MPLTEXT 1 202 31 "          termTbl:=(lst[i])=1;\n" }{MPLTEXT 1 202 
13 "        else\n" }{MPLTEXT 1 202 56 "          term:=select(type,ls
t[i],cat(TYPE,fktmonom));\n" }{MPLTEXT 1 202 35 "          terms:=\{op
(terms),term\};\n" }{MPLTEXT 1 202 16 "        end if;\n" }{MPLTEXT 1 
202 14 "      end do;\n" }{MPLTEXT 1 202 24 "      if terms=\{1\} then
\n" }{MPLTEXT 1 202 73 "        error \"I didn't find a basis element,
 provide a correct basis!\";\n" }{MPLTEXT 1 202 14 "      end if;\n" }
{MPLTEXT 1 202 43 "      return map(factor,collect(x,terms));\n" }
{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }
{MPLTEXT 1 202 66 "###################################################
##############\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 69 "#  sfkt_
terms returns a set of basis monoms of an input expression. \n" }
{MPLTEXT 1 202 67 "#      The basis is by default the Schur function b
asis and may be\n" }{MPLTEXT 1 202 64 "#      altered by giving a lett
er from the set 's,p,m,h,f,e' as\n" }{MPLTEXT 1 202 24 "#      second \+
argument.\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 66 "#############
####################################################\n" }{MPLTEXT 1 
202 20 "sfkt_terms:=proc(X)\n" }{MPLTEXT 1 202 84 "  option `Copyright
 (c) B. Fauser & R. Ablamowicz 2004-2006. All rights reserved.`;\n" }
{MPLTEXT 1 202 44 "  local cf,x,lst,i,term,terms,termTbl,TYPE;\n" }
{MPLTEXT 1 202 18 "  if nargs=2 then\n" }{MPLTEXT 1 202 19 "    TYPE:=
args[2];\n" }{MPLTEXT 1 202 43 "    if not member(TYPE,\{s,p,m,h,f,e\}
) then\n" }{MPLTEXT 1 202 100 "      error \"You picked a type '%1' wh
ich is not in my list of known types\\n 's,p,m,h,f,e' !\",TYPE;\n" }
{MPLTEXT 1 202 12 "    end if;\n" }{MPLTEXT 1 202 8 "  else \n" }
{MPLTEXT 1 202 15 "    TYPE:='s';\n" }{MPLTEXT 1 202 10 "  end if;\n" 
}{MPLTEXT 1 202 16 "  x:=expand(X);\n" }{MPLTEXT 1 202 14 "  terms:=\{
\}; \n" }{MPLTEXT 1 202 38 "  if type(x,cat(TYPE,fktmonom)) then \n" }
{MPLTEXT 1 202 17 "     return \{x\};\n" }{MPLTEXT 1 202 38 "  elif ty
pe(x,cat(TYPE,fktterm)) then\n" }{MPLTEXT 1 202 55 "      term,cf:=sel
ectremove(type,x,cat(TYPE,fktterm));\n" }{MPLTEXT 1 202 21 "      retu
rn \{term\};\n" }{MPLTEXT 1 202 24 "  elif type(x,`+`) then\n" }
{MPLTEXT 1 202 20 "      lst:=[op(x)];\n" }{MPLTEXT 1 202 35 "      fo
r i from 1 to nops(lst) do\n" }{MPLTEXT 1 202 48 "        if type(lst[
i],cat(TYPE,fktmonom)) then\n" }{MPLTEXT 1 202 37 "          terms:=\{
op(terms),lst[i]\};\n" }{MPLTEXT 1 202 13 "        else\n" }{MPLTEXT 
1 202 56 "          term:=select(type,lst[i],cat(TYPE,fktmonom));\n" }
{MPLTEXT 1 202 35 "          terms:=\{op(terms),term\};\n" }{MPLTEXT 
1 202 16 "        end if;\n" }{MPLTEXT 1 202 14 "      end do;\n" }
{MPLTEXT 1 202 156 "      if terms=\{1\} then error \"Couldn't find a \+
basis monom!\\nyou can provide a second argument with the name of the \+
basis like 's', 'p', 'h', 'f', 'e' \\n\";\n" }{MPLTEXT 1 202 14 "     \+
 end if;\n" }{MPLTEXT 1 202 20 "      return terms;\n" }{MPLTEXT 1 
202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 
66 "#################################################################
\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 62 "# Functions related to
 the Lascoux Schuetzenberger algorithm \n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 48 "#          to multiply and skew Schur functions\n" 
}{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 66 "##########################
#######################################\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 67 "# lehmerCodeToPermutation t
ransform a Lehmer code of a permutation\n" }{MPLTEXT 1 202 67 "#      \+
     into the list representation of that permutation, that\n" }
{MPLTEXT 1 202 65 "#           is the list of the image of the permuta
ion of of the\n" }{MPLTEXT 1 202 33 "#           standatd list [1..n]
\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 85 "#     Note: we prune t
railing fixed points, it the second variable is set to \"prune\"\n" }
{MPLTEXT 1 202 29 "#           including quotes\n" }{MPLTEXT 1 202 2 "
#\n" }{MPLTEXT 1 202 53 "#   -- The algorithm use is the following rec
ursion:\n" }{MPLTEXT 1 202 44 "#   -- let ordLst be the orderd list [1
..n]\n" }{MPLTEXT 1 202 46 "#   -- \\pi_1 is the lement ordLst_\{code[
1]+1\}\n" }{MPLTEXT 1 202 67 "#   -- remove the element ordLst_\{code[
1]+1\} from the list ordList\n" }{MPLTEXT 1 202 46 "#   -- \\pi_2 is t
he lement ordLst_\{code[2]+1\}\n" }{MPLTEXT 1 202 67 "#   -- remove th
e element ordLst_\{code[2]+1\} from the list ordList\n" }{MPLTEXT 1 
202 37 "#   -- repeat unless ordLst is empty\n" }{MPLTEXT 1 202 65 "# \+
  -- if \"prune\" is set, we skip trailing fixed points, that is\n" }
{MPLTEXT 1 202 72 "#   -- we reduce the permutation from S_n (n=card(o
rdLst)) to a smaller\n" }{MPLTEXT 1 202 70 "#   -- S_k which acts on t
he first [1..k] entries, in this way S_k is\n" }{MPLTEXT 1 202 46 "#  \+
 -- canonically embedded into S_n for n>k.\n" }{MPLTEXT 1 202 2 "#\n" 
}{MPLTEXT 1 202 36 "lehmerCodeToPermutation:=proc(code)\n" }{MPLTEXT 
1 202 19 "  option remember;\n" }{MPLTEXT 1 202 32 "  local ordLst,i,i
dx,per,prune;\n" }{MPLTEXT 1 202 106 "  if nargs=2 and args[2]=\"prune
\" then prune:=true; print(\"prune is true now\"); else prune:=false; \+
end if;\n" }{MPLTEXT 1 202 39 "  ordLst:=[seq(i,i in 1..nops(code))];
\n" }{MPLTEXT 1 202 11 "  per:=[];\n" }{MPLTEXT 1 202 32 "  for i from
 1 to nops(code) do\n" }{MPLTEXT 1 202 29 "     idx:=ordLst[code[i]+1]
;\n" }{MPLTEXT 1 202 25 "     per:=[op(per),idx];\n" }{MPLTEXT 1 202 
36 "     ordLst:=subs(idx=NULL,ordLst);\n" }{MPLTEXT 1 202 10 "  end d
o;\n" }{MPLTEXT 1 202 21 "  if prune=true then\n" }{MPLTEXT 1 202 19 "
     i:=nops(per);\n" }{MPLTEXT 1 202 31 "     while per[i]=i and i>1 \+
do\n" }{MPLTEXT 1 202 16 "        i:=i-1;\n" }{MPLTEXT 1 202 25 "     \+
   per:=per[1..-2];\n" }{MPLTEXT 1 202 13 "     end do;\n" }{MPLTEXT 
1 202 11 "   end if;\n" }{MPLTEXT 1 202 7 "  per;\n" }{MPLTEXT 1 202 
10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 85 "# permuta
tionToLehmerCode transforms a permutation \\pi in list representation \+
(image\n" }{MPLTEXT 1 202 84 "#             of \\pi acting on the stan
dard set [1..n]) into the Lehmer code of the\n" }{MPLTEXT 1 202 26 "# \+
            permutation\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 76 
"#     -- The Lehmer code of a permutation is given by code:=[l1,..,ln
] with\n" }{MPLTEXT 1 202 42 "#     -- lk :=Card \{ j>k, \\pi[k]>\\pi[
j] \}\n" }{MPLTEXT 1 202 78 "#     -- The Lehmer code is a factorial n
umber system adapted to permutations\n" }{MPLTEXT 1 202 79 "#     -- s
ince card S_n = n! This allows a one-one relation between such codes\n
" }{MPLTEXT 1 202 27 "#     -- and permutations.\n" }{MPLTEXT 1 202 
86 "#     -- If S_k is embedded into S_n in such a way that S_k permus
te the first [1..k]\n" }{MPLTEXT 1 202 85 "#     -- entries of the sta
ndard set while S_n permutes [1..n], then the Lehmer code\n" }{MPLTEXT
 1 202 86 "#     -- of a permutation S_k transforms under this injecti
on into the Lehmer code of\n" }{MPLTEXT 1 202 64 "#     -- \\pi in S_n
 by adding appropriatly many trailing zeros.\n" }{MPLTEXT 1 202 2 "#\n
" }{MPLTEXT 1 202 35 "permutationToLehmerCode:=proc(per)\n" }{MPLTEXT 
1 202 19 "  option remember;\n" }{MPLTEXT 1 202 28 "  local idx,lehmer
,res,k,j;\n" }{MPLTEXT 1 202 35 "  if per=[] then return [] end if;\n"
 }{MPLTEXT 1 202 144 "  if \{op(per)\}<>\{seq(i,i in 1..nops(per))\} t
hen error \"input was not a permutation of the form (i1,i2,...in) with
 entries ik in [1..n]\" end if;\n" }{MPLTEXT 1 202 36 "  if per=[] the
n return [0] end if;\n" }{MPLTEXT 1 202 14 "  lehmer:=[];\n" }{MPLTEXT
 1 202 33 "  for k from 1 to nops(per)-1 do\n" }{MPLTEXT 1 202 13 "   \+
  idx:=0;\n" }{MPLTEXT 1 202 36 "     for j from k+1 to nops(per) do\n
" }{MPLTEXT 1 202 49 "        if per[j]<per[k] then idx:=idx+1 end if;
\n" }{MPLTEXT 1 202 13 "     end do;\n" }{MPLTEXT 1 202 31 "     lehme
r:=[op(lehmer),idx];\n" }{MPLTEXT 1 202 11 "   end do;\n" }{MPLTEXT 1 
202 18 "  [op(lehmer),0];\n" }{MPLTEXT 1 202 10 "end proc:\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 77 "# Descents takes a permutat
ion pi and returns the the list of descents of pi\n" }{MPLTEXT 1 202 
57 "#         ++ the list of descents is in decreasing order\n" }
{MPLTEXT 1 202 70 "#         ++ Descents describe important facts abou
t the structure of\n" }{MPLTEXT 1 202 69 "#         ++ reduced words r
epresenting permutations when written as\n" }{MPLTEXT 1 202 58 "#     \+
    ++ product of elementary transpositions (i,i+1)\n" }{MPLTEXT 1 
202 2 "#\n" }{MPLTEXT 1 202 20 "Descents:=proc(per)\n" }{MPLTEXT 1 
202 20 "   option remember;\n" }{MPLTEXT 1 202 16 "   local des,i;\n" 
}{MPLTEXT 1 202 12 "   des:=[];\n" }{MPLTEXT 1 202 34 "   for i from 1
 to nops(per)-1 do\n" }{MPLTEXT 1 202 56 "      if per[i]>per[i+1] the
n des:=[i,op(des)]; end if;\n" }{MPLTEXT 1 202 11 "   end do;\n" }
{MPLTEXT 1 202 8 "   des;\n" }{MPLTEXT 1 202 10 "end proc:\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 78 "# lehmerCodeToSchurFkt tran
sforms a Lehmer code of a Grassmannian permutation\n" }{MPLTEXT 1 202 
75 "#         ++ that is a permutation which respresents a Schur funct
ion into\n" }{MPLTEXT 1 202 70 "#         ++ the Schurfunction with th
e corresponding partition lable\n" }{MPLTEXT 1 202 88 "#         ++ NO
TE: No check is performed if the input is a Lehmer code of a Grassmani
an\n" }{MPLTEXT 1 202 79 "#         ++       permutation. This routine
 is meant for internal use mainly.\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 33 "lehmerCodeToSchurFkt:=proc(code)\n" }{MPLTEXT 1 
202 20 "   option remember;\n" }{MPLTEXT 1 202 16 "   local i,prt;\n" 
}{MPLTEXT 1 202 61 "   ## ++ no check included, user or algorithm must
 make sure\n" }{MPLTEXT 1 202 88 "   ## ++ input represents a Schur fu
nction, otherwise return value is invalid_operation\n" }{MPLTEXT 1 
202 12 "   prt:=[];\n" }{MPLTEXT 1 202 33 "   for i from 1 to nops(cod
e) do\n" }{MPLTEXT 1 202 24 "     if code[i]<>0 then\n" }{MPLTEXT 1 
202 31 "       prt:=[code[i],op(prt)];\n" }{MPLTEXT 1 202 13 "     end
 if;\n" }{MPLTEXT 1 202 11 "   end do;\n" }{MPLTEXT 1 202 81 "   ## --
 possibly needs to be sorted, if vexillary permutations are used, if t
he\n" }{MPLTEXT 1 202 78 "   ## -- transition algorithm runs through, \+
till the permutation has only one\n" }{MPLTEXT 1 202 59 "   ## -- desc
ent, it seems to be unnecessary to sort here.\n" }{MPLTEXT 1 202 14 " \+
  s[op(prt)]\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#
\n" }{MPLTEXT 1 202 80 "# schurToLehmerCode implements the relation be
tween a Schurfunction \{\\lambda\}^m\n" }{MPLTEXT 1 202 80 "#     \{
\\lambda\}^m=s_\\lambda(x1,...xm) in exactly m-variables and a Grassma
nnian\n" }{MPLTEXT 1 202 84 "#     Lehmer code of a permutation (that \+
is a permutation with exactly one descent.\n" }{MPLTEXT 1 202 80 "#   \+
  The parameter m gived the muner of variables. Caution, if m is too s
mall,\n" }{MPLTEXT 1 202 73 "#     the Schur function may be unreprese
ntable (=0) in that Z[x1,..,xm]\n" }{MPLTEXT 1 202 81 "#     An optima
l embedding is reached by setting m=length(\\lambda), resulting in\n" 
}{MPLTEXT 1 202 44 "#     no leading zerors on teh Lehmer code.\n" }
{MPLTEXT 1 202 77 "#     We don't add trailing zeros, but keep the min
imal number of _required_\n" }{MPLTEXT 1 202 21 "#     trailing zeros
\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 32 "schurToLehmerCode:=pro
c(sfkt,m)\n" }{MPLTEXT 1 202 20 "   option remember;\n" }{MPLTEXT 1 
202 24 "   local code,i,par,wt;\n" }{MPLTEXT 1 202 20 "   par:=[op(sfk
t)];\n" }{MPLTEXT 1 202 22 "   wt:=`+`(op(sfkt));\n" }{MPLTEXT 1 202 
13 "   code:=[];\n" }{MPLTEXT 1 202 32 "   for i from 1 to nops(par) d
o\n" }{MPLTEXT 1 202 31 "      code:=[par[i],op(code)];\n" }{MPLTEXT 
1 202 11 "   end do;\n" }{MPLTEXT 1 202 30 "   code:=[op(code),0$par[1
]];\n" }{MPLTEXT 1 202 31 "   [0$(m-nops(par)),op(code)];\n" }{MPLTEXT
 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 88 "# \+
schurToLehmerCode1 computes automatically the minimal embedding of the
 Schur function\n" }{MPLTEXT 1 202 31 "#     in terms of Lehmer codes
\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 73 "schurToLehmerCode1:=pr
oc(x) schurToLehmerCode(x,nops([op(x)])) end proc:\n" }{MPLTEXT 1 202 
2 "#\n" }{MPLTEXT 1 202 68 "# skewToLehmerCode transforms two partitio
ns of two schur functions\n" }{MPLTEXT 1 202 68 "#      which are to b
e skewed into the Lehmer code representing the\n" }{MPLTEXT 1 202 39 "
#      skew partitions schur function.\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 32 "skewToLehmerCode:=proc(sf1,sf2)\n" }{MPLTEXT 1 202 
20 "   option remember;\n" }{MPLTEXT 1 202 28 "   local prt,i,code,k,e
lem;\n" }{MPLTEXT 1 202 19 "   prt:=[op(sf1)];\n" }{MPLTEXT 1 202 13 "
   code:=[];\n" }{MPLTEXT 1 202 32 "   for i from 1 to nops(prt) do\n"
 }{MPLTEXT 1 202 31 "      code:=[prt[i],op(code)];\n" }{MPLTEXT 1 
202 11 "   end do;\n" }{MPLTEXT 1 202 32 "   code:=[op(code),0$code[-1
]];\n" }{MPLTEXT 1 202 40 "   if sf2=s[0] then return code end if;\n" 
}{MPLTEXT 1 202 17 "   k:=nops(prt);\n" }{MPLTEXT 1 202 19 "   prt:=[o
p(sf2)];\n" }{MPLTEXT 1 202 32 "   for i from 1 to nops(prt) do\n" }
{MPLTEXT 1 202 38 "      code[k+prt[i]]:=code[k]-prt[i];\n" }{MPLTEXT 
1 202 18 "      code[k]:=0;\n" }{MPLTEXT 1 202 14 "      k:=k-1;\n" }
{MPLTEXT 1 202 11 "   end do;\n" }{MPLTEXT 1 202 15 "   [op(code)];\n"
 }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 106 "# transition implements an algorithmy by Lascoux and Schuetze
rnberger Lett. Math. Phys. 10 (1985) 111-124\n" }{MPLTEXT 1 202 109 "#
      this paper does not give a full description of the implemented c
ode, but uses vexillary permutations.\n" }{MPLTEXT 1 202 100 "#      W
e use a variant of the algorithm described by Axel Konhner, who was al
so helpful in proding\n" }{MPLTEXT 1 202 45 "#      details and furthe
r information, see:\n" }{MPLTEXT 1 202 70 "#      A. Kohner, Schubert \+
polynomials and skew Schur functions, 1991\n" }{MPLTEXT 1 202 86 "#   \+
   A. Kohner, The use of Schubert polynomials in SYMCHAR (later SYMMET
RICA), 1991\n" }{MPLTEXT 1 202 37 "#      A further usefull resource i
s\n" }{MPLTEXT 1 202 83 "#      R. Winkel, Recursive and combinatorial
 properties of Schubert polynomials, \n" }{MPLTEXT 1 202 66 "#        \+
         Sem. Lotharigien de Comb. Vol38 1996 B38c 29pp \n" }{MPLTEXT 
1 202 2 "#\n" }{MPLTEXT 1 202 37 "#      The algorithms is as follows:
\n" }{MPLTEXT 1 202 78 "#      input a permutation pi, not of Grassman
ian type (two or more descents)\n" }{MPLTEXT 1 202 43 "#      1) compu
te the right most descent k\n" }{MPLTEXT 1 202 87 "#      2) swap the \+
element pi[k] and the largest pi[l] to the right smaller than pi[k]\n"
 }{MPLTEXT 1 202 55 "#      3) find all elements to the left of k such
 that\n" }{MPLTEXT 1 202 41 "#         -- pi[l] is smaller than pi[k]
\n" }{MPLTEXT 1 202 64 "#         -- there is no pi[j] with pi[l]<pi[j
]<pi[k] for l<j<k\n" }{MPLTEXT 1 202 78 "#         produce all permuta
tiones obtained by swapping the pi[l] with pi[k]\n" }{MPLTEXT 1 202 
50 "#         Note: We had to add the following rule:\n" }{MPLTEXT 1 
202 83 "#         -- If the search for pi[l] returns no element, then \+
return the partition\n" }{MPLTEXT 1 202 84 "#            which is obta
ined by shifting the Lehmer code of the _input_ partition\n" }{MPLTEXT
 1 202 58 "#            by one to the right inserting a 0 at place 1\n
" }{MPLTEXT 1 202 79 "#            [On the partition this means add a \+
1 to each part and concatenate\n" }{MPLTEXT 1 202 28 "#              1
 |_| 1+[pi]\n" }{MPLTEXT 1 202 55 "#      4) output the list of the pr
oduced permutations\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n"
 }{MPLTEXT 1 202 24 "transition:=proc(perIN)\n" }{MPLTEXT 1 202 20 "  \+
 option remember;\n" }{MPLTEXT 1 202 52 "   local max,per,k,l,i,elem,r
es,sp_min,newper,code;\n" }{MPLTEXT 1 202 45 "   # -- per needs to hav
e nops(per)>2 check?\n" }{MPLTEXT 1 202 21 "   max:=nops(perIN);\n" }
{MPLTEXT 1 202 15 "   per:=perIN;\n" }{MPLTEXT 1 202 34 "   # -- ingon
e final fixed points\n" }{MPLTEXT 1 202 45 "   while per[max]=max do m
ax:=max-1; end do;\n" }{MPLTEXT 1 202 26 "   # -- find last descent\n"
 }{MPLTEXT 1 202 13 "   k:=max-1;\n" }{MPLTEXT 1 202 44 "   while per[
k]<per[k+1] do k:=k-1; end do;\n" }{MPLTEXT 1 202 67 "   # find larges
t per[l] to the right of per[k] with per[l]<per[k]\n" }{MPLTEXT 1 202 
11 "   l:=k+1;\n" }{MPLTEXT 1 202 17 "   elem:=per[l];\n" }{MPLTEXT 1 
202 28 "   for i from k+2 to max do\n" }{MPLTEXT 1 202 71 "      if pe
r[i]<per[k] and elem<per[i] then elem:=per[i]; l:=i end if;\n" }
{MPLTEXT 1 202 11 "   end do;\n" }{MPLTEXT 1 202 46 "   ## -- switch p
laces k,l, note elem:=per[l]\n" }{MPLTEXT 1 202 19 "   per[l]:=per[k];
\n" }{MPLTEXT 1 202 17 "   per[k]:=elem;\n" }{MPLTEXT 1 202 50 "   # -
- find all elements left to k which fulfill\n" }{MPLTEXT 1 202 49 "   \+
# -- per[l]<per[k] and no element exists with\n" }{MPLTEXT 1 202 39 " \+
  # -- per[l\}<per[i]<per[k] for l<i<k\n" }{MPLTEXT 1 202 66 "   # -- \+
switch these elements and return the list or permutations\n" }{MPLTEXT
 1 202 12 "   res:=[];\n" }{MPLTEXT 1 202 49 "   # -- find elements sm
aller per[k] to the left\n" }{MPLTEXT 1 202 25 "   # -- special case k
=1\n" }{MPLTEXT 1 202 36 "   if k=1 then return [per] end if;\n" }
{MPLTEXT 1 202 11 "   l:=k-1;\n" }{MPLTEXT 1 202 16 "   sp_min:=0;  \n
" }{MPLTEXT 1 202 16 "   while l>0 do\n" }{MPLTEXT 1 202 48 "        i
f sp_min<per[l] and per[l]<per[k] then\n" }{MPLTEXT 1 202 54 "        \+
# -- make new permutation with (l,k) switched\n" }{MPLTEXT 1 202 24 " \+
       sp_min:=per[l];\n" }{MPLTEXT 1 202 21 "        newper:=per;\n" 
}{MPLTEXT 1 202 27 "        newper[l]:=per[k];\n" }{MPLTEXT 1 202 27 "
        newper[k]:=per[l];\n" }{MPLTEXT 1 202 31 "        res:=[op(res
),newper];\n" }{MPLTEXT 1 202 14 "      end if;\n" }{MPLTEXT 1 202 24 
"      # -- else proceed\n" }{MPLTEXT 1 202 15 "      l:=l-1; \n" }
{MPLTEXT 1 202 11 "   end do;\n" }{MPLTEXT 1 202 33 "   ## A. Kohnert \+
says keep this:\n" }{MPLTEXT 1 202 26 "   if l=0 and res=[] then\n" }
{MPLTEXT 1 202 71 "   # -- However, we need to add a prefix 0 to the L
ehmer code of perIN\n" }{MPLTEXT 1 202 74 "   # -- otherwise the algor
ithm cannot find an element in the left search\n" }{MPLTEXT 1 202 45 "
      if perIN[nops(perIN)]=nops(perIN) then\n" }{MPLTEXT 1 202 58 "  \+
      res:=[[1,seq(perIN[i]+1,i in 1..nops(perIN)-1)]];\n" }{MPLTEXT 
1 202 11 "      else\n" }{MPLTEXT 1 202 56 "        res:=[[1,seq(perIN
[i]+1,i in 1..nops(perIN))]];\n" }{MPLTEXT 1 202 14 "      end if;\n" 
}{MPLTEXT 1 202 11 "   end if;\n" }{MPLTEXT 1 202 8 "   res;\n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 66 "##############################################################
###\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 24 "# basis transformat
ions\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 66 "##################
###############################################\n" }{MPLTEXT 1 202 2 "
#\n" }{MPLTEXT 1 202 68 "# s_to_xM transforms an S-function into a pol
ynom of x-monomials in\n" }{MPLTEXT 1 202 67 "#         N variables (x
1,x2,...,xn) (N should be greater or equal\n" }{MPLTEXT 1 202 42 "#   \+
      to the weight of the partition.\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 62 "#         <internal use; users use the linear versi
on s_to_x>\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 22 "s_to_xM:=pro
c(sfkt,N)\n" }{MPLTEXT 1 202 83 "  option `Copyright (c) B. Fauser & R
. Ablamowicz 2004-2009. All rights reserved.`\n" }{MPLTEXT 1 202 20 " \+
        ,remember;\n" }{MPLTEXT 1 202 13 "  local cmp;\n" }{MPLTEXT 1 
202 32 "  cmp:=CompNM(`+`(op(sfkt)),N);\n" }{MPLTEXT 1 202 46 "  add(K
ostkaPC([op(sfkt)],k)*x[op(k)],k=cmp);\n" }{MPLTEXT 1 202 10 "end proc
:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 69 "# x_to_sM gets a mono
mial and transforms it back into an S-function.\n" }{MPLTEXT 1 202 75 
"#         This transformation is critical, since the transformation m
atrix\n" }{MPLTEXT 1 202 72 "#         K is rectangular! The inverse i
s computes on the maximal rank\n" }{MPLTEXT 1 202 71 "#         subspa
ce, and suitably normalized, so that the collextion of\n" }{MPLTEXT 1 
202 68 "#         *all* x monomials which give rise to the same S-func
tions\n" }{MPLTEXT 1 202 41 "#         adds up to the integral result
\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 62 "#         <internal us
e; users use the linear version x_to_s>\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 20 "x_to_sM:=proc(xfkt)\n" }{MPLTEXT 1 202 83 "  option
 `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserv
ed.`\n" }{MPLTEXT 1 202 20 "         ,remember;\n" }{MPLTEXT 1 202 40 
"  local wgt,prt,KMat,tab,tabc,cmp,matT;\n" }{MPLTEXT 1 202 22 "  wgt:
=`+`(op(xfkt));\n" }{MPLTEXT 1 202 24 "  prt:=PartNM(wgt,wgt);\n" }
{MPLTEXT 1 202 89 "  KMat :=evalm(linalg[matrix](nops(prt),nops(prt),(
i,j)->KostkaPC(prt[i],prt[j]))^(-1));\n" }{MPLTEXT 1 202 48 "  tab:=ta
ble([seq((prt[k])=k,k=1..nops(prt))]);\n" }{MPLTEXT 1 202 37 "  cmp:=C
ompNM(wgt,nops([op(xfkt)]));\n" }{MPLTEXT 1 202 44 "  matT:=linalg[mat
rix](nops(cmp),nops(prt),\n" }{MPLTEXT 1 202 78 "       (i,j)->1/cmp2p
rtMult(cmp[i])*KMat[tab[cmp2part(cmp[i])],tab[prt[j]]]);\n" }{MPLTEXT 
1 202 17 "  ## new index  \n" }{MPLTEXT 1 202 64 "  tabc:=1; while [op
(xfkt)]<>cmp[tabc] do tabc:=tabc+1; end do;\n" }{MPLTEXT 1 202 50 "  a
dd(matT[tabc,k]*s[op(prt[k])],k=1..nops(prt));\n" }{MPLTEXT 1 202 10 "
end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 76 "# s_to_x line
ar version of the transformation of S functions to x monomials\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 26 "s_to_x:=proc(sfkt,weight)\n
" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ablamowic
z 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 20 "          r
emember;\n" }{MPLTEXT 1 202 21 "  local cf,term,lst;\n" }{MPLTEXT 1 
202 36 "  if weight=0 then return 1 end if;\n" }{MPLTEXT 1 202 18 "  i
f sfkt=0 then \n" }{MPLTEXT 1 202 14 "    return 0;\n" }{MPLTEXT 1 
202 28 "  elif type(sfkt,`+`) then \n" }{MPLTEXT 1 202 37 "    return \+
map(procname,sfkt,weight)\n" }{MPLTEXT 1 202 27 "  elif type(sfkt,`*`)
 then\n" }{MPLTEXT 1 202 48 "    term,cf:=selectremove(type,sfkt,sfktm
onom);\n" }{MPLTEXT 1 202 36 "    return cf*procname(term,weight)\n" }
{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 26 "    s_to_xM(sfkt,weigh
t);\n" }{MPLTEXT 1 202 11 "  end if; \n" }{MPLTEXT 1 202 10 "end proc:
\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 76 "# x_to_s linear versio
n of the transformation of x monomials to S functions\n" }{MPLTEXT 1 
202 2 "#\n" }{MPLTEXT 1 202 19 "x_to_s:=proc(xfkt)\n" }{MPLTEXT 1 202 
84 "  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All r
ights reserved.`,\n" }{MPLTEXT 1 202 20 "          remember;\n" }
{MPLTEXT 1 202 21 "  local cf,term,lst;\n" }{MPLTEXT 1 202 26 "  if ty
pe(xfkt,`+`) then \n" }{MPLTEXT 1 202 30 "    return map(procname,xfkt
)\n" }{MPLTEXT 1 202 27 "  elif type(xfkt,`*`) then\n" }{MPLTEXT 1 
202 61 "    cf,term:=selectremove(type,xfkt,\{'integer','fraction'\});
\n" }{MPLTEXT 1 202 29 "    return cf*procname(term)\n" }{MPLTEXT 1 
202 7 "  else\n" }{MPLTEXT 1 202 19 "    x_to_sM(xfkt);\n" }{MPLTEXT 
1 202 11 "  end if; \n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 
202 80 "##############################################################
#################\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 82 "# h_t
o_s transformes a complete symmetric function into an s-function polyn
omial.\n" }{MPLTEXT 1 202 10 "#        \n" }{MPLTEXT 1 202 20 "h_to_sM
:=proc(hfkt)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser \+
& R. Ablamowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 
20 "          remember;\n" }{MPLTEXT 1 202 34 "  if hfkt=0 then return
 0 end if;\n" }{MPLTEXT 1 202 38 "  outer(op(map(i->s[i],[op(hfkt)])))
;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 19 "h_to_s:=proc
(hfkt)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. A
blamowicz 2004-2009. All rights reserved.`;\n" }{MPLTEXT 1 202 28 "  l
ocal n1,prt,cf,term,lst;\n" }{MPLTEXT 1 202 34 "  if hfkt=0 then retur
n 0 end if;\n" }{MPLTEXT 1 202 38 "  if not type(hfkt,hfktpolynom) the
n \n" }{MPLTEXT 1 202 72 "     error(\"wrong basis as input, need comp
lete symmetric functions\"); \n" }{MPLTEXT 1 202 10 "  end if;\n" }
{MPLTEXT 1 202 40 "  if hfkt=h[0] then return s[0] end if;\n" }
{MPLTEXT 1 202 26 "  if type(hfkt,`+`) then \n" }{MPLTEXT 1 202 30 "  \+
  return map(procname,hfkt)\n" }{MPLTEXT 1 202 27 "  elif type(hfkt,`*
`) then\n" }{MPLTEXT 1 202 48 "    term,cf:=selectremove(type,hfkt,hfk
tmonom);\n" }{MPLTEXT 1 202 29 "    return cf*procname(term)\n" }
{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 25 "    return h_to_sM(hfk
t)\n" }{MPLTEXT 1 202 11 "  end if; \n" }{MPLTEXT 1 202 10 "end proc:
\n" }{MPLTEXT 1 202 80 "##############################################
#################################\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT
 1 202 80 "# s_to_h transformes a s-function polynomial into complete \+
symmetric functions.\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 49 "# \+
WARNING: SLOW!! Uses the inverse Kostka Matrix\n" }{MPLTEXT 1 202 48 "
#          better use the Jacobi-Trudi formula!\n" }{MPLTEXT 1 202 10 
"#        \n" }{MPLTEXT 1 202 20 "s_to_hM:=proc(sfkt)\n" }{MPLTEXT 1 
202 84 "  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. A
ll rights reserved.`,\n" }{MPLTEXT 1 202 20 "          remember;\n" }
{MPLTEXT 1 202 20 "  local prt,N,KI,i;\n" }{MPLTEXT 1 202 51 "  KI:=ev
alm(rhs(KostkaTable(`+`(op(sfkt))))^(-1));\n" }{MPLTEXT 1 202 20 "  N:
=`+`(op(sfkt));\n" }{MPLTEXT 1 202 20 "  prt:=PartNM(N,N);\n" }
{MPLTEXT 1 202 51 "  i:=1: while prt[i]<>[op(sfkt)] do i:=i+1 end do;
\n" }{MPLTEXT 1 202 45 "  add(KI[j,i]*h[op(prt[j])],j=1..nops(prt));\n
" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 22 "s_to_hMat:=proc
(sfkt)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. A
blamowicz 2004-2009. All rights reserved.`;\n" }{MPLTEXT 1 202 28 "  l
ocal n1,prt,cf,term,lst;\n" }{MPLTEXT 1 202 34 "  if sfkt=0 then retur
n 0 end if;\n" }{MPLTEXT 1 202 40 "  if sfkt=s[0] then return h[0] end
 if;\n" }{MPLTEXT 1 202 26 "  if type(sfkt,`+`) then \n" }{MPLTEXT 1 
202 30 "    return map(procname,sfkt)\n" }{MPLTEXT 1 202 27 "  elif ty
pe(sfkt,`*`) then\n" }{MPLTEXT 1 202 48 "    term,cf:=selectremove(typ
e,sfkt,sfktmonom);\n" }{MPLTEXT 1 202 29 "    return cf*procname(term)
\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 25 "    return s_to_h
M(sfkt)\n" }{MPLTEXT 1 202 11 "  end if; \n" }{MPLTEXT 1 202 10 "end p
roc:\n" }{MPLTEXT 1 202 80 "##########################################
#####################################\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 34 "# s_to_h recursive faster version\n" }{MPLTEXT 1 
202 2 "#\n" }{MPLTEXT 1 202 16 "s_to_h:=proc(x)\n" }{MPLTEXT 1 202 84 
"  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All righ
ts reserved.`,\n" }{MPLTEXT 1 202 12 "  remember;\n" }{MPLTEXT 1 202 
17 "  local term,cf;\n" }{MPLTEXT 1 202 31 "  if x=0 then return 0 end
 if;\n" }{MPLTEXT 1 202 37 "  if x=s[0] then return h[0] end if;\n" }
{MPLTEXT 1 202 22 "  if type(x,`+`) then\n" }{MPLTEXT 1 202 21 "     m
ap(procname,x)\n" }{MPLTEXT 1 202 24 "  elif type(x,`*`) then\n" }
{MPLTEXT 1 202 45 "    term,cf:=selectremove(type,x,sfktmonom);\n" }
{MPLTEXT 1 202 30 "    return cf*procname(term);\n" }{MPLTEXT 1 202 7 
"  else\n" }{MPLTEXT 1 202 52 "    return h[op(x)] + procname(x-h_to_s
(h[op(x)]));\n" }{MPLTEXT 1 202 7 "  end;\n" }{MPLTEXT 1 202 10 "end p
roc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 80 "##################
#############################################################\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 72 "# sfktmon_to_hmatrix transf
orms a sfktmonom (Schur basis function) into\n" }{MPLTEXT 1 202 72 "# \+
  -- a matrix in such a way, that the determinant of the matrix w.r.t
\n" }{MPLTEXT 1 202 63 "#   -- the outer product yields back the Schur
 function monom.\n" }{MPLTEXT 1 202 73 "#   -- the entries of the matr
ix are one part Schur functions, and hence\n" }{MPLTEXT 1 202 81 "#   \+
-- can be multiplies by teh outer product in teh complete symmetric fu
nction\n" }{MPLTEXT 1 202 70 "#   -- basis, this gives teh Jacobi-Trud
i formula for Schur functions\n" }{MPLTEXT 1 202 44 "#   -- s_\\lambda
 = det( h_[\\lambda_i-i+j]) \n" }{MPLTEXT 1 202 74 "#   -- (there is a
 similar formula for the elementray symetric functions)\n" }{MPLTEXT 
1 202 2 "#\n" }{MPLTEXT 1 202 28 "sfktmon_to_hmatrix:=proc(x)\n" }
{MPLTEXT 1 202 21 "  local l,f,dim,lst;\n" }{MPLTEXT 1 202 26 "  l,dim
:=nops([op(x)]),0;\n" }{MPLTEXT 1 202 44 "  if nargs=2 then l:=max(l,a
rgs[2]) end if;\n" }{MPLTEXT 1 202 36 "  lst:=[op(x),0$(l-nops([op(x)]
))];\n" }{MPLTEXT 1 202 42 "  f:=(x)->if x<0 then 0 else h[x] end if;
\n" }{MPLTEXT 1 202 51 "  evalm(linalg[matrix](l,l,(i,j)->f(lst[i]-i+j
)));\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 80 "# s_to_hmat transforms an sfunction into a Toeplitz
 matrix of complete one part\n" }{MPLTEXT 1 202 82 "#    -- symmetric \+
functions. It takes as a second argument a dimension, which can\n" }
{MPLTEXT 1 202 88 "#    -- be taken to be the largest length of all in
volved partitions in teh sfktpolynom\n" }{MPLTEXT 1 202 40 "#    -- se
e : \"maxlengthSymFkt()\" below\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 
1 202 19 "s_to_hmat:=proc(x)\n" }{MPLTEXT 1 202 84 "  option `Copyrigh
t (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n" }
{MPLTEXT 1 202 12 "  remember;\n" }{MPLTEXT 1 202 19 "  local cf,tm,di
m;\n" }{MPLTEXT 1 202 54 "  if nargs=2 then dim:=args[2] else dim:=NUL
L end if;\n" }{MPLTEXT 1 202 23 "  if type(x,`+`) then \n" }{MPLTEXT 
1 202 32 "    return map(procname,x,dim);\n" }{MPLTEXT 1 202 25 "  eli
f type(x,`*`) then \n" }{MPLTEXT 1 202 43 "    tm,cf:=selectremove(typ
e,x,sfktmonom);\n" }{MPLTEXT 1 202 31 "    return cf*procname(tm,dim)
\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 33 "    sfktmon_to_hm
atrix(x,dim);  \n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 
10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 84 "# evalJac
obiTrudiMatrix given an Jacobi-Trudin matrix (say from sfktmon_to_hmat
rix)\n" }{MPLTEXT 1 202 81 "#    -- this function evaluates the determ
inant w.r.t. the outer product in the \n" }{MPLTEXT 1 202 43 "#    -- \+
complete symmetric function basis.\n" }{MPLTEXT 1 202 65 "#    -- NOTE
: one can give a multiplication as second argument! \n" }{MPLTEXT 1 
202 2 "#\n" }{MPLTEXT 1 202 36 "evalJacobiTrudiMatrix:=proc(matrix)\n"
 }{MPLTEXT 1 202 28 "  local mdim,lst,i,k,l,fun;\n" }{MPLTEXT 1 202 
56 "  if nargs=2 then fun:=args[2] else fun:=outerH end if;\n" }
{MPLTEXT 1 202 32 "  mdim:=linalg[rowdim](matrix);\n" }{MPLTEXT 1 202 
44 "  if mdim=1 then return matrix[1,1] end if;\n" }{MPLTEXT 1 202 27 
"  lst:=[seq(i,i=1..mdim)];\n" }{MPLTEXT 1 202 41 "  add((-1)^(i-1)*ex
pand(fun(matrix[i,1],\n" }{MPLTEXT 1 202 35 "       procname(linalg[su
bmatrix](\n" }{MPLTEXT 1 202 78 "     matrix,map(x->if x=i then NULL e
lse x end if,lst),[seq(k,k=2..mdim)]))))\n" }{MPLTEXT 1 202 18 "     ,
i=1..mdim);\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n
" }{MPLTEXT 1 202 78 "# s_to_hJT linear version of the transition from
 the s-basis into the h-basis\n" }{MPLTEXT 1 202 39 "#   -- useing the
 Jacobi-Trudi formula\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 18 "s
_to_hJT:=proc(x)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fau
ser & R. Ablamowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 
202 12 "  remember;\n" }{MPLTEXT 1 202 19 "  local cf,tm,fun;\n" }
{MPLTEXT 1 202 56 "  if nargs=2 then fun:=args[2] else fun:=outerH end
 if;\n" }{MPLTEXT 1 202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 202 
28 "    return map(procname,x);\n" }{MPLTEXT 1 202 25 "  elif type(x,`
*`) then \n" }{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,x,sfktmo
nom);\n" }{MPLTEXT 1 202 27 "    return cf*procname(tm)\n" }{MPLTEXT 
1 202 7 "  else\n" }{MPLTEXT 1 202 56 "    evalJacobiTrudiMatrix(sfktm
on_to_hmatrix(x),fun);  \n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT
 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 69 "# \+
maxlengthSymFkt gives the maximal length of a partition index in a\n" 
}{MPLTEXT 1 202 42 "#  -- symfktpolynom of type \{s,p,m,h,f,e\}\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 25 "max
lengthSymFkt:=proc(x)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B
. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n" }
{MPLTEXT 1 202 12 "  remember;\n" }{MPLTEXT 1 202 15 "  local cf,tm;\n
" }{MPLTEXT 1 202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 202 43 "  \+
  return max(op(map(procname,[op(x)])));\n" }{MPLTEXT 1 202 25 "  elif
 type(x,`*`) then \n" }{MPLTEXT 1 202 45 "    tm,cf:=selectremove(type
,x,symfktmonom);\n" }{MPLTEXT 1 202 26 "    return nops([op(tm)])\n" }
{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 27 "    return nops([op(x)
])  \n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:
\n" }{MPLTEXT 1 202 80 "##############################################
#################################\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT
 1 202 77 "# etoh is the transition from elementary to complete symmet
ric functions for\n" }{MPLTEXT 1 202 80 "#     -- one part elementary \+
symmetric functions e_n. It is done using the fact\n" }{MPLTEXT 1 202 
91 "#     -- that the generating functions H_t=\\sum_n \{n]t^n and E_-
t = \\sum_m (-1)^m \{1^m\}t^m\n" }{MPLTEXT 1 202 69 "#     -- are inve
rse series under the pointwise product of functions\n" }{MPLTEXT 1 
202 65 "#     -- Note: H_t = M_t and E_-t = M_t[-s_1] = \\sum_n S(\{n
\})t^n\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 14 "etoh:=proc(x)\n"
 }{MPLTEXT 1 202 11 "  local n;\n" }{MPLTEXT 1 202 12 "  n:=op(x);\n" 
}{MPLTEXT 1 202 60 "  if n=1 then return h[1] elif n=0 then return h[0
] end if;\n" }{MPLTEXT 1 202 60 "  add((-1)^(n-r-1)*outerH(h[n-r],proc
name(e[r])),r=0..n-1);\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 
1 202 2 "#\n" }{MPLTEXT 1 202 88 "# e_to_hM is the basis change e_to_h
 on a single efktmonom, it uses the fact that the '\n" }{MPLTEXT 1 
202 86 "#     -- elementary symmetric functions for a multiplicative b
asis and employs `etoh'\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 17 
"e_to_hM:=proc(x)\n" }{MPLTEXT 1 202 13 "  local prt;\n" }{MPLTEXT 1 
202 16 "  prt:=[op(x)];\n" }{MPLTEXT 1 202 41 "  outerH(op(map(etoh,ma
p(x->[x],prt))));\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 
2 "#\n" }{MPLTEXT 1 202 94 "# e_to_h linear version of the transformat
ion of elementary functions into complete functions\n" }{MPLTEXT 1 
202 2 "#\n" }{MPLTEXT 1 202 19 "e_to_h:=proc(efkt)\n" }{MPLTEXT 1 202 
21 "  local cf,term,lst;\n" }{MPLTEXT 1 202 34 "  if efkt=0 then retur
n 0 end if;\n" }{MPLTEXT 1 202 40 "  if efkt=e[0] then return h[0] end
 if;\n" }{MPLTEXT 1 202 26 "  if type(efkt,`+`) then \n" }{MPLTEXT 1 
202 30 "    return map(procname,efkt)\n" }{MPLTEXT 1 202 27 "  elif ty
pe(efkt,`*`) then\n" }{MPLTEXT 1 202 48 "    term,cf:=selectremove(typ
e,efkt,efktmonom);\n" }{MPLTEXT 1 202 29 "    return cf*procname(term)
\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 19 "    e_to_hM(efkt)
;\n" }{MPLTEXT 1 202 11 "  end if; \n" }{MPLTEXT 1 202 10 "end proc:\n
" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 89 "# e_to_sM is the transit
ion from elementary symmetric function monoms to Schur functions\n" }
{MPLTEXT 1 202 57 "#    -- it uses the fact that e_k=s[1,1,...,1] (k o
nes) \n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 17 "e_to_sM:=proc(x)
\n" }{MPLTEXT 1 202 31 "  if x=0 then return 0 end if;\n" }{MPLTEXT 1 
202 37 "  if x=e[0] then return s[0] end if;\n" }{MPLTEXT 1 202 40 "  \+
outerS(op(map((x)->s[1$x],[op(x)])));\n" }{MPLTEXT 1 202 10 "end proc:
\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 91 "# e_to_s linear versio
n of the transformation of elementary functions into Schur functions\n
" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 19 "e_to_s:=proc(efkt)\n" }
{MPLTEXT 1 202 21 "  local cf,term,lst;\n" }{MPLTEXT 1 202 26 "  if ty
pe(efkt,`+`) then \n" }{MPLTEXT 1 202 30 "    return map(procname,efkt
)\n" }{MPLTEXT 1 202 27 "  elif type(efkt,`*`) then\n" }{MPLTEXT 1 
202 48 "    term,cf:=selectremove(type,efkt,efktmonom);\n" }{MPLTEXT 
1 202 29 "    return cf*procname(term)\n" }{MPLTEXT 1 202 7 "  else\n"
 }{MPLTEXT 1 202 19 "    e_to_sM(efkt);\n" }{MPLTEXT 1 202 11 "  end i
f; \n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 64 "# e_to_mM ist the basis change from e-fkt to m-fkt \+
on monomials\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 17 "e_to_mM:=p
roc(x)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. A
blamowicz 2004-2009. All rights reserved.`;\n" }{MPLTEXT 1 202 13 "  l
ocal lst;\n" }{MPLTEXT 1 202 16 "  lst:=[op(x)];\n" }{MPLTEXT 1 202 
34 "  outerM(op(map(x->m[1$x],lst)));\n" }{MPLTEXT 1 202 10 "end proc:
\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 75 "# e_to_m is the linear
 basis change from elementary symmetric functions to\n" }{MPLTEXT 1 
202 38 "#        monomial symmetric functions\n" }{MPLTEXT 1 202 2 "#
\n" }{MPLTEXT 1 202 16 "e_to_m:=proc(x)\n" }{MPLTEXT 1 202 85 "   opti
on `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights rese
rved.`,\n" }{MPLTEXT 1 202 20 "          remember;\n" }{MPLTEXT 1 202 
16 "   local cf,tm;\n" }{MPLTEXT 1 202 32 "   if x=0 then return 0 end
 if;\n" }{MPLTEXT 1 202 38 "   if x=e[0] then return m[0] end if;\n" }
{MPLTEXT 1 202 24 "   if type(x,`+`) then \n" }{MPLTEXT 1 202 29 "    \+
 return map(procname,x);\n" }{MPLTEXT 1 202 26 "   elif type(x,`*`) th
en \n" }{MPLTEXT 1 202 44 "     tm,cf:=selectremove(type,x,efktmonom);
\n" }{MPLTEXT 1 202 30 "     return cf*procname(tm,x)\n" }{MPLTEXT 1 
202 8 "   else\n" }{MPLTEXT 1 202 19 "     e_to_mM(x);  \n" }{MPLTEXT 
1 202 11 "   end if;\n" }{MPLTEXT 1 202 11 " end proc:\n" }{MPLTEXT 1 
202 80 "##############################################################
#################\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 84 "# h_t
o_mM is the basis transformation from complete to monomials ymmetric f
unctions\n" }{MPLTEXT 1 202 83 "#   -- it is computed along the lines \+
of Rota-Stein using the multiplicativity of \n" }{MPLTEXT 1 202 76 "# \+
  -- the complete basis. The coproduct is used in disguise in the form
ula\n" }{MPLTEXT 1 202 80 "#   -- h_(n) = \\sum_\{\\mu|-n\} m_\\mu, an
d the multiplicativity is translated into\n" }{MPLTEXT 1 202 45 "#   -
- the nonmultiplicative outerM product.\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 17 "h_to_mM:=proc(x)\n" }{MPLTEXT 1 202 84 "  option `C
opyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.
`,\n" }{MPLTEXT 1 202 20 "          remember;\n" }{MPLTEXT 1 202 15 " \+
 local lst,f;\n" }{MPLTEXT 1 202 15 "  if x=0 then \n" }{MPLTEXT 1 
202 13 "    return 0\n" }{MPLTEXT 1 202 19 "  elif x=h[0] then\n" }
{MPLTEXT 1 202 16 "    return m[0]\n" }{MPLTEXT 1 202 10 "  end if;\n"
 }{MPLTEXT 1 202 60 "  #  -- h(n) = \\sum_rho p[rho] = \\sum_\\rho \\p
rod_i p[rho_i]\n" }{MPLTEXT 1 202 27 "  #  -- and use p(n)==m(n)\n" }
{MPLTEXT 1 202 39 "  f:=(x)->add(m[op(i)],i=PartNM(x,x));\n" }{MPLTEXT
 1 202 16 "  lst:=[op(x)];\n" }{MPLTEXT 1 202 26 "  outerM(op(map(f,ls
t)));\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 92 "# h_to_m linear version of the transformation of co
mplete functions into monomial functions\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 19 "h_to_m:=proc(hfkt)\n" }{MPLTEXT 1 202 85 "   option
 `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserv
ed.`;\n" }{MPLTEXT 1 202 21 "  local cf,term,lst;\n" }{MPLTEXT 1 202 
26 "  if type(hfkt,`+`) then \n" }{MPLTEXT 1 202 30 "    return map(pr
ocname,hfkt)\n" }{MPLTEXT 1 202 27 "  elif type(hfkt,`*`) then\n" }
{MPLTEXT 1 202 48 "    term,cf:=selectremove(type,hfkt,hfktmonom);\n" 
}{MPLTEXT 1 202 29 "    return cf*procname(term)\n" }{MPLTEXT 1 202 7 
"  else\n" }{MPLTEXT 1 202 19 "    h_to_mM(hfkt);\n" }{MPLTEXT 1 202 
11 "  end if; \n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "
#\n" }{MPLTEXT 1 202 66 "# h_to_pM is the transformation from h-basis \+
monomials to p-bases\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 17 "h_
to_pM:=proc(x)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fause
r & R. Ablamowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 
202 19 "         remember;\n" }{MPLTEXT 1 202 15 "  local lst,f;\n" }
{MPLTEXT 1 202 39 "  f:=(x)->add(p[op(i)],i=PartNM(x,x));\n" }{MPLTEXT
 1 202 15 "  if x=0 then \n" }{MPLTEXT 1 202 13 "    return 0\n" }
{MPLTEXT 1 202 19 "  elif x=h[0] then\n" }{MPLTEXT 1 202 16 "    retur
n m[0]\n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 16 "  lst:=
[op(x)];\n" }{MPLTEXT 1 202 27 "  outerP(op(map(f,lst))); \n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 84 "# h_to_p linear version of the transformation of complete func
tions into power sums\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 19 "h
_to_p:=proc(hfkt)\n" }{MPLTEXT 1 202 85 "   option `Copyright (c) B. F
auser & R. Ablamowicz 2004-2009. All rights reserved.`;\n" }{MPLTEXT 
1 202 21 "  local cf,term,lst;\n" }{MPLTEXT 1 202 26 "  if type(hfkt,`
+`) then \n" }{MPLTEXT 1 202 30 "    return map(procname,hfkt)\n" }
{MPLTEXT 1 202 27 "  elif type(hfkt,`*`) then\n" }{MPLTEXT 1 202 48 " \+
   term,cf:=selectremove(type,hfkt,hfktmonom);\n" }{MPLTEXT 1 202 29 "
    return cf*procname(term)\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT
 1 202 19 "    h_to_pM(hfkt);\n" }{MPLTEXT 1 202 11 "  end if; \n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 80 "##################
#############################################################\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 75 "# p_to_s transformes a powe
r sum polynomial into an s-function polynomial.\n" }{MPLTEXT 1 202 48 
"#        This version was checked against SCHUR\n" }{MPLTEXT 1 202 2 
"#\n" }{MPLTEXT 1 202 19 "p_to_s:=proc(pfkt)\n" }{MPLTEXT 1 202 84 "  \+
option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights \+
reserved.`;\n" }{MPLTEXT 1 202 28 "  local n1,prt,cf,term,lst;\n" }
{MPLTEXT 1 202 34 "  if pfkt=0 then return 0 end if;\n" }{MPLTEXT 1 
202 52 "  if pfkt=p[0] or pfkt=p[] then return s[0] end if;\n" }
{MPLTEXT 1 202 26 "  if type(pfkt,`+`) then \n" }{MPLTEXT 1 202 30 "  \+
  return map(procname,pfkt)\n" }{MPLTEXT 1 202 27 "  elif type(pfkt,`*
`) then\n" }{MPLTEXT 1 202 48 "    term,cf:=selectremove(type,pfkt,pfk
tmonom);\n" }{MPLTEXT 1 202 29 "    return cf*procname(term)\n" }
{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 26 "    n1:=`+`(op(pfkt));
   \n" }{MPLTEXT 1 202 24 "    prt:=PartNM(n1,n1);\n" }{MPLTEXT 1 202 
46 "    add(s[op(i)]*MurNak([op(pfkt)],i),i=prt);\n" }{MPLTEXT 1 202 
11 "  end if; \n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 80 
"#####################################################################
##########\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 81 "# p_to_s rec
ursive version INACTIVE about 10 times slower than the combinatorial\n
" }{MPLTEXT 1 202 51 "#        version using the Murnaghan Nakayama ru
le\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 80 "####################
###########################################################\n" }
{MPLTEXT 1 202 18 "#p_to_sM:=proc(x)\n" }{MPLTEXT 1 202 20 "#  option \+
remember;\n" }{MPLTEXT 1 202 16 "#  local k,lst;\n" }{MPLTEXT 1 202 
32 "#  if x=0 then return 0 end if;\n" }{MPLTEXT 1 202 27 "#  if nops(
[op(x)])=1 then\n" }{MPLTEXT 1 202 62 "#    return s[op(x)]+add((-1)^k
*s[op(x)-k,1$k],k=1..op(x)-1);\n" }{MPLTEXT 1 202 8 "#  else\n" }
{MPLTEXT 1 202 19 "#    lst:=[op(x)];\n" }{MPLTEXT 1 202 88 "#    retu
rn outer(op(map((a)->s[op(a)]+add((-1)^k*s[op(a)-k,1$k],k=1..op(a)-1) \+
,lst)));\n" }{MPLTEXT 1 202 11 "#  end if;\n" }{MPLTEXT 1 202 11 "#end
 proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 18 "#p_to_s2:=proc(x
)\n" }{MPLTEXT 1 202 18 "#  local cf,term;\n" }{MPLTEXT 1 202 32 "#  i
f x=0 then return 0 end if;\n" }{MPLTEXT 1 202 23 "#  if type(x,`+`) t
hen\n" }{MPLTEXT 1 202 29 "#    return map(procname,x);\n" }{MPLTEXT 
1 202 25 "#  elif type(x,`*`) then\n" }{MPLTEXT 1 202 46 "#    term,cf
:=selectremove(type,x,pfktmonom);\n" }{MPLTEXT 1 202 39 "#    return e
xpand(cf*procname(term));\n" }{MPLTEXT 1 202 8 "#  else\n" }{MPLTEXT 
1 202 24 "#    return p_to_sM(x);\n" }{MPLTEXT 1 202 11 "#  end if;\n"
 }{MPLTEXT 1 202 11 "#end proc:\n" }{MPLTEXT 1 202 81 "###############
#################################################################\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 52 "# s_to_p transformes an s-f
unction into power sums.\n" }{MPLTEXT 1 202 63 "#        This version \+
was checked against SCHUR, but *differs*\n" }{MPLTEXT 1 202 67 "#     \+
   in that effect, that it does not introduce an artificial \n" }
{MPLTEXT 1 202 53 "#        factor n! to avaoid fractional coefficient
s\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 
19 "s_to_p:=proc(xfkt)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) \+
B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;\n" }
{MPLTEXT 1 202 34 "  local cf,term,lst,mat,np,prt,i;\n" }{MPLTEXT 1 
202 34 "  if xfkt=0 then return 0 end if;\n" }{MPLTEXT 1 202 40 "  if \+
xfkt=s[0] then return p[0] end if;\n" }{MPLTEXT 1 202 26 "  if type(xf
kt,`+`) then \n" }{MPLTEXT 1 202 30 "    return map(procname,xfkt)\n" 
}{MPLTEXT 1 202 27 "  elif type(xfkt,`*`) then\n" }{MPLTEXT 1 202 48 "
    term,cf:=selectremove(type,xfkt,sfktmonom);\n" }{MPLTEXT 1 202 29 
"    return cf*procname(term)\n" }{MPLTEXT 1 202 7 "  else\n" }
{MPLTEXT 1 202 23 "    np:=`+`(op(xfkt));\n" }{MPLTEXT 1 202 27 "    p
rt:=PartNM(np,np);   \n" }{MPLTEXT 1 202 10 "    i:=1:\n" }{MPLTEXT 1 
202 47 "    while prt[i]<>[op(xfkt)] do i:=i+1 end do;\n" }{MPLTEXT 1 
202 6 "    #\n" }{MPLTEXT 1 202 80 "    #+++ use the Murnaghan-Nakayam
a rules directly without the matrix inversion\n" }{MPLTEXT 1 202 6 "  \+
  #\n" }{MPLTEXT 1 202 75 "    add(1/zee(prt[k])*MurNak(prt[k],prt[i])
*p[op(prt[k])],k=1..nops(prt));\n" }{MPLTEXT 1 202 11 "  end if; \n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 80 "##################
#############################################################\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 82 "# s_to_e transformes a s-fu
nction polynomial into elementary symmetric functions.\n" }{MPLTEXT 1 
202 2 "#\n" }{MPLTEXT 1 202 19 "s_to_e:=proc(sfkt)\n" }{MPLTEXT 1 202 
17 "  local cf,term;\n" }{MPLTEXT 1 202 34 "  if sfkt=0 then return 0 \+
end if;\n" }{MPLTEXT 1 202 40 "  if sfkt=s[0] then return e[0] end if;
\n" }{MPLTEXT 1 202 25 "  if type(sfkt,`+`) then\n" }{MPLTEXT 1 202 
32 "     return map(procname,sfkt);\n" }{MPLTEXT 1 202 27 "  elif type
(sfkt,`*`) then\n" }{MPLTEXT 1 202 49 "     term,cf:=selectremove(type
,sfkt,sfktmonom);\n" }{MPLTEXT 1 202 31 "     return cf*procname(term)
;\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 76 "     if `+`(op(s
fkt))=nops([op(sfkt)]) then return e[`+`(op(sfkt))] end if;\n" }
{MPLTEXT 1 202 92 "     return e[op(conjpart([op(sfkt)]))]+procname(sf
kt-e_to_s(e[op(conjpart([op(sfkt)]))]));\n" }{MPLTEXT 1 202 10 "  end \+
if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 76 "# s_to_mM basis change from Schur functions to mono
mial symmetric functions\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 
20 "s_to_mM:=proc(sfkt)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c)
 B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n" }
{MPLTEXT 1 202 19 "         remember;\n" }{MPLTEXT 1 202 18 "  local p
rt,pt,k;\n" }{MPLTEXT 1 202 18 "  if sfkt=0 then \n" }{MPLTEXT 1 202 
13 "    return 0\n" }{MPLTEXT 1 202 23 "  elif sfkt=s[0] then \n" }
{MPLTEXT 1 202 17 "    return m[0];\n" }{MPLTEXT 1 202 7 "  else\n" }
{MPLTEXT 1 202 46 "    prt:=PartNM(`+`(op(sfkt)),`+`(op(sfkt)));\n" }
{MPLTEXT 1 202 83 "    add(subs(s[0]=1,Scalar(sfkt,outer(op(map(k->s[k
],pt)))))*m[op(pt)], pt in prt)\n" }{MPLTEXT 1 202 10 "  end if;\n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 82 "# s_to_m linear basis change from Schur functions to monomial \+
symmetric functions\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 16 "s_t
o_m:=proc(x)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser \+
& R. Ablamowicz 2004-2009. All rights reserved.`;\n" }{MPLTEXT 1 202 
15 "  local cf,tm;\n" }{MPLTEXT 1 202 23 "  if type(x,`+`) then \n" }
{MPLTEXT 1 202 28 "    return map(procname,x);\n" }{MPLTEXT 1 202 25 "
  elif type(x,`*`) then \n" }{MPLTEXT 1 202 43 "    tm,cf:=selectremov
e(type,x,sfktmonom);\n" }{MPLTEXT 1 202 35 "    return expand(cf*procn
ame(tm))\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 20 "    s_to_
mM(x,N);  \n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end
 proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 56 "# m_to_sM basis \+
change from monomial to Schur functions\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 20 "m_to_sM:=proc(mfkt)\n" }{MPLTEXT 1 202 84 "  option
 `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserv
ed.`,\n" }{MPLTEXT 1 202 19 "         remember;\n" }{MPLTEXT 1 202 18 
"  local prt,pt,k;\n" }{MPLTEXT 1 202 18 "  if mfkt=0 then \n" }
{MPLTEXT 1 202 13 "    return 0\n" }{MPLTEXT 1 202 23 "  elif mfkt=m[0
] then \n" }{MPLTEXT 1 202 17 "    return s[0];\n" }{MPLTEXT 1 202 7 "
  else\n" }{MPLTEXT 1 202 46 "    prt:=PartNM(`+`(op(mfkt)),`+`(op(mfk
t)));\n" }{MPLTEXT 1 202 76 "    add(subs(s[0]=1,ScalarMH(mfkt,s_to_h(
s[op(pt)])))*s[op(pt)], pt in prt)\n" }{MPLTEXT 1 202 10 "  end if;\n"
 }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 62 "# m_to_s linear basis change from monomial to Schur functions
\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 16 "m_to_s:=proc(x)\n" }
{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ablamowicz 2
004-2009. All rights reserved.`;\n" }{MPLTEXT 1 202 15 "  local cf,tm;
\n" }{MPLTEXT 1 202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 202 28 "
    return map(procname,x);\n" }{MPLTEXT 1 202 25 "  elif type(x,`*`) \+
then \n" }{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,x,mfktmonom)
;\n" }{MPLTEXT 1 202 35 "    return expand(cf*procname(tm))\n" }
{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 20 "    m_to_sM(x,N);  \n"
 }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 85 "# p_to_mM is an internal fu
nction computing the transition from a power sum monomial\n" }{MPLTEXT
 1 202 65 "#         into a monomial symmetric function. Internal use \+
only.\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 17 "p_to_mM:=proc(x)
\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ablamow
icz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 20 "         \+
 remember;\n" }{MPLTEXT 1 202 31 "  if x=0 then return 0 end if;\n" }
{MPLTEXT 1 202 46 "  if nops([op(x)])<1 then return m[0] end if;\n" }
{MPLTEXT 1 202 52 "  outerM(seq(m[op([op(x)][k])],k=1..nops([op(x)])))
\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT
 1 202 84 "# p_to_m linear version of the transformation of power sums
 into monomial functions\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 
19 "p_to_m:=proc(pfkt)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) \+
B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;\n" }
{MPLTEXT 1 202 21 "  local cf,term,lst;\n" }{MPLTEXT 1 202 26 "  if ty
pe(pfkt,`+`) then \n" }{MPLTEXT 1 202 30 "    return map(procname,pfkt
)\n" }{MPLTEXT 1 202 27 "  elif type(pfkt,`*`) then\n" }{MPLTEXT 1 
202 48 "    term,cf:=selectremove(type,pfkt,pfktmonom);\n" }{MPLTEXT 
1 202 29 "    return cf*procname(term)\n" }{MPLTEXT 1 202 7 "  else\n"
 }{MPLTEXT 1 202 19 "    p_to_mM(pfkt);\n" }{MPLTEXT 1 202 11 "  end i
f; \n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 87 "# m_to_pM transferes monomial symmetric function ba
sis monoms into power sum symmetric\n" }{MPLTEXT 1 202 41 "#         f
unctions. Internal use only. \n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 90 "# SLOW!! This routine uses matrix inversion and not a direct c
ombinatorial algorithm !!! \n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 20 "m_to_pM:=proc(mfkt)\n" }{MPLTEXT 1 202 84 "  option `Copyright
 (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n" }
{MPLTEXT 1 202 20 "          remember;\n" }{MPLTEXT 1 202 25 "  local \+
nm,np,mat,prt,k;\n" }{MPLTEXT 1 202 34 "  if mfkt=0 then return 0 end \+
if;\n" }{MPLTEXT 1 202 40 "  if mfkt=m[0] then return p[0] end if;\n" 
}{MPLTEXT 1 202 21 "  nm:=`+`(op(mfkt));\n" }{MPLTEXT 1 202 22 "  prt:
=PartNM(nm,nm);\n" }{MPLTEXT 1 202 17 "  np:=nops(prt);\n" }{MPLTEXT 
1 202 74 "  mat:=linalg[matrix](np,np,(i,j)->coeff(p_to_mM(prt[i]),m[o
p(prt[j])]));\n" }{MPLTEXT 1 202 24 "  mat:=evalm(mat^(-1));\n" }
{MPLTEXT 1 202 52 "  k:=1: while prt[k]<>[op(mfkt)] do k:=k+1; end do:
\n" }{MPLTEXT 1 202 46 "  add(mat[k,i]*p[op(prt[i])],i=1..nops(prt));
\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT
 1 202 84 "# m_to_p linear version of the transformation of monomial f
unctions into power sums\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 
22 "m_to_pMat:=proc(mfkt)\n" }{MPLTEXT 1 202 84 "  option `Copyright (
c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;\n" }
{MPLTEXT 1 202 21 "  local cf,term,lst;\n" }{MPLTEXT 1 202 26 "  if ty
pe(mfkt,`+`) then \n" }{MPLTEXT 1 202 30 "    return map(procname,mfkt
)\n" }{MPLTEXT 1 202 27 "  elif type(mfkt,`*`) then\n" }{MPLTEXT 1 
202 48 "    term,cf:=selectremove(type,mfkt,mfktmonom);\n" }{MPLTEXT 
1 202 29 "    return cf*procname(term)\n" }{MPLTEXT 1 202 7 "  else\n"
 }{MPLTEXT 1 202 19 "    m_to_pM(mfkt);\n" }{MPLTEXT 1 202 11 "  end i
f; \n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 64 "##########
#####################################################\n" }{MPLTEXT 1 
202 2 "#\n" }{MPLTEXT 1 202 34 "# m_to_p recursive faster version\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 64 "###########################
####################################\n" }{MPLTEXT 1 202 16 "m_to_p:=pr
oc(x)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ab
lamowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 12 "  re
member;\n" }{MPLTEXT 1 202 25 "  local term,cf,y,const;\n" }{MPLTEXT 
1 202 31 "  if x=0 then return 0 end if;\n" }{MPLTEXT 1 202 37 "  if x
=m[0] then return p[0] end if;\n" }{MPLTEXT 1 202 22 "  if type(x,`+`)
 then\n" }{MPLTEXT 1 202 21 "     map(procname,x)\n" }{MPLTEXT 1 202 
24 "  elif type(x,`*`) then\n" }{MPLTEXT 1 202 45 "    term,cf:=select
remove(type,x,mfktmonom);\n" }{MPLTEXT 1 202 30 "    return cf*procnam
e(term);\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 18 "    y:=p_
to_m(x);\n" }{MPLTEXT 1 202 47 "    const:=subs(s[0]=1, ScalarMH(y,h[o
p(x)]));\n" }{MPLTEXT 1 202 48 "    return p[op(x)]/const+ procname(x-
y/const);\n" }{MPLTEXT 1 202 7 "  end;\n" }{MPLTEXT 1 202 10 "end proc
:\n" }{MPLTEXT 1 202 82 "#############################################
####################################\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 76 "# m_to_hM is the basis change from monomial to comp
lete symmetric functions\n" }{MPLTEXT 1 202 78 "#         it uses the \+
m_to_p function to evaluate the Scalar product in terms\n" }{MPLTEXT 
1 202 42 "#         of poer sum symmetric functions\n" }{MPLTEXT 1 
202 2 "#\n" }{MPLTEXT 1 202 82 "######################################
###########################################\n" }{MPLTEXT 1 202 17 "m_t
o_hM:=proc(x)\n" }{MPLTEXT 1 202 16 "  local prt,pt;\n" }{MPLTEXT 1 
202 31 "  if x=0 then return 0 end if;\n" }{MPLTEXT 1 202 37 "  if x=m
[0] then return h[0] end if;\n" }{MPLTEXT 1 202 44 "  prt:=[op(PartNM(
`+`(op(x)),`+`(op(x))))];\n" }{MPLTEXT 1 202 84 "  add( subs(s[0]=1, S
calarP( m_to_p(x), m_to_p(m[op(pt)]) ))*h[op(pt)] ,pt in prt);\n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 82 "##################
###############################################################\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 72 "# m_to_h is the linear vers
ion of m_to_pM basis change from monomial to\n" }{MPLTEXT 1 202 37 "# \+
       complete symmetrc functions\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 82 "###################################################
##############################\n" }{MPLTEXT 1 202 16 "m_to_h:=proc(x)
\n" }{MPLTEXT 1 202 17 "  local cf,term;\n" }{MPLTEXT 1 202 22 "  if t
ype(x,`+`) then\n" }{MPLTEXT 1 202 28 "    return map(procname,x);\n" 
}{MPLTEXT 1 202 24 "  elif type(x,`*`) then\n" }{MPLTEXT 1 202 45 "   \+
 term,cf:=selectremove(type,x,mfktmonom);\n" }{MPLTEXT 1 202 38 "    r
eturn expand(cf*procname(term));\n" }{MPLTEXT 1 202 7 "  else\n" }
{MPLTEXT 1 202 23 "    return m_to_hM(x);\n" }{MPLTEXT 1 202 11 "  end
 if; \n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 64 "###################################################
############\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 48 "# m_to_e t
ransformation from m-bases to p-bases\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 64 "###################################################
############\n" }{MPLTEXT 1 202 16 "m_to_e:=proc(x)\n" }{MPLTEXT 1 
202 84 "  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. A
ll rights reserved.`,\n" }{MPLTEXT 1 202 12 "  remember;\n" }{MPLTEXT 
1 202 34 "  local term,cf,y,const,len,mred;\n" }{MPLTEXT 1 202 31 "  i
f x=0 then return 0 end if;\n" }{MPLTEXT 1 202 37 "  if x=m[0] then re
turn e[0] end if;\n" }{MPLTEXT 1 202 22 "  if type(x,`+`) then\n" }
{MPLTEXT 1 202 21 "     map(procname,x)\n" }{MPLTEXT 1 202 24 "  elif \+
type(x,`*`) then\n" }{MPLTEXT 1 202 45 "    term,cf:=selectremove(type
,x,mfktmonom);\n" }{MPLTEXT 1 202 30 "    return cf*procname(term);\n"
 }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 24 "    len:=nops([op(x)
]);\n" }{MPLTEXT 1 202 49 "    mred:=subs(0=NULL,m[ op([op(x)]-[1$len]
) ]);\n" }{MPLTEXT 1 202 40 "    if mred=m[] then mred:=m[0] end if;\n
" }{MPLTEXT 1 202 73 "    #const:=coeff(outerM(op(map(z->m[op(z)],[op(
x)]))),m[1$`+`(op(x))]);\n" }{MPLTEXT 1 202 46 "    return outerE( e[l
en] , procname( mred ))\n" }{MPLTEXT 1 202 53 "          - procname( o
uterM(m[1$len],  mred ) - x);\n" }{MPLTEXT 1 202 7 "  end;\n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 64 "##################
#############################################\n" }{MPLTEXT 1 202 64 "#
##############################################################\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 68 "# makeRimRep is a cast from
 a partition into a representation of a \n" }{MPLTEXT 1 202 67 "#     \+
       partition by noting its E-N directions by 1-0 symbols\n" }
{MPLTEXT 1 202 69 "#            This sequence is infinite having infin
it many leading 0\n" }{MPLTEXT 1 202 61 "#            and traling 1s (
which are of course not stored)\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 
1 202 23 "makeRimRep:=proc(part)\n" }{MPLTEXT 1 202 84 "   option `Cop
yright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`
\n" }{MPLTEXT 1 202 21 "          ,remember;\n" }{MPLTEXT 1 202 24 "  \+
 local n1,diff,res,i;\n" }{MPLTEXT 1 202 19 "   n1:=nops(part);\n" }
{MPLTEXT 1 202 61 "   diff:=[part[-1],seq(-part[n1+1-i]+part[n1-i],i=1
..n1-1)];\n" }{MPLTEXT 1 202 12 "   res:=[];\n" }{MPLTEXT 1 202 33 "  \+
 for i from 1 to nops(diff) do\n" }{MPLTEXT 1 202 44 "      res:=[op(r
es),seq(1,j=1..diff[i]),0];\n" }{MPLTEXT 1 202 11 "   end do;\n" }
{MPLTEXT 1 202 8 "   res;\n" }{MPLTEXT 1 202 10 "end proc:\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 71 "#  removeRimHook removes a \+
rim hook (edgewise conected boundary strip)\n" }{MPLTEXT 1 202 72 "#  \+
              of length hocklength in all possible ways. It returns \n
" }{MPLTEXT 1 202 76 "#                a list with the rimrepresented \+
partitions of the remaining\n" }{MPLTEXT 1 202 81 "#                pa
rt of the partition and a list with the rimheight attached to\n" }
{MPLTEXT 1 202 37 "#                the removed hoocks.\n" }{MPLTEXT 
1 202 2 "#\n" }{MPLTEXT 1 202 39 "removeRimHook:=proc(rimrep,hooklengt
h)\n" }{MPLTEXT 1 202 85 "   option `Copyright (c) B. Fauser & R. Abla
mowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 20 "      \+
    remember;\n" }{MPLTEXT 1 202 60 "   local i,j,mult,redrimrep,rimhi
eght,nrr,tmprim,del0,del1;\n" }{MPLTEXT 1 202 18 "   redrimrep:=[];\n"
 }{MPLTEXT 1 202 18 "   rimhieght:=[];\n" }{MPLTEXT 1 202 22 "   nrr:=
nops(rimrep);\n" }{MPLTEXT 1 202 28 "   for i from 1 to nrr-1 do\n" }
{MPLTEXT 1 202 25 "     if rimrep[i]=1 then\n" }{MPLTEXT 1 202 32 "   \+
    for j from i+1 to nrr do\n" }{MPLTEXT 1 202 29 "         if rimrep
[j]=0 then\n" }{MPLTEXT 1 202 34 "           if j-i=hooklength then\n"
 }{MPLTEXT 1 202 29 "             tmprim:=rimrep;\n" }{MPLTEXT 1 202 
27 "             tmprim[i]:=0;\n" }{MPLTEXT 1 202 28 "             tmp
rim[j]:=1; \n" }{MPLTEXT 1 202 48 "             redrimrep:=[op(redrimr
ep),tmprim];\n" }{MPLTEXT 1 202 42 "             rimhieght  :=[op(rimh
ieght),\n" }{MPLTEXT 1 202 100 "                         `+`(op(map(x-
>if x=0 then 1 else 0 end if,[seq(tmprim[k],k=i+1..j-1)])))] \n" }
{MPLTEXT 1 202 33 "           end if;              \n" }{MPLTEXT 1 
202 19 "         end if;  \n" }{MPLTEXT 1 202 18 "       end do;   \n"
 }{MPLTEXT 1 202 13 "     end if;\n" }{MPLTEXT 1 202 11 "   end do;\n"
 }{MPLTEXT 1 202 16 "###############\n" }{MPLTEXT 1 202 22 "      del0
:=proc(lst)\n" }{MPLTEXT 1 202 20 "        local flag;\n" }{MPLTEXT 1 
202 21 "        flag:=false;\n" }{MPLTEXT 1 202 94 "        map(x->if \+
x=0 and flag=false then return NULL else flag:=true; return x end if,l
st); \n" }{MPLTEXT 1 202 16 "      end proc:\n" }{MPLTEXT 1 202 22 "  \+
    del1:=proc(lst)\n" }{MPLTEXT 1 202 28 "        local flag,f,res,i;
\n" }{MPLTEXT 1 202 21 "        flag:=false;\n" }{MPLTEXT 1 202 87 "  \+
      f:=x->if x=1 and flag=false then return NULL else flag:=true; re
turn x end if;\n" }{MPLTEXT 1 202 17 "        res:=[];\n" }{MPLTEXT 1 
202 43 "        for i from nops(lst) to 1 by -1 do\n" }{MPLTEXT 1 202 
36 "          res:=[f(lst[i]),op(res)];\n" }{MPLTEXT 1 202 17 "       \+
 end do; \n" }{MPLTEXT 1 202 16 "      end proc:\n" }{MPLTEXT 1 202 
21 "################    \n" }{MPLTEXT 1 202 44 "   map(del0,map(del1,r
edrimrep)),rimhieght;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 
202 2 "#\n" }{MPLTEXT 1 202 76 "# MurNakRim This is the function which
 computes the Murnaghan Nakayama rule\n" }{MPLTEXT 1 202 75 "#        \+
   in terms of the rim representation of a shape. It is internal,\n" }
{MPLTEXT 1 202 79 "#           since rim representations of shapes are
 not supported on the user \n" }{MPLTEXT 1 202 33 "#           side of
 the package.\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 30 "MurNakRim
:=proc(rimRep,part2)\n" }{MPLTEXT 1 202 85 "   option `Copyright (c) B
. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n" }
{MPLTEXT 1 202 20 "          remember;\n" }{MPLTEXT 1 202 27 "   local
 pt1,pt2,lst,sign;\n" }{MPLTEXT 1 202 25 "   if nops(part2)=1 then\n" 
}{MPLTEXT 1 202 48 "      lst,sign:=removeRimHook(rimRep,part2[1]);\n"
 }{MPLTEXT 1 202 33 "      return add((-1)^i,i=sign);\n" }{MPLTEXT 1 
202 8 "   else\n" }{MPLTEXT 1 202 21 "      pt1:=part2[1];\n" }
{MPLTEXT 1 202 25 "      pt2:=part2[2..-1];\n" }{MPLTEXT 1 202 43 "   \+
   lst,sign:=removeRimHook(rimRep,pt1);\n" }{MPLTEXT 1 202 68 "      r
eturn add((-1)^sign[i]*procname(lst[i],pt2),i=1..nops(lst));\n" }
{MPLTEXT 1 202 11 "   end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 76 "# MurNak This function prov
ides the interface for the function MurNakRim to\n" }{MPLTEXT 1 202 
82 "#        compute the Murnaghan-Nakayama rule. This function return
s the character\n" }{MPLTEXT 1 202 77 "#        value of an S_n charac
ter with cycletype part1 on an element of S_n\n" }{MPLTEXT 1 202 31 "#
        with cycletype part2.\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 76 "# NOTE:  MurNak should be defined as scalar(s[part1],p[part2])
 which is the\n" }{MPLTEXT 1 202 45 "#        _transpodes_ of the pres
ent MurNak!\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 26 "MurNak:=pro
c(part1,part2)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fause
r & R. Ablamowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 
202 20 "          remember;\n" }{MPLTEXT 1 202 42 "  if `+`(op(part1))
<>`+`(op(part2)) then \n" }{MPLTEXT 1 202 68 "    # -- This function i
s graded, for different grades return zero \n" }{MPLTEXT 1 202 14 "   \+
 return 0;\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 83 "    # -
- else use MurNakRim which needs a rim representation in the first arg
ument\n" }{MPLTEXT 1 202 50 "    # -- MurNak is _not_ symmetric in its
 entries\n" }{MPLTEXT 1 202 47 "    return MurNakRim(makeRimRep(part2)
,part1);\n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end p
roc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 83 "# CharHook compute
 the character <sfkt,pfkt> if pfkt is a one part partition power\n" }
{MPLTEXT 1 202 81 "#          sum. The result is zero unless sfkt=\{a+
1,1^b\} is a Hook in which case\n" }{MPLTEXT 1 202 84 "#          the \+
value of the character is (-1)^b, the height of the hook (leglength)\n
" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 26 "CharHook:=proc(sfkt,pfkt
)\n" }{MPLTEXT 1 202 85 "   option `Copyright (c) B. Fauser & R. Ablam
owicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 20 "       \+
   remember;\n" }{MPLTEXT 1 202 28 "   local spart,ppart,ns,np;\n" }
{MPLTEXT 1 202 22 "   spart:=[op(sfkt)];\n" }{MPLTEXT 1 202 22 "   ppa
rt:=[op(pfkt)];\n" }{MPLTEXT 1 202 17 "   np:=ppart[1];\n" }{MPLTEXT 
1 202 23 "   ns:=`+`(op(spart));\n" }{MPLTEXT 1 202 35 "   if ns<>np t
hen return 0 end if;\n" }{MPLTEXT 1 202 27 "## -- check if s is a hook
\n" }{MPLTEXT 1 202 55 "   if spart[1]+nops(spart)-1<>ns then return 0
 end if;\n" }{MPLTEXT 1 202 29 "   (-1)^(nops(spart)-1);    \n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 65 "# sq_coeff returns the square of the coefficients of a symmetr
ic\n" }{MPLTEXT 1 202 50 "#          function polynomial of a certain \+
type.\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 28 "sq_coeff:=proc(x,typ::type)\n" }{MPLTEXT 1 202 84 "  option `C
opyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.
`;\n" }{MPLTEXT 1 202 14 "  local  lst;\n" }{MPLTEXT 1 202 15 "  if x=
0 then \n" }{MPLTEXT 1 202 13 "    return 0\n" }{MPLTEXT 1 202 25 "  e
lif type(x,`+`) then \n" }{MPLTEXT 1 202 18 "    lst:=[op(x)];\n" }
{MPLTEXT 1 202 8 "  else \n" }{MPLTEXT 1 202 14 "    lst:=[x];\n" }
{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 73 "  lst:=map(x->if t
ype(x,`*`) then remove(type,x,typ) else 1 end if,lst);\n" }{MPLTEXT 1 
202 18 "  add(i^2,i=lst);\n" }{MPLTEXT 1 202 10 "end proc:\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n"
 }{MPLTEXT 1 202 85 "# MurNak2 is a function which as a proof of conce
pt shows how the Murnaghan Nakayama\n" }{MPLTEXT 1 202 81 "#         r
ule can be evaluatedon base of the Littlewood Richardson rule and the
\n" }{MPLTEXT 1 202 85 "#         character formula on Hook Shapes \\C
hi^\\lambda_n=Scalar(s_\\lambda,p[n]). It\n" }{MPLTEXT 1 202 57 "#    \+
     is much slower than the rimRep based function.\n" }{MPLTEXT 1 
202 2 "#\n" }{MPLTEXT 1 202 89 "# WARINING: MurNak2 needs FLAT and MLI
N which make functions associative and multilinear\n" }{MPLTEXT 1 202 
86 "#         This should be replaced by a better version of 'define' \+
which specifies not\n" }{MPLTEXT 1 202 72 "#         the base ring, bu
t the types of the generating basis elemnts.\n" }{MPLTEXT 1 202 2 "#\n
" }{MPLTEXT 1 202 25 "MurNak2:=proc(sfkt,pfkt)\n" }{MPLTEXT 1 202 84 "
   option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All righ
ts reserved.`\n" }{MPLTEXT 1 202 21 "          ,remember;\n" }{MPLTEXT
 1 202 34 "   local spart,ppart,ns,np,sw,CH;\n" }{MPLTEXT 1 202 22 "  \+
 spart:=[op(sfkt)];\n" }{MPLTEXT 1 202 22 "   ppart:=[op(pfkt)];\n" }
{MPLTEXT 1 202 60 "#   sw:=proc() T(args[1],args[3],args[2],args[4]) e
nd proc:\n" }{MPLTEXT 1 202 76 "#   CH:=proc() CharHook(args[1],args[2
])*MurNak2(args[3],args[4]) end proc:\n" }{MPLTEXT 1 202 57 "   CH:=(a
1,a2,a3,a4) -> CharHook(a1,a3)*MurNak2(a2,a4): \n" }{MPLTEXT 1 202 25 
"   if nops(pfkt)=1 then \n" }{MPLTEXT 1 202 34 "      return CharHook
(sfkt,pfkt);\n" }{MPLTEXT 1 202 8 "   else\n" }{MPLTEXT 1 202 67 "    \+
 T(subs(`&t`=T,couter(sfkt)),s[ppart[1]],s[op(ppart[2..-1])]);\n" }
{MPLTEXT 1 202 33 "     FLAT(eval(subs(T=MLIN,%)));\n" }{MPLTEXT 1 
202 26 "#     eval(subs(T=sw,%));\n" }{MPLTEXT 1 202 25 "     eval(sub
s(T=CH,%));\n" }{MPLTEXT 1 202 11 "   end if;\n" }{MPLTEXT 1 202 10 "e
nd proc:\n" }{MPLTEXT 1 202 41 "######################################
##\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 54 "# dimSN_mon computes
 the dimension of an SN character\n" }{MPLTEXT 1 202 59 "#           a
ccording to the hook rule for an Sn character\n" }{MPLTEXT 1 202 45 "#
           s[lambda] (Schur function monom)\n" }{MPLTEXT 1 202 36 "#  \+
         ++ dimSN(s[\\lambda]) = \n" }{MPLTEXT 1 202 62 "#           +
+   factorial(|\\lambda|)/\\prod_\{i,j\} h_ij  where\n" }{MPLTEXT 1 
202 66 "#           ++   h_ij is the length of the hook at position (i
,j)\n" }{MPLTEXT 1 202 50 "#           ++   in the Young diagram of \+
\\lambda \n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT
 1 202 19 "dimSN_mon:=proc(x)\n" }{MPLTEXT 1 202 93 "  option `Copyrig
ht (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,reme
mber;\n" }{MPLTEXT 1 202 68 "  local part,part_conj,np,i,j,hooks;\n  i
f x=0 then return 0 end if;\n" }{MPLTEXT 1 202 17 "  part:=[op(x)];\n"
 }{MPLTEXT 1 202 36 "  if part=[0] then return 0 end if;\n" }{MPLTEXT 
1 202 18 "  np:=nops(part);\n" }{MPLTEXT 1 202 29 "  part_conj:=conjpa
rt(part);\n" }{MPLTEXT 1 202 12 "  hooks:=1;\n" }{MPLTEXT 1 202 24 "  \+
for i from 1 to np do\n" }{MPLTEXT 1 202 29 "  for j from 1 to part[i]
 do\n" }{MPLTEXT 1 202 62 "     hooks:=hooks *( (part[i]-j+1)+max(part
_conj[j]-i , 0) );\n" }{MPLTEXT 1 202 17 "  end do;end do;\n" }
{MPLTEXT 1 202 34 "  factorial(`+`(op(part)))/hooks;\n" }{MPLTEXT 1 
202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 48 "# dim
SN is the multilinear version of simSN_mon\n" }{MPLTEXT 1 202 2 "#\n" 
}{MPLTEXT 1 202 15 "dimSN:=proc(x)\n" }{MPLTEXT 1 202 84 "  option `Co
pyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`
;\n" }{MPLTEXT 1 202 32 "  local cf,tm,n1,plst1,plst2,i;\n" }{MPLTEXT 
1 202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 202 30 "    return map
(procname,x,y);\n" }{MPLTEXT 1 202 25 "  elif type(x,`*`) then \n" }
{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,x,sfktmonom);\n" }
{MPLTEXT 1 202 29 "    return cf*procname(tm,y)\n" }{MPLTEXT 1 202 7 "
  else\n" }{MPLTEXT 1 202 20 "    dimSN_mon(x);  \n" }{MPLTEXT 1 202 
10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#
\n" }{MPLTEXT 1 202 52 "# dimSNP gives the dimension of S_n-modules in
 the \n" }{MPLTEXT 1 202 44 "#        power sum symmetric function bas
is\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 16 "dimSNP:=proc(x)\n" }
{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ablamowicz 2
004-2009. All rights reserved.`;\n" }{MPLTEXT 1 202 15 "  local cf,tm;
\n" }{MPLTEXT 1 202 31 "  if x=0 then return 0 end if;\n" }{MPLTEXT 1 
202 34 "  if x=p[0] then return 0 end if;\n" }{MPLTEXT 1 202 23 "  if \+
type(x,`+`) then \n" }{MPLTEXT 1 202 28 "    return map(procname,x);\n
" }{MPLTEXT 1 202 25 "  elif type(x,`*`) then \n" }{MPLTEXT 1 202 43 "
    tm,cf:=selectremove(type,x,pfktmonom);\n" }{MPLTEXT 1 202 27 "    \+
return cf*procname(tm)\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 
202 37 "    if `+`(op(x))=nops([op(x)]) then\n" }{MPLTEXT 1 202 26 "  \+
    return `+`(op(x))!;\n" }{MPLTEXT 1 202 10 "    else \n" }{MPLTEXT 
1 202 16 "      return 0;\n" }{MPLTEXT 1 202 14 "    end if;  \n" }
{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 52 "# dimSNM gives the dimensio
n of S_n-modules in the \n" }{MPLTEXT 1 202 43 "#        monomial symm
etric function basis\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 16 "di
mSNM:=proc(x)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser
 & R. Ablamowicz 2004-2009. All rights reserved.`;\n" }{MPLTEXT 1 202 
15 "  local cf,tm;\n" }{MPLTEXT 1 202 31 "  if x=0 then return 0 end i
f;\n" }{MPLTEXT 1 202 34 "  if x=m[0] then return 0 end if;\n" }
{MPLTEXT 1 202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 202 28 "    r
eturn map(procname,x);\n" }{MPLTEXT 1 202 25 "  elif type(x,`*`) then \+
\n" }{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,x,mfktmonom);\n" 
}{MPLTEXT 1 202 27 "    return cf*procname(tm)\n" }{MPLTEXT 1 202 7 " \+
 else\n" }{MPLTEXT 1 202 37 "    if `+`(op(x))=nops([op(x)]) then\n" }
{MPLTEXT 1 202 15 "      return 1\n" }{MPLTEXT 1 202 10 "    else \n" 
}{MPLTEXT 1 202 16 "      return 0;\n" }{MPLTEXT 1 202 14 "    end if;
  \n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n
" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 52 "# dimSNH gives the dimen
sion of S_n-modules in the \n" }{MPLTEXT 1 202 44 "#        compleete \+
symmetric function basis\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 
16 "dimSNH:=proc(x)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. \+
Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;\n" }{MPLTEXT 
1 202 15 "  local cf,tm;\n" }{MPLTEXT 1 202 31 "  if x=0 then return 0
 end if;\n" }{MPLTEXT 1 202 34 "  if x=h[0] then return 0 end if;\n" }
{MPLTEXT 1 202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 202 28 "    r
eturn map(procname,x);\n" }{MPLTEXT 1 202 25 "  elif type(x,`*`) then \+
\n" }{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,x,hfktmonom);\n" 
}{MPLTEXT 1 202 27 "    return cf*procname(tm)\n" }{MPLTEXT 1 202 7 " \+
 else\n" }{MPLTEXT 1 202 52 "    return combinat:-multinomial(`+`(op(x
)),op(x));\n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end
 proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 52 "# dimSNE gives t
he dimension of S_n-modules in the \n" }{MPLTEXT 1 202 45 "#        el
ementray symmetric function basis\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT
 1 202 16 "dimSNE:=proc(x)\n" }{MPLTEXT 1 202 84 "  option `Copyright \+
(c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;\n" }
{MPLTEXT 1 202 15 "  local cf,tm;\n" }{MPLTEXT 1 202 31 "  if x=0 then
 return 0 end if;\n" }{MPLTEXT 1 202 34 "  if x=e[0] then return 0 end
 if;\n" }{MPLTEXT 1 202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 202 
28 "    return map(procname,x);\n" }{MPLTEXT 1 202 25 "  elif type(x,`
*`) then \n" }{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,x,efktmo
nom);\n" }{MPLTEXT 1 202 27 "    return cf*procname(tm)\n" }{MPLTEXT 
1 202 7 "  else\n" }{MPLTEXT 1 202 52 "    return combinat:-multinomia
l(`+`(op(x)),op(x));\n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 
202 10 "end proc:\n" }{MPLTEXT 1 202 41 "#############################
###########\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 57 "# dimGL_mon
 computes the dimension of an GL(N) character\n" }{MPLTEXT 1 202 59 "#
           according to the hook rule for an Sn character\n" }{MPLTEXT
 1 202 45 "#           s[lambda] (Schur function monom)\n" }{MPLTEXT 
1 202 38 "#           ++ dimGL(s[\\lambda],N) = \n" }{MPLTEXT 1 202 
49 "#           ++   content/\\prod_\{i,j\} h_ij  where\n" }{MPLTEXT 
1 202 66 "#           ++   h_ij is the length of the hook at position \+
(i,j)\n" }{MPLTEXT 1 202 50 "#           ++   in the Young diagram of \+
\\lambda,\n" }{MPLTEXT 1 202 63 "#           ++   content is the produ
ct of the content of the \n" }{MPLTEXT 1 202 70 "#           ++   boxe
s x(i,j)=N-i+j  (i,j = row,column) and N the dim\n" }{MPLTEXT 1 202 
52 "#           ++ of the vectorspace underlying GL(N) \n" }{MPLTEXT 
1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 21 "dimGL_mon:=p
roc(x,N)\n" }{MPLTEXT 1 202 93 "  option `Copyright (c) B. Fauser & R.
 Ablamowicz 2004-2009. All rights reserved.`,remember;\n" }{MPLTEXT 1 
202 76 "  local part,part_conj,np,i,j,hooks,content;\n  if x=0 then re
turn 0 end if;\n" }{MPLTEXT 1 202 17 "  part:=[op(x)];\n" }{MPLTEXT 1 
202 36 "  if part=[0] then return 1 end if;\n" }{MPLTEXT 1 202 18 "  n
p:=nops(part);\n" }{MPLTEXT 1 202 29 "  part_conj:=conjpart(part);\n" 
}{MPLTEXT 1 202 12 "  hooks:=1;\n" }{MPLTEXT 1 202 14 "  content:=1;\n
" }{MPLTEXT 1 202 24 "  for i from 1 to np do\n" }{MPLTEXT 1 202 29 " \+
 for j from 1 to part[i] do\n" }{MPLTEXT 1 202 62 "     hooks:=hooks *
( (part[i]-j+1)+max(part_conj[j]-i , 0) );\n" }{MPLTEXT 1 202 31 "    \+
 content:=content*(N-i+j);\n" }{MPLTEXT 1 202 17 "  end do;end do;\n" 
}{MPLTEXT 1 202 17 "  content/hooks;\n" }{MPLTEXT 1 202 10 "end proc:
\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 48 "# dimGL is the multili
near version of dimGL_mon\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 
17 "dimGL:=proc(x,N)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B.
 Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;\n" }{MPLTEXT
 1 202 32 "  local cf,tm,n1,plst1,plst2,i;\n" }{MPLTEXT 1 202 23 "  if
 type(x,`+`) then \n" }{MPLTEXT 1 202 30 "    return map(procname,x,N)
;\n" }{MPLTEXT 1 202 25 "  elif type(x,`*`) then \n" }{MPLTEXT 1 202 
43 "    tm,cf:=selectremove(type,x,sfktmonom);\n" }{MPLTEXT 1 202 29 "
    return cf*procname(tm,N)\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT
 1 202 22 "    dimGL_mon(x,N);  \n" }{MPLTEXT 1 202 10 "  end if;\n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 49 "##################
##############################\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 77 "# dimGLP_mon gives the dimension of a monomial representing a \+
module in the \n" }{MPLTEXT 1 202 44 "#        power sum symmetric fun
ction basis\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 25 "dimGLP_mon:=proc(pfkt,N)\n" }{MPLTEXT 1 202 84 "  o
ption `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights r
eserved.`;\n" }{MPLTEXT 1 202 18 "  if pfkt=0 then \n" }{MPLTEXT 1 
202 13 "    return 0\n" }{MPLTEXT 1 202 23 "  elif pfkt=p[0] then \n" 
}{MPLTEXT 1 202 13 "    return 1\n" }{MPLTEXT 1 202 7 "  else\n" }
{MPLTEXT 1 202 26 "    N^(nops([op(pfkt)]));\n" }{MPLTEXT 1 202 10 "  \+
end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 60 "# dimGLP gives the dimension of a sum of GL-modules
 in the \n" }{MPLTEXT 1 202 44 "#        power sum symmetric function \+
basis\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 18 "dimGLP:=proc(x,N)
\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ablamow
icz 2004-2009. All rights reserved.`;\n" }{MPLTEXT 1 202 15 "  local c
f,tm;\n" }{MPLTEXT 1 202 31 "  if x=0 then return 0 end if;\n" }
{MPLTEXT 1 202 34 "  if x=p[0] then return 1 end if;\n" }{MPLTEXT 1 
202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 202 30 "    return map(p
rocname,x,N);\n" }{MPLTEXT 1 202 25 "  elif type(x,`*`) then \n" }
{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,x,pfktmonom);\n" }
{MPLTEXT 1 202 29 "    return cf*procname(tm,N)\n" }{MPLTEXT 1 202 7 "
  else\n" }{MPLTEXT 1 202 23 "    dimGLP_mon(x,N);  \n" }{MPLTEXT 1 
202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 
2 "#\n" }{MPLTEXT 1 202 60 "# dimGLM gives the dimension of a sum of G
L-modules in the \n" }{MPLTEXT 1 202 43 "#        monomial symmetric f
unction basis\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 18 "dimGLM:=p
roc(x,N)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R.
 Ablamowicz 2004-2009. All rights reserved.`;\n" }{MPLTEXT 1 202 15 " \+
 local cf,tm;\n" }{MPLTEXT 1 202 31 "  if x=0 then return 0 end if;\n"
 }{MPLTEXT 1 202 34 "  if x=m[0] then return 1 end if;\n" }{MPLTEXT 1 
202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 202 30 "    return map(p
rocname,x,N);\n" }{MPLTEXT 1 202 25 "  elif type(x,`*`) then \n" }
{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,x,mfktmonom);\n" }
{MPLTEXT 1 202 29 "    return cf*procname(tm,N)\n" }{MPLTEXT 1 202 7 "
  else\n" }{MPLTEXT 1 202 90 "    factor(1/(`*`(op(map(x->x!,part2mset
([op(x)])))))*fallingFactorial(N,nops([op(x)])));\n" }{MPLTEXT 1 202 
10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#
\n" }{MPLTEXT 1 202 60 "# dimGLH gives the dimension of a sum of GL-mo
dules in the \n" }{MPLTEXT 1 202 44 "#        compleete symmetric func
tion basis\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 18 "dimGLH:=proc
(x,N)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ab
lamowicz 2004-2009. All rights reserved.`;\n" }{MPLTEXT 1 202 15 "  lo
cal cf,tm;\n" }{MPLTEXT 1 202 31 "  if x=0 then return 0 end if;\n" }
{MPLTEXT 1 202 34 "  if x=h[0] then return 1 end if;\n" }{MPLTEXT 1 
202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 202 30 "    return map(p
rocname,x,N);\n" }{MPLTEXT 1 202 25 "  elif type(x,`*`) then \n" }
{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,x,hfktmonom);\n" }
{MPLTEXT 1 202 29 "    return cf*procname(tm,N)\n" }{MPLTEXT 1 202 7 "
  else\n" }{MPLTEXT 1 202 88 "    factor(1/(`*`(op(map(x->x!,[op(x)]))
)) * `*`(op(map2(risingFactorial,N,[op(x)]))));\n" }{MPLTEXT 1 202 9 "
 end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 60 "# dimGLE gives the dimension of a sum of GL-modules
 in the \n" }{MPLTEXT 1 202 45 "#        elementray symmetric function
 basis\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 18 "dimGLE:=proc(x,N
)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ablamo
wicz 2004-2009. All rights reserved.`;\n" }{MPLTEXT 1 202 15 "  local \+
cf,tm;\n" }{MPLTEXT 1 202 31 "  if x=0 then return 0 end if;\n" }
{MPLTEXT 1 202 34 "  if x=e[0] then return 1 end if;\n" }{MPLTEXT 1 
202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 202 30 "    return map(p
rocname,x,N);\n" }{MPLTEXT 1 202 25 "  elif type(x,`*`) then \n" }
{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,x,efktmonom);\n" }
{MPLTEXT 1 202 29 "    return cf*procname(tm,N)\n" }{MPLTEXT 1 202 7 "
  else\n" }{MPLTEXT 1 202 89 "    factor(1/(`*`(op(map(x->x!,[op(x)]))
)) * `*`(op(map2(fallingFactorial,N,[op(x)]))));\n" }{MPLTEXT 1 202 9 
" end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 80 "####
######################################################################
#####\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 34 "# G E S S E L T H
 E T A functions\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 80 "######
######################################################################
###\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 74 "# GesselTheta is th
e Gessel map from a polynomial ring in infinitley many\n" }{MPLTEXT 1 
202 70 "#     (finitely many) variables 'u1,u2,u3,...' into a polynomi
al ring\n" }{MPLTEXT 1 202 77 "#     in one variable 'z', say. The map
 is ussefull for counting purpose and\n" }{MPLTEXT 1 202 26 "#     def
ined as follows:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 24 "# -- i
)   \\Theta(1) = 1\n" }{MPLTEXT 1 202 43 "# -- ii)  \\Theta(p_n(u)) = \+
z if n=1 else 0\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 41 "#     w
e have therefore for S-functiuons\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT
 1 202 72 "# -- iii) \\Theta(s_\\lambda(u)) = f^\\lambda z^(|\\lambda|
) / (|\\lambda|)!\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 61 "#    \+
where |\\lambda| is the weight of a partition lambda and\n" }{MPLTEXT 
1 202 64 "#    f^\\lambda is the number of standard Young tableau of s
hape\n" }{MPLTEXT 1 202 52 "#    \\lambda i.e. SYT(\\lambda)=dimSN(s[
\\lambda](u))\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 80 "#########
######################################################################
\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 71 "# GesselThetaP_mon is \+
the theta function given for power sum monomials\n" }{MPLTEXT 1 202 2 
"#\n" }{MPLTEXT 1 202 30 "GesselThetaP_mon:=proc(x,var)\n" }{MPLTEXT 
1 202 84 "  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009.
 All rights reserved.`,\n" }{MPLTEXT 1 202 11 "  remeber;\n" }{MPLTEXT
 1 202 11 "  local n;\n" }{MPLTEXT 1 202 43 "  if (x=p[0] or x=1) then
 return 1 end if;\n" }{MPLTEXT 1 202 20 "  n:=nops([op(x)]);\n" }
{MPLTEXT 1 202 44 "  if n=`+`(op(x)) then var^n else 0 end if;\n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 67 "# GesselThetaP is the linear version for the Gessel map theta \+
for \n" }{MPLTEXT 1 202 37 "#              power sum polynomials\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 26 "GesselThetaP:=proc(x,var)\n
" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ablamowic
z 2004-2009. All rights reserved.`;\n" }{MPLTEXT 1 202 15 "  local cf,
tm;\n" }{MPLTEXT 1 202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 202 
32 "    return map(procname,x,var);\n" }{MPLTEXT 1 202 25 "  elif type
(x,`*`) then \n" }{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,x,pf
ktmonom);\n" }{MPLTEXT 1 202 39 "    return cf*GesselThetaP_mon(tm,var
)\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 31 "    GesselThetaP
_mon(x,var);  \n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 10 
"end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 76 "# GesselThet
aS_mon is the theta function given for Schur function monomials\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 30 "GesselThetaS_mon:=proc(x,va
r)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ablam
owicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 11 "  remeb
er;\n" }{MPLTEXT 1 202 11 "  local N;\n" }{MPLTEXT 1 202 43 "  if (x=s
[0] or x=1) then return 1 end if;\n" }{MPLTEXT 1 202 17 "  N:=`+`(op(x
));\n" }{MPLTEXT 1 202 32 "  dimSN(x)*var^N/factorial(N); \n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 67 "# GesselThetaS is the linear version for the Gessel map theta \+
for \n" }{MPLTEXT 1 202 42 "#              Schur function polynomials
\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 26 "GesselThetaS:=proc(x,v
ar)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Abla
mowicz 2004-2009. All rights reserved.`;\n" }{MPLTEXT 1 202 15 "  loca
l cf,tm;\n" }{MPLTEXT 1 202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 
202 32 "    return map(procname,x,var);\n" }{MPLTEXT 1 202 25 "  elif \+
type(x,`*`) then \n" }{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,
x,sfktmonom);\n" }{MPLTEXT 1 202 39 "    return cf*GesselThetaS_mon(tm
,var)\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 31 "    GesselTh
etaS_mon(x,var);  \n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 
202 10 "end proc:\n" }{MPLTEXT 1 202 1 "\n" }{MPLTEXT 1 202 41 "######
##################################\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 28 "# Functions for s-functions\n" }{MPLTEXT 1 202 2 "#
\n" }{MPLTEXT 1 202 41 "########################################\n" }
{MPLTEXT 1 202 1 "\n" }{MPLTEXT 1 202 1 "\n" }{MPLTEXT 1 202 81 "#####
######################################################################
#####\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 23 "# S C A L A R PRO
DUCTS\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 26 "#     for differe
nt bases\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 81 "##############
##################################################################\n" 
}{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 40 "# +++ scalar product of sc
hur functions\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 18 "Scalar:=p
roc(x,y)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R.
 Ablamowicz 2004-2009. All rights reserved.`;\n" }{MPLTEXT 1 202 21 " \+
 local cf,tm,p1,p2;\n" }{MPLTEXT 1 202 38 "  if x=0 or y=0 then return
 0 end if;\n" }{MPLTEXT 1 202 89 "  if not (type(x,sfktpolynom) and ty
pe(y,sfktpolynom)) then error \"wrong type\\n\" end if;\n" }{MPLTEXT 
1 202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 202 30 "    return map
(procname,x,y);\n" }{MPLTEXT 1 202 25 "  elif type(x,`*`) then \n" }
{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,x,sfktmonom);\n" }
{MPLTEXT 1 202 29 "    return cf*procname(tm,y)\n" }{MPLTEXT 1 202 7 "
  else\n" }{MPLTEXT 1 202 25 "    if type(y,`+`) then \n" }{MPLTEXT 1 
202 33 "      return map2(procname,x,y);\n" }{MPLTEXT 1 202 26 "    el
if type(y,`*`) then\n" }{MPLTEXT 1 202 45 "      tm,cf:=selectremove(t
ype,y,sfktmonom);\n" }{MPLTEXT 1 202 31 "      return cf*procname(x,tm
)\n" }{MPLTEXT 1 202 9 "    else\n" }{MPLTEXT 1 202 37 "      p1:=getP
art(x):p2:=getPart(y):\n" }{MPLTEXT 1 202 70 "      if   nops(p1)<nops
(p2) then p1:=[op(p1),0$(nops(p2)-nops(p1))];\n" }{MPLTEXT 1 202 70 " \+
     elif nops(p1)>nops(p2) then p2:=[op(p2),0$(nops(p1)-nops(p2))];\n
" }{MPLTEXT 1 202 14 "      end if;\n" }{MPLTEXT 1 202 80 "      if \{
op(zip((i,j)->i-j,p1,p2))\}=\{0\} then return s[0] else return 0 end i
f;\n" }{MPLTEXT 1 202 12 "    end if;\n" }{MPLTEXT 1 202 10 "  end if;
\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 86 "#############
######################################################################
##\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 66 "# ScalarP is the Sch
ur-Hall scalar product on power sum functions\n" }{MPLTEXT 1 202 2 "#
\n" }{MPLTEXT 1 202 19 "ScalarP:=proc(x,y)\n" }{MPLTEXT 1 202 84 "  op
tion `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights re
served.`;\n" }{MPLTEXT 1 202 21 "  local cf,tm,p1,p2;\n" }{MPLTEXT 1 
202 89 "  if not (type(x,pfktpolynom) and type(y,pfktpolynom)) then er
ror \"wrong type\\n\" end if;\n" }{MPLTEXT 1 202 23 "  if type(x,`+`) \+
then \n" }{MPLTEXT 1 202 30 "    return map(procname,x,y);\n" }
{MPLTEXT 1 202 25 "  elif type(x,`*`) then \n" }{MPLTEXT 1 202 43 "   \+
 tm,cf:=selectremove(type,x,pfktmonom);\n" }{MPLTEXT 1 202 29 "    ret
urn cf*procname(tm,y)\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 
25 "    if type(y,`+`) then \n" }{MPLTEXT 1 202 33 "      return map2(
procname,x,y);\n" }{MPLTEXT 1 202 26 "    elif type(y,`*`) then\n" }
{MPLTEXT 1 202 45 "      tm,cf:=selectremove(type,y,pfktmonom);\n" }
{MPLTEXT 1 202 31 "      return cf*procname(x,tm)\n" }{MPLTEXT 1 202 
9 "    else\n" }{MPLTEXT 1 202 10 "      ###\n" }{MPLTEXT 1 202 19 "  \+
    p1:=[op(x)];\n" }{MPLTEXT 1 202 19 "      p2:=[op(y)];\n" }
{MPLTEXT 1 202 56 "      if `+`(op(p1))<>`+`(op(p2)) then return 0 end
 if;\n" }{MPLTEXT 1 202 47 "      if \{op(zip((x,y)->x-y,p1,p2))\}=\{0
\} then \n" }{MPLTEXT 1 202 24 "        return zee(p1) \n" }{MPLTEXT 
1 202 14 "      end if;\n" }{MPLTEXT 1 202 9 "      0;\n" }{MPLTEXT 1 
202 11 "      ### \n" }{MPLTEXT 1 202 12 "    end if;\n" }{MPLTEXT 1 
202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 
83 "##################################################################
################\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 85 "# Scal
arMH is the Schur-Hall scalar product for the dual pair of complete sy
mmetric \n" }{MPLTEXT 1 202 73 "#          functions and monomial symm
etric functions. Alias is ScalarHM\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 20 "ScalarMH:=proc(x,y)\n" }
{MPLTEXT 1 202 84 "   option `Copyright (c) B. Fauser & R. Ablamowicz \+
2004-2009. All rights reserved`;\n" }{MPLTEXT 1 202 39 "   if x=0 or y
=0 then return 0 end if;\n" }{MPLTEXT 1 202 56 "   if type(x,mfktpolyn
om) and type(y,hfktpolynom) then \n" }{MPLTEXT 1 202 57 "      return \+
Scalar(subs(`m`=s,x),subs(`h`=s,y)) end if;\n" }{MPLTEXT 1 202 59 "   \+
   if type(x,hfktpolynom) and type(y,mfktpolynom) then \n" }{MPLTEXT 
1 202 57 "      return Scalar(subs(`h`=s,x),subs(`m`=s,y)) end if;\n" 
}{MPLTEXT 1 202 37 "   error \"unknown type in ScalarHM\";\n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 32 "ScalarHM:=(x,y)->S
calarMH(y,x);\n" }{MPLTEXT 1 202 86 "#################################
####################################################\n" }{MPLTEXT 1 
202 2 "#\n" }{MPLTEXT 1 202 19 "# O U T E R MONOID\n" }{MPLTEXT 1 202 
2 "#\n" }{MPLTEXT 1 202 86 "##########################################
###########################################\n" }{MPLTEXT 1 202 2 "#\n"
 }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 81 "# outer product for S fun
ctions, this is the default proceedure, alias is outerS\n" }{MPLTEXT 
1 202 2 "#\n" }{MPLTEXT 1 202 15 "outer:=proc(x)\n" }{MPLTEXT 1 202 
84 "  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All r
ights reserved.`;\n" }{MPLTEXT 1 202 23 "  local cf,tm,p1,p2,y;\n" }
{MPLTEXT 1 202 35 "  if nargs=1 then return x end if;\n" }{MPLTEXT 1 
202 14 "  y:=args[2];\n" }{MPLTEXT 1 202 38 "  if x=0 or y=0 then retu
rn 0 end if;\n" }{MPLTEXT 1 202 77 "  if nargs>2 then return procname(
expand(procname(x,y)),args[3..-1]) end if;\n" }{MPLTEXT 1 202 94 "  if
 not(type(x,sfktpolynom) and type(args[2],sfktpolynom)) then error \"w
rong type\\n\" end if;\n" }{MPLTEXT 1 202 23 "  if type(x,`+`) then \n
" }{MPLTEXT 1 202 30 "    return map(procname,x,y);\n" }{MPLTEXT 1 
202 25 "  elif type(x,`*`) then \n" }{MPLTEXT 1 202 43 "    tm,cf:=sel
ectremove(type,x,sfktmonom);\n" }{MPLTEXT 1 202 29 "    return cf*proc
name(tm,y)\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 25 "    if \+
type(y,`+`) then \n" }{MPLTEXT 1 202 33 "      return map2(procname,x,
y);\n" }{MPLTEXT 1 202 26 "    elif type(y,`*`) then\n" }{MPLTEXT 1 
202 45 "      tm,cf:=selectremove(type,y,sfktmonom);\n" }{MPLTEXT 1 
202 31 "      return cf*procname(x,tm)\n" }{MPLTEXT 1 202 9 "    else
\n" }{MPLTEXT 1 202 42 "      if x=0 or y=0 then return 0 end if;\n" }
{MPLTEXT 1 202 38 "      p1:=getPart(x): p2:=getPart(y):\n" }{MPLTEXT 
1 202 38 "# +++ it is faster to add fewer boxes\n" }{MPLTEXT 1 202 31 
"# --- the product is symmetric\n" }{MPLTEXT 1 202 39 "      if `+`(op
(p1))<`+`(op(p2)) then \n" }{MPLTEXT 1 202 27 "        return LRR(p2,p
1);\n" }{MPLTEXT 1 202 11 "      else\n" }{MPLTEXT 1 202 27 "        r
eturn LRR(p1,p2);\n" }{MPLTEXT 1 202 14 "      end if;\n" }{MPLTEXT 1 
202 12 "    end if;\n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 
202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 54 "# +++
 alias for outer product in Schur function basis\n" }{MPLTEXT 1 202 2 
"#\n" }{MPLTEXT 1 202 15 "outerS:=outer:\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 80 "# outerLS computes the prod
uct of two or any number of Schur functions [monoms]\n" }{MPLTEXT 1 
202 82 "#     using the Lascoux Schuetzenberger transition algorithm. \+
after some checking\n" }{MPLTEXT 1 202 76 "#     of the input for inva
lid or special input, we produce the permutation\n" }{MPLTEXT 1 202 
74 "#     which is isomorphic to the concatenation of the Lehmer codes
 od the\n" }{MPLTEXT 1 202 71 "#     input Schur functions. The transi
tion algorithm descomposes this\n" }{MPLTEXT 1 202 84 "#     permutati
on into Grassmannian ones which are turned byck into Schur functions\n
" }{MPLTEXT 1 202 36 "#     and then added up for output.\n" }{MPLTEXT
 1 202 2 "#\n" }{MPLTEXT 1 202 17 "outerLS:=proc(x)\n" }{MPLTEXT 1 
202 37 "  local perLst,res,res2,per,i,nopsD;\n" }{MPLTEXT 1 202 20 "  \+
#-- nothing to do\n" }{MPLTEXT 1 202 35 "  if nargs=1 then return x en
d if;\n" }{MPLTEXT 1 202 74 "  #-- concattenate the Lehmer codes of in
puts and turn into a permutation\n" }{MPLTEXT 1 202 83 "  perLst:= [ l
ehmerCodeToPermutation( op([ map(op@schurToLehmerCode1,[args])])) ];\n
" }{MPLTEXT 1 202 37 "  nopsD:=nops(Descents(op(perLst)));\n" }
{MPLTEXT 1 202 54 "  #-- deal with special cases 0 descest output s[0]
, \n" }{MPLTEXT 1 202 58 "  #-- 1 descent=Grassmannian permutation = S
chur function\n" }{MPLTEXT 1 202 19 "  if nopsD=0 then \n" }{MPLTEXT 
1 202 17 "     return s[0]\n" }{MPLTEXT 1 202 21 "  elif nopsD=1 then \+
\n" }{MPLTEXT 1 202 70 "     return lehmerCodeToSchurFkt(permutationTo
LehmerCode(op(perLst)))\n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 
1 202 65 "  # start computation: for all permutations in perlst applay
 the\n" }{MPLTEXT 1 202 70 "  # transition algorithm (possibly increas
ing the length of the list)\n" }{MPLTEXT 1 202 66 "  # If the number o
f descents for a permutatin is 1 add to result\n" }{MPLTEXT 1 202 33 "
  # othewise feed back to perLst\n" }{MPLTEXT 1 202 10 "  res:=0;\n" }
{MPLTEXT 1 202 22 "  while perLst<>[] do\n" }{MPLTEXT 1 202 20 "    pe
r:=perLst[1];\n" }{MPLTEXT 1 202 27 "    perLst:=perLst[2..-1];\n" }
{MPLTEXT 1 202 27 "    res2:=transition(per);\n" }{MPLTEXT 1 202 35 " \+
   for i from 1 to nops(res2) do \n" }{MPLTEXT 1 202 42 "       if nop
s(Descents(res2[i]))=1 then \n" }{MPLTEXT 1 202 75 "          res:=res
+lehmerCodeToSchurFkt(permutationToLehmerCode(res2[i]));\n" }{MPLTEXT 
1 202 12 "       else\n" }{MPLTEXT 1 202 40 "          perLst:=[res2[i
],op(perLst)];\n" }{MPLTEXT 1 202 15 "       end if;\n" }{MPLTEXT 1 
202 12 "    end do;\n" }{MPLTEXT 1 202 12 "  end do;  \n" }{MPLTEXT 1 
202 7 "  res;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#
\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 94 "# concatM_mon multipli
es two monomials (mfktmonom) using the divided power representation of
 \n" }{MPLTEXT 1 202 28 "#             Rota-Stein 94\n" }{MPLTEXT 1 
202 91 "# WARNING:    this is _not_ the outer product of symmetric fun
ctions, but a concatenation \n" }{MPLTEXT 1 202 51 "#             prod
uct in a divided powers algebra!\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 
1 202 34 "#             (Internal use only)\n" }{MPLTEXT 1 202 2 "#\n"
 }{MPLTEXT 1 202 29 "concatM_mon:=proc(fkt1,fkt2)\n" }{MPLTEXT 1 202 
85 "   option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All \+
rights reserved.`,\n" }{MPLTEXT 1 202 13 "   remember;\n" }{MPLTEXT 1 
202 43 "   local mset1,mset2,n1,n2,N,lst,cf,res,i;\n" }{MPLTEXT 1 202 
45 "   if fkt1=0 or fkt2=0 then return 0 end if;\n" }{MPLTEXT 1 202 
61 "   mset1,mset2:=part2mset([op(fkt1)]),part2mset([op(fkt2)]);\n" }
{MPLTEXT 1 202 35 "   n1,n2:=nops(mset1),nops(mset2);\n" }{MPLTEXT 1 
202 17 "   if n1>n2 then\n" }{MPLTEXT 1 202 12 "     N:=n1;\n" }
{MPLTEXT 1 202 35 "     mset2:=[op(mset2),0$(n1-n2)];\n" }{MPLTEXT 1 
202 19 "   elif n2>n1 then\n" }{MPLTEXT 1 202 12 "     N:=n2;\n" }
{MPLTEXT 1 202 35 "     mset1:=[op(mset1),0$(n2-n1)];\n" }{MPLTEXT 1 
202 8 "   else\n" }{MPLTEXT 1 202 12 "     N:=n1;\n" }{MPLTEXT 1 202 
11 "   end if;\n" }{MPLTEXT 1 202 81 "   lst:=[seq([binomial(mset1[i]+
mset2[i],mset1[i]),mset1[i]+mset2[i]] ,i=1..N)];\n" }{MPLTEXT 1 202 
17 "   cf,res:=1,[];\n" }{MPLTEXT 1 202 19 "   for i in lst do\n" }
{MPLTEXT 1 202 18 "     cf:=cf*i[1];\n" }{MPLTEXT 1 202 26 "     res:=
[op(res),i[2]];\n" }{MPLTEXT 1 202 14 "   end do;   \n" }{MPLTEXT 1 
202 29 "   cf*m[op(mset2part(res))];\n" }{MPLTEXT 1 202 10 "end proc:
\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 87 "# concatM provides the
 concatemation product of m-functions (not the outer product of \n" }
{MPLTEXT 1 202 84 "#         symmetric functions!) This product is nee
ded to produce a 'clifford' type\n" }{MPLTEXT 1 202 51 "#         prod
uct for the outer m-function product\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 17 "concatM:=proc(x)\n" }
{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ablamowicz 2
004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 12 "  remember;\n"
 }{MPLTEXT 1 202 23 "  local cf,tm,p1,p2,y;\n" }{MPLTEXT 1 202 35 "  i
f nargs=1 then return x end if;\n" }{MPLTEXT 1 202 14 "  y:=args[2];\n
" }{MPLTEXT 1 202 38 "  if x=0 or y=0 then return 0 end if;\n" }
{MPLTEXT 1 202 77 "  if nargs>2 then return procname(expand(procname(x
,y)),args[3..-1]) end if;\n" }{MPLTEXT 1 202 94 "  if not(type(x,mfktp
olynom) and type(args[2],mfktpolynom)) then error \"wrong type\\n\" en
d if;\n" }{MPLTEXT 1 202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 
202 30 "    return map(procname,x,y);\n" }{MPLTEXT 1 202 25 "  elif ty
pe(x,`*`) then \n" }{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,x,
mfktmonom);\n" }{MPLTEXT 1 202 29 "    return cf*procname(tm,y)\n" }
{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 25 "    if type(y,`+`) the
n \n" }{MPLTEXT 1 202 33 "      return map2(procname,x,y);\n" }
{MPLTEXT 1 202 26 "    elif type(y,`*`) then\n" }{MPLTEXT 1 202 45 "  \+
    tm,cf:=selectremove(type,y,mfktmonom);\n" }{MPLTEXT 1 202 31 "    \+
  return cf*procname(x,tm)\n" }{MPLTEXT 1 202 9 "    else\n" }{MPLTEXT
 1 202 42 "      if x=0 or y=0 then return 0 end if;\n" }{MPLTEXT 1 
202 23 "      concatM_mon(x,y)\n" }{MPLTEXT 1 202 12 "    end if;\n" }
{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 67 "# c
oncat_mon multiplies two monomials (e-, h-, p-function monoms) \n" }
{MPLTEXT 1 202 59 "#            This _is_ the outer product! for these
 bases \n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 34 "#             (
Internal use only)\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 33 "conc
at_mon:=proc(fkt1,fkt2,name)\n" }{MPLTEXT 1 202 85 "   option `Copyrig
ht (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n" 
}{MPLTEXT 1 202 13 "   remember;\n" }{MPLTEXT 1 202 14 "   local lst;
\n" }{MPLTEXT 1 202 29 "   lst:=[op(fkt1),op(fkt2)];\n" }{MPLTEXT 1 
202 66 "   name[op(sort(lst,(i,j)->if i>j then true else false end if)
)];\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 93 "# outerH,E,P are functions providing the outer prod
uct of complete, elementary and power sum\n" }{MPLTEXT 1 202 91 "#    \+
     symmetric functions. These products are the outer products on the
se bases, since\n" }{MPLTEXT 1 202 60 "#         these particular base
s are multiplicateive bases.\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 2 "#\n" }{MPLTEXT 1 202 16 "outerH:=proc(x)\n" }{MPLTEXT 1 202 84 
"  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All righ
ts reserved.`,\n" }{MPLTEXT 1 202 12 "  remember;\n" }{MPLTEXT 1 202 
23 "  local cf,tm,p1,p2,y;\n" }{MPLTEXT 1 202 35 "  if nargs=1 then re
turn x end if;\n" }{MPLTEXT 1 202 14 "  y:=args[2];\n" }{MPLTEXT 1 
202 38 "  if x=0 or y=0 then return 0 end if;\n" }{MPLTEXT 1 202 77 " \+
 if nargs>2 then return procname(expand(procname(x,y)),args[3..-1]) en
d if;\n" }{MPLTEXT 1 202 88 "  if not(type(x,hfktpolynom) and type(y,h
fktpolynom)) then error \"wrong type\\n\" end if;\n" }{MPLTEXT 1 202 
23 "  if type(x,`+`) then \n" }{MPLTEXT 1 202 30 "    return map(procn
ame,x,y);\n" }{MPLTEXT 1 202 25 "  elif type(x,`*`) then \n" }{MPLTEXT
 1 202 43 "    tm,cf:=selectremove(type,x,hfktmonom);\n" }{MPLTEXT 1 
202 29 "    return cf*procname(tm,y)\n" }{MPLTEXT 1 202 7 "  else\n" }
{MPLTEXT 1 202 25 "    if type(y,`+`) then \n" }{MPLTEXT 1 202 33 "   \+
   return map2(procname,x,y);\n" }{MPLTEXT 1 202 26 "    elif type(y,`
*`) then\n" }{MPLTEXT 1 202 45 "      tm,cf:=selectremove(type,y,hfktm
onom);\n" }{MPLTEXT 1 202 31 "      return cf*procname(x,tm)\n" }
{MPLTEXT 1 202 9 "    else\n" }{MPLTEXT 1 202 42 "      if x=0 or y=0 \+
then return 0 end if;\n" }{MPLTEXT 1 202 38 "      if x=h[0] then retu
rn y end if;\n" }{MPLTEXT 1 202 38 "      if y=h[0] then return x end \+
if;\n" }{MPLTEXT 1 202 26 "      concat_mon(x,y,`h`)\n" }{MPLTEXT 1 
202 12 "    end if;\n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 
202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 16 "outerE:=proc(x)\n" }
{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ablamowicz 2
004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 12 "  remember;\n"
 }{MPLTEXT 1 202 23 "  local cf,tm,p1,p2,y;\n" }{MPLTEXT 1 202 35 "  i
f nargs=1 then return x end if;\n" }{MPLTEXT 1 202 14 "  y:=args[2];\n
" }{MPLTEXT 1 202 38 "  if x=0 or y=0 then return 0 end if;\n" }
{MPLTEXT 1 202 77 "  if nargs>2 then return procname(expand(procname(x
,y)),args[3..-1]) end if;\n" }{MPLTEXT 1 202 94 "  if not(type(x,efktp
olynom) and type(args[2],efktpolynom)) then error \"wrong type\\n\" en
d if;\n" }{MPLTEXT 1 202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 
202 30 "    return map(procname,x,y);\n" }{MPLTEXT 1 202 25 "  elif ty
pe(x,`*`) then \n" }{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,x,
efktmonom);\n" }{MPLTEXT 1 202 29 "    return cf*procname(tm,y)\n" }
{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 25 "    if type(y,`+`) the
n \n" }{MPLTEXT 1 202 33 "      return map2(procname,x,y);\n" }
{MPLTEXT 1 202 26 "    elif type(y,`*`) then\n" }{MPLTEXT 1 202 45 "  \+
    tm,cf:=selectremove(type,y,efktmonom);\n" }{MPLTEXT 1 202 31 "    \+
  return cf*procname(x,tm)\n" }{MPLTEXT 1 202 9 "    else\n" }{MPLTEXT
 1 202 42 "      if x=0 or y=0 then return 0 end if;\n" }{MPLTEXT 1 
202 38 "      if x=e[0] then return y end if;\n" }{MPLTEXT 1 202 38 " \+
     if y=e[0] then return x end if;\n" }{MPLTEXT 1 202 26 "      conc
at_mon(x,y,`e`)\n" }{MPLTEXT 1 202 12 "    end if;\n" }{MPLTEXT 1 202 
10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#
\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 
16 "outerP:=proc(x)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. \+
Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 
1 202 12 "  remember;\n" }{MPLTEXT 1 202 23 "  local cf,tm,p1,p2,y;\n"
 }{MPLTEXT 1 202 35 "  if nargs=1 then return x end if;\n" }{MPLTEXT 
1 202 14 "  y:=args[2];\n" }{MPLTEXT 1 202 38 "  if x=0 or y=0 then re
turn 0 end if;\n" }{MPLTEXT 1 202 77 "  if nargs>2 then return procnam
e(expand(procname(x,y)),args[3..-1]) end if;\n" }{MPLTEXT 1 202 94 "  \+
if not(type(x,pfktpolynom) and type(args[2],pfktpolynom)) then error \+
\"wrong type\\n\" end if;\n" }{MPLTEXT 1 202 23 "  if type(x,`+`) then
 \n" }{MPLTEXT 1 202 30 "    return map(procname,x,y);\n" }{MPLTEXT 1 
202 25 "  elif type(x,`*`) then \n" }{MPLTEXT 1 202 43 "    tm,cf:=sel
ectremove(type,x,pfktmonom);\n" }{MPLTEXT 1 202 29 "    return cf*proc
name(tm,y)\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 25 "    if \+
type(y,`+`) then \n" }{MPLTEXT 1 202 33 "      return map2(procname,x,
y);\n" }{MPLTEXT 1 202 26 "    elif type(y,`*`) then\n" }{MPLTEXT 1 
202 45 "      tm,cf:=selectremove(type,y,pfktmonom);\n" }{MPLTEXT 1 
202 31 "      return cf*procname(x,tm)\n" }{MPLTEXT 1 202 9 "    else
\n" }{MPLTEXT 1 202 42 "      if x=0 or y=0 then return 0 end if;\n" }
{MPLTEXT 1 202 38 "      if x=p[0] then return y end if;\n" }{MPLTEXT 
1 202 38 "      if y=p[0] then return x end if;\n" }{MPLTEXT 1 202 26 
"      concat_mon(x,y,`p`)\n" }{MPLTEXT 1 202 12 "    end if;\n" }
{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }
{MPLTEXT 1 202 89 "###################################################
#####################################\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 21 "# O U T E R COMONOID\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 89 "###########################
#############################################################\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 70 "# couterM_mon computes the \+
outer coproduct of the m-basis m-functions\n" }{MPLTEXT 1 202 2 "#\n" 
}{MPLTEXT 1 202 22 "# (Internal use only)\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 24 "couterM_mon:=proc(mfkt)\n" }{MPLTEXT 1 202 84 "  op
tion `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights re
served.`,\n" }{MPLTEXT 1 202 12 "  remember;\n" }{MPLTEXT 1 202 23 "  \+
local mset,T,res,nT;\n" }{MPLTEXT 1 202 35 "  if mfkt=0 then return(0)
 end if;\n" }{MPLTEXT 1 202 31 "  mset:=part2mset([op(mfkt)]);\n" }
{MPLTEXT 1 202 71 "  T:=combinat[cartprod]([seq([seq(k,k=0..mset[i])],
i=1..nops(mset))]):\n" }{MPLTEXT 1 202 11 "  res:=[];\n" }{MPLTEXT 1 
202 27 "  while not T[finished] do\n" }{MPLTEXT 1 202 25 "    nT:=T[ne
xtvalue](); \n" }{MPLTEXT 1 202 33 "    res:=[op(res),[mset-nT,nT]] \n
" }{MPLTEXT 1 202 10 "  end do;\n" }{MPLTEXT 1 202 64 "  add(&t(m[op(m
set2part(i[1]))],m[op(mset2part(i[2]))]),i=res);\n" }{MPLTEXT 1 202 
10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 85 "# couterM computes the outer coproduct in the m-bas
is. This is essentially a wrapper\n" }{MPLTEXT 1 202 80 "#         fun
ction for couterM_mon on monomials, making it multilinear over the\n" 
}{MPLTEXT 1 202 20 "#         integers.\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 17 "couterM:=proc(x)\n" }
{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ablamowicz 2
004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 12 "  remember;\n"
 }{MPLTEXT 1 202 32 "  local cf,tm,n1,plst1,plst2,i;\n" }{MPLTEXT 1 
202 32 "  if x=0 then return(0) end if;\n" }{MPLTEXT 1 202 23 "  if ty
pe(x,`+`) then \n" }{MPLTEXT 1 202 30 "    return map(procname,x,y);\n
" }{MPLTEXT 1 202 25 "  elif type(x,`*`) then \n" }{MPLTEXT 1 202 43 "
    tm,cf:=selectremove(type,x,mfktmonom);\n" }{MPLTEXT 1 202 29 "    \+
return cf*procname(tm,y)\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 
202 48 "    if x=m[0] then return &t(m[0],m[0]) end if;\n" }{MPLTEXT 
1 202 22 "    couterM_mon(x);  \n" }{MPLTEXT 1 202 10 "  end if;\n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 88 "# LaplaceMset is a internal function which implements the Lapl
ace Pairing of Rota-Stein\n" }{MPLTEXT 1 202 86 "#             in tha \+
case of monomial symmetric functions. For efficiency reasons, it\n" }
{MPLTEXT 1 202 84 "#             uses a third representation of sparse
-multisets M(\\prod_k [i_k,ni_k])\n" }{MPLTEXT 1 202 57 "#            \+
 where the zero entries [n,0] are omitted! \n" }{MPLTEXT 1 202 2 "#\n"
 }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 31 "LaplaceMset:=proc(Mset1,M
set2)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ab
lamowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 12 "  re
member;\n" }{MPLTEXT 1 202 32 "  local n1,n2,T,nT,res,a,b,c,d;\n" }
{MPLTEXT 1 202 34 "  n1,n2:=nops(Mset1),nops(Mset2);\n" }{MPLTEXT 1 
202 39 "  # -- check for m[0]=1 cases directly\n" }{MPLTEXT 1 202 43 "
  if n1=0 and n2=0 then return M() end if;\n" }{MPLTEXT 1 202 40 "  if
 n1=0 or n2=0 then return 0 end if;\n" }{MPLTEXT 1 202 15 "  if n1=1 t
hen\n" }{MPLTEXT 1 202 17 "    if n2=1 then\n" }{MPLTEXT 1 202 52 "   \+
   # -- case n1=n2=1 definition applies directly\n" }{MPLTEXT 1 202 
41 "      if op(Mset1)[2]=op(Mset2)[2] then \n" }{MPLTEXT 1 202 60 "  \+
      return M([op(Mset1)[1]+op(Mset2)[1],op(Mset1)[2]]);\n" }{MPLTEXT
 1 202 11 "      else\n" }{MPLTEXT 1 202 18 "        return 0;\n" }
{MPLTEXT 1 202 15 "      end if; \n" }{MPLTEXT 1 202 9 "    else\n" }
{MPLTEXT 1 202 29 "      # --n1=1, n2 a product\n" }{MPLTEXT 1 202 23 
"      return add(MCAT(\n" }{MPLTEXT 1 202 78 "                      p
rocname( M([ op(Mset1)[1] , k ]) , M( op(Mset2)[1] ) )\n" }{MPLTEXT 1 
202 97 "                     ,procname( M([ op(Mset1)[1] , op(Mset1)[2
]-k ]), M( op(Mset2)[2..-1] ) )   \n" }{MPLTEXT 1 202 23 "            \+
         )\n" }{MPLTEXT 1 202 38 "                ,k=0..op(Mset1)[2] )
;\n" }{MPLTEXT 1 202 12 "    end if;\n" }{MPLTEXT 1 202 7 "  else\n" }
{MPLTEXT 1 202 22 "    # -- n1 a product\n" }{MPLTEXT 1 202 17 "    if
 n2=1 then\n" }{MPLTEXT 1 202 28 "      # -- n2 not a product\n" }
{MPLTEXT 1 202 23 "      return add(MCAT(\n" }{MPLTEXT 1 202 78 "     \+
                 procname( M([ op(Mset2)[1] , k ]) , M( op(Mset1)[1] )
 )\n" }{MPLTEXT 1 202 94 "                     ,procname( M([ op(Mset2
)[1] , op(Mset2)[2]-k ]), M( op(Mset1)[2..-1] ) )\n" }{MPLTEXT 1 202 
23 "                     )\n" }{MPLTEXT 1 202 38 "                ,k=0
..op(Mset2)[2] );\n" }{MPLTEXT 1 202 9 "    else\n" }{MPLTEXT 1 202 
58 "      # -- n1 and n2 products, expand second argument ...\n" }
{MPLTEXT 1 202 56 "      a,b:=M([op(Mset1)][1]),M(op([op(Mset1)][2..-1
]));\n" }{MPLTEXT 1 202 58 "      c:=[seq([op(Mset2)][i][1],i=1..nops(
[op(Mset2)]))];\n" }{MPLTEXT 1 202 58 "      d:=[seq([op(Mset2)][i][2]
,i=1..nops([op(Mset2)]))];\n" }{MPLTEXT 1 202 92 "      T:=combinat[ca
rtprod]([seq([seq(k,k=0..[op(Mset2)][i][2])],i=1..nops([op(Mset2)]))])
:\n" }{MPLTEXT 1 202 15 "      res:=[];\n" }{MPLTEXT 1 202 31 "      w
hile not T[finished] do\n" }{MPLTEXT 1 202 29 "        nT:=T[nextvalue
](); \n" }{MPLTEXT 1 202 34 "        res:=[op(res),[d-nT,nT]] \n" }
{MPLTEXT 1 202 14 "      end do;\n" }{MPLTEXT 1 202 16 "      add(MCAT
(\n" }{MPLTEXT 1 202 64 "               procname(a,M(seq([c[k],i[1][k]
],k=1..nops(c)) ))\n" }{MPLTEXT 1 202 64 "              ,procname(b,M(
seq([c[k],i[2][k]],k=1..nops(c)) ))\n" }{MPLTEXT 1 202 16 "           \+
   )\n" }{MPLTEXT 1 202 19 "          ,i=res);\n" }{MPLTEXT 1 202 12 "
    end if;\n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 10 "en
d proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 88 "# LaplaceM_mon \+
is the wrapper function for LaplaceMset and computes the Laplace pairi
ng\n" }{MPLTEXT 1 202 85 "#          between two _monomials_ in the mo
noamial symmetric function basis. Unless\n" }{MPLTEXT 1 202 79 "#     \+
     it is bilinear it is for internal use in the outerM product mainl
y.\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 
32 "LaplaceM_mon:=proc(mfkt1,mfkt2)\n" }{MPLTEXT 1 202 85 "   option `
Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved
.`,\n" }{MPLTEXT 1 202 13 "   remember;\n" }{MPLTEXT 1 202 24 "   loca
l mset1,mset2,f;\n" }{MPLTEXT 1 202 19 "# -- SPECIAL CASES\n" }
{MPLTEXT 1 202 73 "# -- LaplaceM is _not_ graded, by weight of the par
titions of the mfkt's\n" }{MPLTEXT 1 202 71 "# -- However, LaplaceM _i
s graded_ by the _length_ of the partitions!!\n" }{MPLTEXT 1 202 74 "#
 -- The case m[0] is crittical since part2mset does return an empty li
st\n" }{MPLTEXT 1 202 48 "# -- we deal hence with these cases seperate
ly:\n" }{MPLTEXT 1 202 30 "# -- LaplaceM(m[0],m[0])=m[0]\n" }{MPLTEXT 
1 202 63 "# -- LaplaceM(m[0],<any-mfkt>) = 0 = LaplaceM(<any-mfkt>,m[0
])\n" }{MPLTEXT 1 202 65 "   if nops([op(mfkt1)])<>nops([op(mfkt2)]) t
hen return 0 end if;\n" }{MPLTEXT 1 202 57 "   if mfkt1=m[0] and mfkt2
=m[0] then return m[0] end if;\n" }{MPLTEXT 1 202 53 "   if mfkt1=m[0]
 or mfkt2=m[0] then return 0 end if;\n" }{MPLTEXT 1 202 62 "# -- trans
form partitions into msets M([i1,ni1],[i2,ni2],...)\n" }{MPLTEXT 1 
202 63 "   mset1,mset2:=part2mset([op(mfkt1)]),part2mset([op(mfkt2)]);
\n" }{MPLTEXT 1 202 72 "# -- f is a helper function which turns M-set \+
representations back into\n" }{MPLTEXT 1 202 32 "# -- a partition repr
esentation\n" }{MPLTEXT 1 202 13 "   f:=proc()\n" }{MPLTEXT 1 202 17 "
      local x,n;\n" }{MPLTEXT 1 202 23 "      x,n:=args,nargs;\n" }
{MPLTEXT 1 202 56 "      m[op( sort([seq([x][k][1]$[x][k][2],k=1..n)])
 )];\n" }{MPLTEXT 1 202 13 "   end proc:\n" }{MPLTEXT 1 202 44 "# -- c
all the actual LaplaceMset proceedure\n" }{MPLTEXT 1 202 93 "   Laplac
eMset(M(seq([k,mset1[k]],k=1..nops(mset1))),M(seq([k,mset2[k]],k=1..no
ps(mset2))));\n" }{MPLTEXT 1 202 85 "# -- Turn the M-set representatio
n output of LaplaceMset into a partition based form\n" }{MPLTEXT 1 
202 22 "   eval(subs(M=f,%));\n" }{MPLTEXT 1 202 91 "# -- substitute t
he unevaluated concatenation product MCAT into the actual concatM prod
uct\n" }{MPLTEXT 1 202 34 "# -- and return the final result \n" }
{MPLTEXT 1 202 31 "   eval(subs(MCAT=concatM,%));\n" }{MPLTEXT 1 202 
10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 51 "# The wra
pper which makes LaplaceM_mon multilinear\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 21 "LaplaceM2:=proc(x,y)\n" }{MPLTEXT 1 202 84 "  optio
n `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reser
ved.`;\n" }{MPLTEXT 1 202 21 "  local cf,tm,p1,p2;\n" }{MPLTEXT 1 202 
38 "  if x=0 or y=0 then return 0 end if;\n" }{MPLTEXT 1 202 89 "  if \+
not (type(x,mfktpolynom) and type(y,mfktpolynom)) then error \"wrong t
ype\\n\" end if;\n" }{MPLTEXT 1 202 23 "  if type(x,`+`) then \n" }
{MPLTEXT 1 202 30 "    return map(procname,x,y);\n" }{MPLTEXT 1 202 
25 "  elif type(x,`*`) then \n" }{MPLTEXT 1 202 43 "    tm,cf:=selectr
emove(type,x,mfktmonom);\n" }{MPLTEXT 1 202 29 "    return cf*procname
(tm,y)\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 25 "    if type
(y,`+`) then \n" }{MPLTEXT 1 202 33 "      return map2(procname,x,y);
\n" }{MPLTEXT 1 202 26 "    elif type(y,`*`) then\n" }{MPLTEXT 1 202 
45 "      tm,cf:=selectremove(type,y,mfktmonom);\n" }{MPLTEXT 1 202 
31 "      return cf*procname(x,tm)\n" }{MPLTEXT 1 202 9 "    else\n" }
{MPLTEXT 1 202 39 "#      if x=m[0] then return y end if;\n" }{MPLTEXT
 1 202 39 "#      if y=m[0] then return x end if;\n" }{MPLTEXT 1 202 
25 "      LaplaceM_mon(x,y);\n" }{MPLTEXT 1 202 12 "    end if;\n" }
{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }
{MPLTEXT 1 202 85 "###################################################
#################################\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT
 1 202 28 "# Laplace helper functions:\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 85 "# -------------------------------------------------
---------------------------------\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT
 1 202 66 "# LP_l1 computes the LaplaceM pairing for monomials of leng
th < 2\n" }{MPLTEXT 1 202 3 "# \n" }{MPLTEXT 1 202 17 "LP_l1:=proc(x,y
)\n" }{MPLTEXT 1 202 19 "  option remember;\n" }{MPLTEXT 1 202 27 "  i
f x=m[0] or y=m[0] then\n" }{MPLTEXT 1 202 16 "    if y=x then\n" }
{MPLTEXT 1 202 18 "      return m[0]\n" }{MPLTEXT 1 202 10 "    else \+
\n" }{MPLTEXT 1 202 15 "      return 0\n" }{MPLTEXT 1 202 12 "    end \+
if;\n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 25 "  return m
[op(x)+op(y)];\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "
#\n" }{MPLTEXT 1 202 74 "# couterMproper1n computes the proper coprodu
ct slice of length 1,n where\n" }{MPLTEXT 1 202 55 "#                 \+
the original monomial has length n+1\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 25 "couterMproper1n:=proc(x)\n" }{MPLTEXT 1 202 19 "  o
ption remember;\n" }{MPLTEXT 1 202 18 "  local lst,mset;\n" }{MPLTEXT 
1 202 31 "  if x=0 then return 0 end if;\n" }{MPLTEXT 1 202 46 "  if x
=m[0] then return &t(m[0],m[0]) end if;\n" }{MPLTEXT 1 202 16 "  lst:=
\{op(x)\};\n" }{MPLTEXT 1 202 28 "  mset:=part2mset([op(x)]);\n" }
{MPLTEXT 1 202 80 "  add(&t(m[i],m[op( mset2part(mset-[0$(i-1),1,0$(no
ps(mset)-i)]))]) ,i in lst);\n" }{MPLTEXT 1 202 10 "end proc:\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 81 "# LP_mon is the actual Lapl
aceM pairing evaluated on arbitrary m-basis monomials\n" }{MPLTEXT 1 
202 84 "#        LP_mon is faster and more memory efficient than the o
ld algorithm. It was \n" }{MPLTEXT 1 202 51 "#        seriously tested
 against the old routine.\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 
18 "LP_mon:=proc(x,y)\n" }{MPLTEXT 1 202 19 "  option remember;\n" }
{MPLTEXT 1 202 27 "  local lx,ly,f0,beta,res;\n" }{MPLTEXT 1 202 38 " \+
 lx,ly:=nops([op(x)]),nops([op(y)]);\n" }{MPLTEXT 1 202 34 "  if lx<>l
y then return 0 end if;\n" }{MPLTEXT 1 202 41 "  if lx<2 then return L
P_l1(x,y) end if;\n" }{MPLTEXT 1 202 86 "  # -- the Laplace property (
due to the length constraint we need only one direction)\n" }{MPLTEXT 
1 202 55 "  # -- we split of a single entry in the second fcator\n" }
{MPLTEXT 1 202 82 "  # -- the coproduct needs only terms of the length
 type 1,n, this is provided by\n" }{MPLTEXT 1 202 36 "  # -- the funct
ion couterMproper1n\n" }{MPLTEXT 1 202 75 "  # -- beta is a numerical \+
factor needed to split m-basis monomials into a\n" }{MPLTEXT 1 202 69 
"  # -- concatenation product of two parts : concatM(A,B)/beta(C) = C
\n" }{MPLTEXT 1 202 64 "  beta:=coeff(concatM(m[[op(y)][1]], m[op([op(
y)][2..-1])]),y);\n" }{MPLTEXT 1 202 51 "  f0:=(a,b,c,d)->concatM(LP_m
on(a,c),LP_mon(b,d));\n" }{MPLTEXT 1 202 29 "  eval(1/beta*subs(`&t`=f
0, \n" }{MPLTEXT 1 202 69 "     &t( couterMproper1n(x),  m[[op(y)][1]]
, m[op([op(y)][2..-1])] )\n" }{MPLTEXT 1 202 9 "  ));   \n" }{MPLTEXT 
1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 51 "# T
he wrapper which makes LaplaceM_mon multilinear\n" }{MPLTEXT 1 202 2 "
#\n" }{MPLTEXT 1 202 20 "LaplaceM:=proc(x,y)\n" }{MPLTEXT 1 202 84 "  \+
option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights \+
reserved.`;\n" }{MPLTEXT 1 202 21 "  local cf,tm,p1,p2;\n" }{MPLTEXT 
1 202 38 "  if x=0 or y=0 then return 0 end if;\n" }{MPLTEXT 1 202 89 
"  if not (type(x,mfktpolynom) and type(y,mfktpolynom)) then error \"w
rong type\\n\" end if;\n" }{MPLTEXT 1 202 23 "  if type(x,`+`) then \n
" }{MPLTEXT 1 202 30 "    return map(procname,x,y);\n" }{MPLTEXT 1 
202 25 "  elif type(x,`*`) then \n" }{MPLTEXT 1 202 43 "    tm,cf:=sel
ectremove(type,x,mfktmonom);\n" }{MPLTEXT 1 202 29 "    return cf*proc
name(tm,y)\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 25 "    if \+
type(y,`+`) then \n" }{MPLTEXT 1 202 33 "      return map2(procname,x,
y);\n" }{MPLTEXT 1 202 26 "    elif type(y,`*`) then\n" }{MPLTEXT 1 
202 45 "      tm,cf:=selectremove(type,y,mfktmonom);\n" }{MPLTEXT 1 
202 31 "      return cf*procname(x,tm)\n" }{MPLTEXT 1 202 9 "    else
\n" }{MPLTEXT 1 202 19 "      LP_mon(x,y);\n" }{MPLTEXT 1 202 12 "    \+
end if;\n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end pr
oc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 87 "# outerM the cliffo
rdization of the concatM product, the outer product in the monomial\n"
 }{MPLTEXT 1 202 90 "#        symmetric function basis. This function \+
takes 1,2, or n variables (associactive)\n" }{MPLTEXT 1 202 59 "#     \+
   and is multilinear over the integers / fractions.\n" }{MPLTEXT 1 
202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 16 "outerM:=proc(x
)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ablamo
wicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 12 "  rememb
er;\n" }{MPLTEXT 1 202 25 "  local cf,tm,p1,p2,y,f;\n" }{MPLTEXT 1 
202 35 "  if nargs=1 then return x end if;\n" }{MPLTEXT 1 202 14 "  y:
=args[2];\n" }{MPLTEXT 1 202 38 "  if x=0 or y=0 then return 0 end if;
\n" }{MPLTEXT 1 202 77 "  if nargs>2 then return procname(expand(procn
ame(x,y)),args[3..-1]) end if;\n" }{MPLTEXT 1 202 94 "  if not(type(x,
mfktpolynom) and type(args[2],mfktpolynom)) then error \"wrong type\\n
\" end if;\n" }{MPLTEXT 1 202 23 "  if type(x,`+`) then \n" }{MPLTEXT 
1 202 30 "    return map(procname,x,y);\n" }{MPLTEXT 1 202 25 "  elif \+
type(x,`*`) then \n" }{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,
x,mfktmonom);\n" }{MPLTEXT 1 202 29 "    return cf*procname(tm,y)\n" }
{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 25 "    if type(y,`+`) the
n \n" }{MPLTEXT 1 202 33 "      return map2(procname,x,y);\n" }
{MPLTEXT 1 202 26 "    elif type(y,`*`) then\n" }{MPLTEXT 1 202 45 "  \+
    tm,cf:=selectremove(type,y,mfktmonom);\n" }{MPLTEXT 1 202 31 "    \+
  return cf*procname(x,tm)\n" }{MPLTEXT 1 202 9 "    else\n" }{MPLTEXT
 1 202 42 "      if x=0 or y=0 then return 0 end if;\n" }{MPLTEXT 1 
202 65 "      f:=(a,b,c,d)->concatM(LaplaceM_mon(a,c),concatM_mon(b,d)
);\n" }{MPLTEXT 1 202 52 "      eval(subs(`&t`=f,&t(couterM(x),couterM
(y))));\n" }{MPLTEXT 1 202 12 "    end if;\n" }{MPLTEXT 1 202 10 "  en
d if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 89 "########
######################################################################
##########\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 35 "# A D J O I \+
N T OPERATIONS / SKEWS\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 89 "
######################################################################
##################\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 27 "#  +
++ skew shur functions\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 75 "
#  skewLR computes the skew operation by dualiting the outer product b
ased\n" }{MPLTEXT 1 202 87 "#     on the Littlewood-Richarson rule, th
is is slow and ineefective, see skewLS below\n" }{MPLTEXT 1 202 2 "#\n
" }{MPLTEXT 1 202 18 "skewLR:=proc(x,y)\n" }{MPLTEXT 1 202 84 "  optio
n `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reser
ved.`;\n" }{MPLTEXT 1 202 29 "  local cf,tm,n1,n2,n3,plst;\n" }
{MPLTEXT 1 202 35 "  if y=s[0] then return x; end if;\n" }{MPLTEXT 1 
202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 202 30 "    return map(p
rocname,x,y);\n" }{MPLTEXT 1 202 25 "  elif type(x,`*`) then \n" }
{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,x,sfktmonom);\n" }
{MPLTEXT 1 202 29 "    return cf*procname(tm,y)\n" }{MPLTEXT 1 202 7 "
  else\n" }{MPLTEXT 1 202 25 "    if type(y,`+`) then \n" }{MPLTEXT 1 
202 33 "      return map2(procname,x,y);\n" }{MPLTEXT 1 202 26 "    el
if type(y,`*`) then\n" }{MPLTEXT 1 202 45 "      tm,cf:=selectremove(t
ype,y,sfktmonom);\n" }{MPLTEXT 1 202 31 "      return cf*procname(x,tm
)\n" }{MPLTEXT 1 202 9 "    else\n" }{MPLTEXT 1 202 55 "      n1:=`+`(
op(getPart(x))):n2:=`+`(op(getPart(y))):\n" }{MPLTEXT 1 202 17 "      \+
n3:=n1-n2;\n" }{MPLTEXT 1 202 29 "      if n3<0 then return 0 \n" }
{MPLTEXT 1 202 41 "      elif n3=0 then return Scalar(x,y) \n" }
{MPLTEXT 1 202 11 "      else\n" }{MPLTEXT 1 202 52 "        plst:=map
(x->s[op(x)],[op(PartNM(n3,n3))]);\n" }{MPLTEXT 1 202 58 "        retu
rn add(outer(Scalar(x,outer(y,z)),z),z=plst);\n" }{MPLTEXT 1 202 14 " \+
     end if;\n" }{MPLTEXT 1 202 12 "    end if;\n" }{MPLTEXT 1 202 10 
"  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n"
 }{MPLTEXT 1 202 82 "# skewLS computes the skew using the Lascoux Schu
etzenberger transition algorithm\n" }{MPLTEXT 1 202 80 "#     this is \+
by fare the faster skew operation then the above one obtained by \n" }
{MPLTEXT 1 202 46 "#     duality and is therefore set as default\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 22 "skewLS:=proc(sf1,sf2)\n" }
{MPLTEXT 1 202 37 "  local perLst,res,res2,per,i,nopsD;\n" }{MPLTEXT 
1 202 34 "  #-- sf2=s[0] then nothing to do\n" }{MPLTEXT 1 202 38 "  i
f sf2=s[0] then return sf1 end if;\n" }{MPLTEXT 1 202 46 "  #-- check \+
if sf1 covers sf2, otherwise zero\n" }{MPLTEXT 1 202 59 "  if nops([op
(sf1)])<nops([op(sf2)]) then return 0 end if;\n" }{MPLTEXT 1 202 50 " \+
 for i in zip((i,j)->i-j,[op(sf1)],[op(sf2)]) do\n" }{MPLTEXT 1 202 
34 "     if i<0 then return 0 end if;\n" }{MPLTEXT 1 202 10 "  end do;
\n" }{MPLTEXT 1 202 71 "  #-- construct the permutation of the Lehmer \+
code of the skew diagram\n" }{MPLTEXT 1 202 66 "  perLst:=[lehmerCodeT
oPermutation( skewToLehmerCode(sf1,sf2) )];\n" }{MPLTEXT 1 202 37 "  n
opsD:=nops(Descents(op(perLst)));\n" }{MPLTEXT 1 202 54 "  #-- deal wi
th special cases 0 descest output s[0], \n" }{MPLTEXT 1 202 58 "  #-- \+
1 descent=Grassmannian permutation = Schur function\n" }{MPLTEXT 1 
202 19 "  if nopsD=0 then \n" }{MPLTEXT 1 202 17 "     return s[0]\n" 
}{MPLTEXT 1 202 21 "  elif nopsD=1 then \n" }{MPLTEXT 1 202 70 "     r
eturn lehmerCodeToSchurFkt(permutationToLehmerCode(op(perLst)))\n" }
{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 65 "  # start computat
ion: for all permutations in perlst applay the\n" }{MPLTEXT 1 202 70 "
  # transition algorithm (possibly increasing the length of the list)
\n" }{MPLTEXT 1 202 66 "  # If the number of descents for a permutatin
 is 1 add to result\n" }{MPLTEXT 1 202 33 "  # othewise feed back to p
erLst\n" }{MPLTEXT 1 202 10 "  res:=0;\n" }{MPLTEXT 1 202 22 "  while \+
perLst<>[] do\n" }{MPLTEXT 1 202 20 "    per:=perLst[1];\n" }{MPLTEXT 
1 202 27 "    perLst:=perLst[2..-1];\n" }{MPLTEXT 1 202 27 "    res2:=
transition(per);\n" }{MPLTEXT 1 202 35 "    for i from 1 to nops(res2)
 do \n" }{MPLTEXT 1 202 42 "       if nops(Descents(res2[i]))=1 then \+
\n" }{MPLTEXT 1 202 75 "          res:=res+lehmerCodeToSchurFkt(permut
ationToLehmerCode(res2[i]));\n" }{MPLTEXT 1 202 12 "       else\n" }
{MPLTEXT 1 202 40 "          perLst:=[res2[i],op(perLst)];\n" }
{MPLTEXT 1 202 15 "       end if;\n" }{MPLTEXT 1 202 12 "    end do;\n
" }{MPLTEXT 1 202 12 "  end do;  \n" }{MPLTEXT 1 202 7 "  res;\n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 30 "# DEFAULT: skewLS made linear\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 16 "skew:=proc(x,y)\n" }{MPLTEXT 1 202 84 "  option `Co
pyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`
;\n" }{MPLTEXT 1 202 29 "  local cf,tm,n1,n2,n3,plst;\n" }{MPLTEXT 1 
202 35 "  if y=s[0] then return x; end if;\n" }{MPLTEXT 1 202 23 "  if
 type(x,`+`) then \n" }{MPLTEXT 1 202 30 "    return map(procname,x,y)
;\n" }{MPLTEXT 1 202 25 "  elif type(x,`*`) then \n" }{MPLTEXT 1 202 
43 "    tm,cf:=selectremove(type,x,sfktmonom);\n" }{MPLTEXT 1 202 29 "
    return cf*procname(tm,y)\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT
 1 202 25 "    if type(y,`+`) then \n" }{MPLTEXT 1 202 33 "      retur
n map2(procname,x,y);\n" }{MPLTEXT 1 202 26 "    elif type(y,`*`) then
\n" }{MPLTEXT 1 202 45 "      tm,cf:=selectremove(type,y,sfktmonom);\n
" }{MPLTEXT 1 202 31 "      return cf*procname(x,tm)\n" }{MPLTEXT 1 
202 9 "    else\n" }{MPLTEXT 1 202 26 "      return skewLS(x,y);\n" }
{MPLTEXT 1 202 12 "    end if;\n" }{MPLTEXT 1 202 10 "  end if;\n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 20 "couter_mon:=pr
oc(x)\n" }{MPLTEXT 1 202 24 "   local par,parLst,pr;\n" }{MPLTEXT 1 
202 48 "   if x=s[0] then return &t(s[0],s[0]); end if;\n" }{MPLTEXT 
1 202 62 "   if x=s[1] then return &t(s[1],s[0])+&t(s[0],s[1]); end if
;\n" }{MPLTEXT 1 202 17 "   par:=[op(x)];\n" }{MPLTEXT 1 202 35 "   pa
rLst:=partitionsInShape(par);\n" }{MPLTEXT 1 202 57 "   add(&t(s[op(pr
)],skewLS(x,s[op(pr)])), pr in parLst);\n" }{MPLTEXT 1 202 10 "end pro
c:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 
2 "#\n" }{MPLTEXT 1 202 16 "couter:=proc(x)\n" }{MPLTEXT 1 202 84 "  o
ption `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights r
eserved.`;\n" }{MPLTEXT 1 202 32 "  local cf,tm,n1,plst1,plst2,i;\n" }
{MPLTEXT 1 202 66 "  if not type(x,sfktpolynom) then return x*procname
(s[0]) end if;\n" }{MPLTEXT 1 202 23 "  if type(x,`+`) then \n" }
{MPLTEXT 1 202 28 "    return map(procname,x);\n" }{MPLTEXT 1 202 25 "
  elif type(x,`*`) then \n" }{MPLTEXT 1 202 43 "    tm,cf:=selectremov
e(type,x,sfktmonom);\n" }{MPLTEXT 1 202 27 "    return cf*procname(tm)
\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 21 "#----- obsolete c
ode\n" }{MPLTEXT 1 202 49 "#    if x=s[0] then return &t(s[0],s[0]) en
d if;\n" }{MPLTEXT 1 202 30 "#    n1:=`+`(op(getPart(x))):\n" }
{MPLTEXT 1 202 32 "#    tm:=&t(s[0],x)+&t(x,s[0]);\n" }{MPLTEXT 1 202 
29 "#    for i from 1 to n1-1 do\n" }{MPLTEXT 1 202 49 "#       plst1:
=map(x->s[op(x)],PartNM(n1-i,n1));\n" }{MPLTEXT 1 202 46 "#       plst
2:=map(x->s[op(x)],PartNM(i,n1));\n" }{MPLTEXT 1 202 84 "#       tm:=t
m+add(add(subs(s[0]=1,Scalar(x,outer(y,z)))*&t(y,z),y=plst1),z=plst2);
\n" }{MPLTEXT 1 202 13 "#    end do;\n" }{MPLTEXT 1 202 16 "#    retur
n tm;\n" }{MPLTEXT 1 202 26 "    return couter_mon(x);\n" }{MPLTEXT 1 
202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 
2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 81 "# couterH_monom is
 the internal function computing the outer product on complete\n" }
{MPLTEXT 1 202 42 "#              symmetric functions monoms\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 21 "cou
terH_mon:=proc(x)\n" }{MPLTEXT 1 202 85 "   option `Copyright (c) B. F
auser & R. Ablamowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 
1 202 20 "          remember;\n" }{MPLTEXT 1 202 24 "   local prtx,p1,
f,g,l;\n" }{MPLTEXT 1 202 18 "   prtx:=[op(x)];\n" }{MPLTEXT 1 202 60 
"   if prtx=[] or prtx=[0] then return &t(h[0],h[0]) end if;\n" }
{MPLTEXT 1 202 79 "   if nops(prtx)=1 then return add(&t(h[prtx[1]-i],
h[i]),i=0..prtx[1]) end if;\n" }{MPLTEXT 1 202 16 "   p1:=prtx[1];\n" 
}{MPLTEXT 1 202 22 "   prtx:=prtx[2..-1];\n" }{MPLTEXT 1 202 26 "   f:
=(x,y,z)->&t(x,z,y):\n" }{MPLTEXT 1 202 14 "   l:=proc(x)\n" }{MPLTEXT
 1 202 36 "      h[op(subs(0=NULL,[op(x)]))]; \n" }{MPLTEXT 1 202 40 "
      if %=h[] then h[0] else % end if:\n" }{MPLTEXT 1 202 13 "   end \+
proc:\n" }{MPLTEXT 1 202 52 "   g:=(x,y,s,t)->&t(l(outerH(x,y)),l(oute
rH(s,t))):\n" }{MPLTEXT 1 202 21 "   eval(subs(`&t`=g,\n" }{MPLTEXT 1 
202 66 "          add(f(h[p1-i],h[i],procname(h[op(prtx)])) ,i=0..p1) \+
));\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 85 "# couterH computes the oute
r coproduct in the h-basis. This is essentially a wrapper\n" }{MPLTEXT
 1 202 80 "#         function for couterH_mon on monomials, making it \+
multilinear over the\n" }{MPLTEXT 1 202 20 "#         integers.\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 17 "cou
terH:=proc(x)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser
 & R. Ablamowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 
12 "  remember;\n" }{MPLTEXT 1 202 32 "  local cf,tm,n1,plst1,plst2,i;
\n" }{MPLTEXT 1 202 83 "  ####if not type(x,efktpolynom) then return x
*procname(h[0]) end if;#####<<<<<BUG\n" }{MPLTEXT 1 202 66 "  if not t
ype(x,hfktpolynom) then return x*procname(h[0]) end if;\n" }{MPLTEXT 
1 202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 202 30 "    return map
(procname,x,y);\n" }{MPLTEXT 1 202 25 "  elif type(x,`*`) then \n" }
{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,x,hfktmonom);\n" }
{MPLTEXT 1 202 29 "    return cf*procname(tm,y)\n" }{MPLTEXT 1 202 7 "
  else\n" }{MPLTEXT 1 202 25 "    if type(y,`+`) then \n" }{MPLTEXT 1 
202 33 "      return map2(procname,x,y);\n" }{MPLTEXT 1 202 26 "    el
if type(y,`*`) then\n" }{MPLTEXT 1 202 43 "      cf,tm:=selectremove(t
ype,y,integer);\n" }{MPLTEXT 1 202 31 "      return cf*procname(x,tm)
\n" }{MPLTEXT 1 202 9 "    else\n" }{MPLTEXT 1 202 50 "      if x=h[0]
 then return &t(h[0],h[0]) end if;\n" }{MPLTEXT 1 202 24 "      couter
H_mon(x);  \n" }{MPLTEXT 1 202 12 "    end if;\n" }{MPLTEXT 1 202 10 "
  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" 
}{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 81 "# couterE_mon is the inter
nal function computing the outer product on elementary\n" }{MPLTEXT 1 
202 42 "#              symmetric functions monoms\n" }{MPLTEXT 1 202 
2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 21 "couterE_mon:=proc(
x)\n" }{MPLTEXT 1 202 85 "   option `Copyright (c) B. Fauser & R. Abla
mowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 20 "      \+
    remember;\n" }{MPLTEXT 1 202 24 "   local prtx,p1,f,g,l;\n" }
{MPLTEXT 1 202 18 "   prtx:=[op(x)];\n" }{MPLTEXT 1 202 60 "   if prtx
=[] or prtx=[0] then return &t(e[0],e[0]) end if;\n" }{MPLTEXT 1 202 
79 "   if nops(prtx)=1 then return add(&t(e[prtx[1]-i],e[i]),i=0..prtx
[1]) end if;\n" }{MPLTEXT 1 202 16 "   p1:=prtx[1];\n" }{MPLTEXT 1 
202 22 "   prtx:=prtx[2..-1];\n" }{MPLTEXT 1 202 26 "   f:=(x,y,z)->&t
(x,z,y):\n" }{MPLTEXT 1 202 14 "   l:=proc(x)\n" }{MPLTEXT 1 202 36 " \+
     e[op(subs(0=NULL,[op(x)]))]; \n" }{MPLTEXT 1 202 40 "      if %=e
[] then e[0] else % end if:\n" }{MPLTEXT 1 202 13 "   end proc:\n" }
{MPLTEXT 1 202 52 "   g:=(x,y,s,t)->&t(l(outerE(x,y)),l(outerE(s,t))):
\n" }{MPLTEXT 1 202 21 "   eval(subs(`&t`=g,\n" }{MPLTEXT 1 202 66 "  \+
        add(f(e[p1-i],e[i],procname(e[op(prtx)])) ,i=0..p1) ));\n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 2 "#\n" }{MPLTEXT 1 202 85 "# couterE computes the outer coproduct
 in the e-basis. This is essentially a wrapper\n" }{MPLTEXT 1 202 80 "
#         function for couterE_mon on monomials, making it multilinear
 over the\n" }{MPLTEXT 1 202 20 "#         integers.\n" }{MPLTEXT 1 
202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 17 "couterE:=proc(
x)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ablam
owicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 12 "  remem
ber;\n" }{MPLTEXT 1 202 32 "  local cf,tm,n1,plst1,plst2,i;\n" }
{MPLTEXT 1 202 66 "  if not type(x,efktpolynom) then return x*procname
(e[0]) end if;\n" }{MPLTEXT 1 202 23 "  if type(x,`+`) then \n" }
{MPLTEXT 1 202 30 "    return map(procname,x,y);\n" }{MPLTEXT 1 202 
25 "  elif type(x,`*`) then \n" }{MPLTEXT 1 202 43 "    tm,cf:=selectr
emove(type,x,efktmonom);\n" }{MPLTEXT 1 202 29 "    return cf*procname
(tm,y)\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 22 "    couterE
_mon(x);  \n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end
 proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 80 "# couterP_mon is the internal function computing the outer pro
duct on power sum\n" }{MPLTEXT 1 202 42 "#              symmetric func
tions monoms\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 21 "couterP_mon:=proc(x)\n" }{MPLTEXT 1 202 85 "   opti
on `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights rese
rved.`,\n" }{MPLTEXT 1 202 20 "          remember;\n" }{MPLTEXT 1 202 
24 "   local prtx,p1,f,g,l;\n" }{MPLTEXT 1 202 18 "   prtx:=[op(x)];\n
" }{MPLTEXT 1 202 60 "   if prtx=[] or prtx=[0] then return &t(p[0],p[
0]) end if;\n" }{MPLTEXT 1 202 61 "   if nops(prtx)=1 then return &t(x
,p[0])+&t(p[0],x) end if;\n" }{MPLTEXT 1 202 16 "   p1:=prtx[1];\n" }
{MPLTEXT 1 202 22 "   prtx:=prtx[2..-1];\n" }{MPLTEXT 1 202 26 "   f:=
(x,y,z)->&t(x,z,y):\n" }{MPLTEXT 1 202 14 "   l:=proc(x)\n" }{MPLTEXT 
1 202 36 "      p[op(subs(0=NULL,[op(x)]))]; \n" }{MPLTEXT 1 202 40 " \+
     if %=p[] then p[0] else % end if:\n" }{MPLTEXT 1 202 13 "   end p
roc:\n" }{MPLTEXT 1 202 52 "   g:=(x,y,s,t)->&t(l(outerP(x,y)),l(outer
P(s,t))):\n" }{MPLTEXT 1 202 21 "   eval(subs(`&t`=g,\n" }{MPLTEXT 1 
202 46 "          f(p[p1],p[0],procname(p[op(prtx)]))\n" }{MPLTEXT 1 
202 50 "         +f(p[0],p[p1],procname(p[op(prtx)])) ));\n" }{MPLTEXT
 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n
" }{MPLTEXT 1 202 85 "# couterP computes the outer coproduct in the p-
basis. This is essentially a wrapper\n" }{MPLTEXT 1 202 80 "#         \+
function for couterP_mon on monomials, making it multilinear over the
\n" }{MPLTEXT 1 202 20 "#         integers.\n" }{MPLTEXT 1 202 2 "#\n"
 }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 17 "couterP:=proc(x)\n" }
{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ablamowicz 2
004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 12 "  remember;\n"
 }{MPLTEXT 1 202 32 "  local cf,tm,n1,plst1,plst2,i;\n" }{MPLTEXT 1 
202 82 "  if not type(x,pfktpolynom) then error \"Power sum polynom ex
pected....\"; end if;\n" }{MPLTEXT 1 202 31 "  if x=0 then return 0 en
d if;\n" }{MPLTEXT 1 202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 
202 30 "    return map(procname,x,y);\n" }{MPLTEXT 1 202 25 "  elif ty
pe(x,`*`) then \n" }{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,x,
pfktmonom);\n" }{MPLTEXT 1 202 29 "    return cf*procname(tm,y)\n" }
{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 22 "    couterP_mon(x);  \+
\n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" 
}{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 30 "# antipode for the Sfuncti
ons\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 23 "antipS_mon:=proc(sfkt)\n" }{MPLTEXT 1 202 85 "  option `Copyri
ght (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`; \n
" }{MPLTEXT 1 202 25 "  local p1,Lambda,i,k,N;\n" }{MPLTEXT 1 202 18 "
  p1:=[op(sfkt)];\n" }{MPLTEXT 1 202 44 "  if `+`(op(p1))=0 then retur
n s[0] end if;\n" }{MPLTEXT 1 202 27 "  Lambda:=[0$`+`(op(p1))]:\n" }
{MPLTEXT 1 202 30 "  for i from 1 to nops(p1) do\n" }{MPLTEXT 1 202 
27 "  for k from 1 to p1[i] do\n" }{MPLTEXT 1 202 28 "    Lambda[k]:=L
ambda[k]+1;\n" }{MPLTEXT 1 202 18 "  end do: end do:\n" }{MPLTEXT 1 
202 62 "  Lambda:=map(x-> if x=0 then NULL else x end if ,Lambda);   \+
\n" }{MPLTEXT 1 202 37 "  (-1)^(`+`(op(p1)))*s[op(Lambda)]; \n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 52 "# linear version for the antipode of the Sfunctions\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 16 "ant
ipS:=proc(x)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser \+
& R. Ablamowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 
12 "  remember;\n" }{MPLTEXT 1 202 32 "  local cf,tm,n1,plst1,plst2,i;
\n" }{MPLTEXT 1 202 31 "  if x=0 then return 0 end if;\n" }{MPLTEXT 1 
202 37 "  if x=s[0] then return s[0] end if;\n" }{MPLTEXT 1 202 23 "  \+
if type(x,`+`) then \n" }{MPLTEXT 1 202 28 "    return map(procname,x)
;\n" }{MPLTEXT 1 202 25 "  elif type(x,`*`) then \n" }{MPLTEXT 1 202 
43 "    tm,cf:=selectremove(type,x,sfktmonom);\n" }{MPLTEXT 1 202 27 "
    return cf*procname(tm)\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 
1 202 21 "    antipS_mon(x);  \n" }{MPLTEXT 1 202 10 "  end if;\n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 34 "# antipode in the power sum basis\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 23 "antipP_mon:=proc(pfkt)\n" }
{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ablamowicz 2
004-2009. All rights reserved.`;\n" }{MPLTEXT 1 202 33 "  (-1)^(nops([
op(pfkt)]))*pfkt; \n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 
202 2 "#\n" }{MPLTEXT 1 202 40 "# linear form of the power sum antipod
e\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 
16 "antipP:=proc(x)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. \+
Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 
1 202 12 "  remember;\n" }{MPLTEXT 1 202 32 "  local cf,tm,n1,plst1,pl
st2,i;\n" }{MPLTEXT 1 202 31 "  if x=0 then return 0 end if;\n" }
{MPLTEXT 1 202 37 "  if x=p[0] then return p[0] end if;\n" }{MPLTEXT 
1 202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 202 28 "    return map
(procname,x);\n" }{MPLTEXT 1 202 25 "  elif type(x,`*`) then \n" }
{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,x,pfktmonom);\n" }
{MPLTEXT 1 202 27 "    return cf*procname(tm)\n" }{MPLTEXT 1 202 7 "  \+
else\n" }{MPLTEXT 1 202 21 "    antipP_mon(x);  \n" }{MPLTEXT 1 202 
10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#
\n" }{MPLTEXT 1 202 77 "# antipH_mon is the recursively defined antipo
de for the complete symmetric \n" }{MPLTEXT 1 202 43 "#            fun
ctions (internal use only)\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 
28 "antipH_mon:=proc(hfktmonom)\n" }{MPLTEXT 1 202 84 "  option `Copyr
ight (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n
" }{MPLTEXT 1 202 19 "         remember;\n" }{MPLTEXT 1 202 11 "  loca
l f;\n" }{MPLTEXT 1 202 46 "  if op(hfktmonom)=0 then return h[0] end \+
if;\n" }{MPLTEXT 1 202 37 "  f:=(x,y)->outerH(antipH_mon(x),y):\n" }
{MPLTEXT 1 202 61 "  eval(subs(`&t`=f,-couterH(hfktmonom)+&t(hfktmonom
,h[0])));\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" 
}{MPLTEXT 1 202 44 "# antipH is the linear version of antiH_mon\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 16 "antipH:=proc(x)\n" }
{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ablamowicz 2
004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 12 "  remember;\n"
 }{MPLTEXT 1 202 32 "  local cf,tm,n1,plst1,plst2,i;\n" }{MPLTEXT 1 
202 31 "  if x=0 then return 0 end if;\n" }{MPLTEXT 1 202 37 "  if x=h
[0] then return h[0] end if;\n" }{MPLTEXT 1 202 23 "  if type(x,`+`) t
hen \n" }{MPLTEXT 1 202 28 "    return map(procname,x);\n" }{MPLTEXT 
1 202 25 "  elif type(x,`*`) then \n" }{MPLTEXT 1 202 43 "    tm,cf:=s
electremove(type,x,hfktmonom);\n" }{MPLTEXT 1 202 27 "    return cf*pr
ocname(tm)\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 21 "    ant
ipH_mon(x);  \n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 10 "
end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 79 "# antipE_mon \+
is the recursively defined antipode for the elementary symmetric \n" }
{MPLTEXT 1 202 43 "#            functions (internal use only)\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 28 "antipE_mon:=proc(efktmonom)
\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ablamow
icz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 19 "         \+
remember;\n" }{MPLTEXT 1 202 11 "  local f;\n" }{MPLTEXT 1 202 46 "  i
f op(efktmonom)=0 then return e[0] end if;\n" }{MPLTEXT 1 202 37 "  f:
=(x,y)->outerE(antipE_mon(x),y):\n" }{MPLTEXT 1 202 61 "  eval(subs(`&
t`=f,-couterE(efktmonom)+&t(efktmonom,e[0])));\n" }{MPLTEXT 1 202 10 "
end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 44 "# antipE is t
he linear version of antiE_mon\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 16 "antipE:=proc(x)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c)
 B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n" }
{MPLTEXT 1 202 12 "  remember;\n" }{MPLTEXT 1 202 32 "  local cf,tm,n1
,plst1,plst2,i;\n" }{MPLTEXT 1 202 31 "  if x=0 then return 0 end if;
\n" }{MPLTEXT 1 202 37 "  if x=e[0] then return e[0] end if;\n" }
{MPLTEXT 1 202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 202 28 "    r
eturn map(procname,x);\n" }{MPLTEXT 1 202 25 "  elif type(x,`*`) then \+
\n" }{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,x,efktmonom);\n" 
}{MPLTEXT 1 202 27 "    return cf*procname(tm)\n" }{MPLTEXT 1 202 7 " \+
 else\n" }{MPLTEXT 1 202 21 "    antipE_mon(x);  \n" }{MPLTEXT 1 202 
10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#
\n" }{MPLTEXT 1 202 77 "# antipM_mon is the recursively defined antipo
de for the monomial symmetric \n" }{MPLTEXT 1 202 43 "#            fun
ctions (internal use only)\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 
28 "antipM_mon:=proc(mfktmonom)\n" }{MPLTEXT 1 202 84 "  option `Copyr
ight (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n
" }{MPLTEXT 1 202 19 "         remember;\n" }{MPLTEXT 1 202 11 "  loca
l f;\n" }{MPLTEXT 1 202 46 "  if op(mfktmonom)=0 then return m[0] end \+
if;\n" }{MPLTEXT 1 202 37 "  f:=(x,y)->outerM(antipM_mon(x),y):\n" }
{MPLTEXT 1 202 61 "  eval(subs(`&t`=f,-couterM(mfktmonom)+&t(mfktmonom
,m[0])));\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" 
}{MPLTEXT 1 202 45 "# antipM is the linear version of antipM_mon\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 16 "antipM:=proc(x)\n" }
{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ablamowicz 2
004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 12 "  remember;\n"
 }{MPLTEXT 1 202 32 "  local cf,tm,n1,plst1,plst2,i;\n" }{MPLTEXT 1 
202 31 "  if x=0 then return 0 end if;\n" }{MPLTEXT 1 202 37 "  if x=m
[0] then return m[0] end if;\n" }{MPLTEXT 1 202 23 "  if type(x,`+`) t
hen \n" }{MPLTEXT 1 202 28 "    return map(procname,x);\n" }{MPLTEXT 
1 202 25 "  elif type(x,`*`) then \n" }{MPLTEXT 1 202 43 "    tm,cf:=s
electremove(type,x,mfktmonom);\n" }{MPLTEXT 1 202 27 "    return cf*pr
ocname(tm)\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 21 "    ant
ipM_mon(x);  \n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 10 "
end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 91 "# linear vers
ion for the antipode of the Hopf algebra of outer coproduct and concat
enation\n" }{MPLTEXT 1 202 32 "#   -- in the monomial basis...\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 17 "ant
ipMC:=proc(x)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser
 & R. Ablamowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 
12 "  remember;\n" }{MPLTEXT 1 202 17 "  local cf,term;\n" }{MPLTEXT 
1 202 31 "  if x=0 then return 0 end if;\n" }{MPLTEXT 1 202 37 "  if x
=m[0] then return m[0] end if;\n" }{MPLTEXT 1 202 23 "  if type(x,`+`)
 then \n" }{MPLTEXT 1 202 28 "    return map(procname,x);\n" }{MPLTEXT
 1 202 25 "  elif type(x,`*`) then \n" }{MPLTEXT 1 202 45 "    term,cf
:=selectremove(type,x,mfktmonom);\n" }{MPLTEXT 1 202 29 "    return cf
*procname(term)\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 35 "  \+
  return (-1)^nops(op([x]))*x;  \n" }{MPLTEXT 1 202 10 "  end if;\n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 89 "##################
######################################################################
\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 14 "# T A B L E S\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 89 "###########################
#############################################################\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 81 "# KostkaTable returns an eq
uation Kostka'N'=matrix where matrix is the matrix of\n" }{MPLTEXT 1 
202 78 "#             Kostka numbers in the anti lexicographic orderin
g of partitions\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 30 "KostkaT
able:=proc(N::integer)\n" }{MPLTEXT 1 202 85 "  option `Copyright (c) \+
B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`; \n" }
{MPLTEXT 1 202 21 "  local part,sn,mks;\n" }{MPLTEXT 1 202 36 "  mks:=
(lst)->map(i->s[op(i)],lst);\n" }{MPLTEXT 1 202 21 "  part:=PartNM(N,N
);\n" }{MPLTEXT 1 202 27 "  sn:=map(i->mks(i),part);\n" }{MPLTEXT 1 
202 123 "  cat(Kostka,N)=subs(s[0]=1,evalm(linalg[matrix](nops(part),n
ops(part),(i,j)->Scalar( s[op(part[i])],outer(op(sn[j]))))));\n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 85 "# LaplaceTable returns the matrix of the Rota-Stein Laplace pa
iring for the monomial\n" }{MPLTEXT 1 202 82 "#              symmetric
 function deformation. It is presented in the graded anti\n" }{MPLTEXT
 1 202 81 "#              lexicographic ordering, which respects the g
rading of the Laplace\n" }{MPLTEXT 1 202 83 "#              pairing (b
lock diagonal form). First row and colums show the basis \n" }{MPLTEXT
 1 202 26 "#              partitions\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 24 "LaplaceTable:=proc(N,M)\n" }{MPLTEXT 1 202 84 "  op
tion `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights re
served.`;\n" }{MPLTEXT 1 202 19 "  local prtN,prtM;\n" }{MPLTEXT 1 
202 72 "  prtN,prtM:=sort(PartNM(N,N),grAlexComp),sort(PartNM(M,M),grA
lexComp);\n" }{MPLTEXT 1 202 44 "  linalg[matrix](nops(prtN)+1,nops(pr
tM)+1,\n" }{MPLTEXT 1 202 35 "       (i,j)->if i=1 and j=1 then \n" }
{MPLTEXT 1 202 39 "                `<x|y>` elif j=1 then \n" }{MPLTEXT
 1 202 41 "                prtN[i-1] elif i=1 then \n" }{MPLTEXT 1 
202 34 "                prtM[j-1] else   \n" }{MPLTEXT 1 202 51 "     \+
           LaplaceM_mon(prtN[i-1],prtM[j-1]) \n" }{MPLTEXT 1 202 23 " \+
             end if);\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 
202 1 "\n" }{MPLTEXT 1 202 75 "#######################################
###################################\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 32 "# I N N E R MONOID and COMONOID\n" }{MPLTEXT 1 202 
2 "#\n" }{MPLTEXT 1 202 29 "#           Power Sum Basis \n" }{MPLTEXT 
1 202 2 "#\n" }{MPLTEXT 1 202 75 "####################################
######################################\n" }{MPLTEXT 1 202 1 "\n" }
{MPLTEXT 1 202 75 "###################################################
#######################\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 69 
"# innerH_mon the inner product of symmetric functions in the h-basis
\n" }{MPLTEXT 1 202 77 "#     -- it is based on the Laplace property o
f the inner and outer products\n" }{MPLTEXT 1 202 61 "#     -- i)  (a.
b) o c = \\sum_(c)  (a o c_(1)) . (b o c_(2))\n" }{MPLTEXT 1 202 61 "#
     -- ii) c o (a.b) = \\sum_(c)  (c_(1) o a) . (c_(2) o b)\n" }
{MPLTEXT 1 202 29 "#     -- where we have used:\n" }{MPLTEXT 1 202 26 
"#     --  . outer product\n" }{MPLTEXT 1 202 65 "#     --  \\Delta(c)
= \\sum_(c) c_(1) otimes c_(2) outer coproduct\n" }{MPLTEXT 1 202 27 "
#     --  o inner product \n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 
36 "innerH_mon:=proc(hfktmon1,hfktmon2)\n" }{MPLTEXT 1 202 19 "  local
 n,m,coh,f;\n" }{MPLTEXT 1 202 50 "  n,m:=nops([op(hfktmon1)]),nops([o
p(hfktmon2)]);\n" }{MPLTEXT 1 202 48 "  if `+`(op(hfktmon1))<> `+`(op(
hfktmon2)) then\n" }{MPLTEXT 1 202 15 "     return 0;\n" }{MPLTEXT 1 
202 16 "  elif n=1 then\n" }{MPLTEXT 1 202 22 "     return hfktmon2;\n
" }{MPLTEXT 1 202 16 "  elif m=1 then\n" }{MPLTEXT 1 202 22 "     retu
rn hfktmon1;\n" }{MPLTEXT 1 202 16 "  elif n<m then\n" }{MPLTEXT 1 
202 61 "     f:=(a,b,x,y)->outerH(innerH_mon(a,x),innerH_mon(b,y)); \n
" }{MPLTEXT 1 202 83 "     coh:=&t(couterH(hfktmon1),h[[op(hfktmon2)][
1]],h[op([op(hfktmon2)][2..-1])]);\n" }{MPLTEXT 1 202 36 "     return \+
eval(subs(`&t`=f,coh));\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 
202 61 "     f:=(a,b,x,y)->outerH(innerH_mon(a,x),innerH_mon(b,y)); \n
" }{MPLTEXT 1 202 83 "     coh:=&t(couterH(hfktmon2),h[[op(hfktmon1)][
1]],h[op([op(hfktmon1)][2..-1])]);\n" }{MPLTEXT 1 202 36 "     return \+
eval(subs(`&t`=f,coh));\n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 
1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 45 "# i
nnerH is the linear version of innerH_mon\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 16 "innerH:=proc(x)\n" }
{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser & R. Ablamowicz 2
004-2009. All rights reserved.`,\n" }{MPLTEXT 1 202 12 "  remember;\n"
 }{MPLTEXT 1 202 25 "  local cf,tm,p1,p2,y,f;\n" }{MPLTEXT 1 202 35 " \+
 if nargs=1 then return x end if;\n" }{MPLTEXT 1 202 14 "  y:=args[2];
\n" }{MPLTEXT 1 202 38 "  if x=0 or y=0 then return 0 end if;\n" }
{MPLTEXT 1 202 77 "  if nargs>2 then return procname(expand(procname(x
,y)),args[3..-1]) end if;\n" }{MPLTEXT 1 202 94 "  if not(type(x,hfktp
olynom) and type(args[2],hfktpolynom)) then error \"wrong type\\n\" en
d if;\n" }{MPLTEXT 1 202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 
202 30 "    return map(procname,x,y);\n" }{MPLTEXT 1 202 25 "  elif ty
pe(x,`*`) then \n" }{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,x,
hfktmonom);\n" }{MPLTEXT 1 202 29 "    return cf*procname(tm,y)\n" }
{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 25 "    if type(y,`+`) the
n \n" }{MPLTEXT 1 202 33 "      return map2(procname,x,y);\n" }
{MPLTEXT 1 202 26 "    elif type(y,`*`) then\n" }{MPLTEXT 1 202 45 "  \+
    tm,cf:=selectremove(type,y,hfktmonom);\n" }{MPLTEXT 1 202 31 "    \+
  return cf*procname(x,tm)\n" }{MPLTEXT 1 202 9 "    else\n" }{MPLTEXT
 1 202 23 "      innerH_mon(x,y);\n" }{MPLTEXT 1 202 12 "    end if;\n
" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }
{MPLTEXT 1 202 88 "###################################################
####################################\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 83 "# inner is the inner product on Schur functions. It
 establishes the tensor product\n" }{MPLTEXT 1 202 78 "#    of S_n rep
resentations in terms of their characters under the Frobenius \n" }
{MPLTEXT 1 202 25 "#    characteristic map.\n" }{MPLTEXT 1 202 2 "#\n"
 }{MPLTEXT 1 202 31 "inner_mon := proc(sfkt1,sfkt2)\n" }{MPLTEXT 1 
202 85 "  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. A
ll rights reserved.`; \n" }{MPLTEXT 1 202 39 "  local n1,n2,prt,mat,i,
k,lst1,lst2,m;\n" }{MPLTEXT 1 202 21 "  lst1:=[op(sfkt1)];\n" }
{MPLTEXT 1 202 21 "  lst2:=[op(sfkt2)];\n" }{MPLTEXT 1 202 21 "  n1:=`
+`(op(lst1));\n" }{MPLTEXT 1 202 21 "  n2:=`+`(op(lst2));\n" }{MPLTEXT
 1 202 34 "  if n1<>n2 then return 0 end if;\n" }{MPLTEXT 1 202 58 "  \+
if op(sfkt1)=0 and op(sfkt2)=0 then return s[0] end if;\n" }{MPLTEXT 
1 202 22 "  prt:=PartNM(n1,n1);\n" }{MPLTEXT 1 202 17 "  n2:=nops(prt)
;\n" }{MPLTEXT 1 202 51 "  mat:=matrix(n2,n2,(i,j)->MurNak(prt[j],prt[
i]));\n" }{MPLTEXT 1 202 45 " # -- find position of lst1, and lst2 in \+
prt\n" }{MPLTEXT 1 202 45 "  i:=1:while prt[i]<>lst1 do i:=i+1; end do
;\n" }{MPLTEXT 1 202 45 "  k:=1:while prt[k]<>lst2 do k:=k+1; end do;
\n" }{MPLTEXT 1 202 54 " # -- use the characters to generate the multp
. table\n" }{MPLTEXT 1 202 11 "  add(add(\n" }{MPLTEXT 1 202 62 "    z
ee(prt[l])^(-1)*mat[i,l]*mat[k,l]*mat[m,l]*s[op(prt[m])]\n" }{MPLTEXT 
1 202 33 "      ,l=1..nops(prt)),m=1..n2);\n" }{MPLTEXT 1 202 57 "####
####################################################\n" }{MPLTEXT 1 
202 3 "##\n" }{MPLTEXT 1 202 74 "##  this is a direct way to compute t
he inner product, needs to be tested\n" }{MPLTEXT 1 202 61 "##  in spe
ed against the above version, rsults are the same.\n" }{MPLTEXT 1 202 
62 "##  Note: in MurNak seems to be a transposition, so that here\n" }
{MPLTEXT 1 202 56 "##        MurNak(par1,par2) = scalarPS(p[par1],s[pa
r2])\n" }{MPLTEXT 1 202 3 "##\n" }{MPLTEXT 1 202 13 "##  add(add(\n" }
{MPLTEXT 1 202 87 "##    zee(rho)^(-1)*MurNak(rho,lst1)*MurNak(rho,lst
2)*MurNak(rho,lambda)*s[op(lambda)]\n" }{MPLTEXT 1 202 36 "##      ,rh
o in prt),lambda in prt)\n" }{MPLTEXT 1 202 1 "\n" }{MPLTEXT 1 202 10 
"end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 15 "inner:=proc(x)\n" }{MPLTEXT 1 202 84 "  option `Cop
yright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,
\n" }{MPLTEXT 1 202 12 "  remember;\n" }{MPLTEXT 1 202 25 "  local cf,
tm,p1,p2,y,f;\n" }{MPLTEXT 1 202 35 "  if nargs=1 then return x end if
;\n" }{MPLTEXT 1 202 14 "  y:=args[2];\n" }{MPLTEXT 1 202 38 "  if x=0
 or y=0 then return 0 end if;\n" }{MPLTEXT 1 202 69 "  if nargs>2 then
 return procname(procname(x,y),args[3..-1]) end if;\n" }{MPLTEXT 1 
202 94 "  if not(type(x,sfktpolynom) and type(args[2],sfktpolynom)) th
en error \"wrong type\\n\" end if;\n" }{MPLTEXT 1 202 23 "  if type(x,
`+`) then \n" }{MPLTEXT 1 202 30 "    return map(procname,x,y);\n" }
{MPLTEXT 1 202 25 "  elif type(x,`*`) then \n" }{MPLTEXT 1 202 43 "   \+
 tm,cf:=selectremove(type,x,sfktmonom);\n" }{MPLTEXT 1 202 29 "    ret
urn cf*procname(tm,y)\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 
25 "    if type(y,`+`) then \n" }{MPLTEXT 1 202 33 "      return map2(
procname,x,y);\n" }{MPLTEXT 1 202 26 "    elif type(y,`*`) then\n" }
{MPLTEXT 1 202 45 "      tm,cf:=selectremove(type,y,sfktmonom);\n" }
{MPLTEXT 1 202 31 "      return cf*procname(x,tm)\n" }{MPLTEXT 1 202 
9 "    else\n" }{MPLTEXT 1 202 42 "      if x=0 or y=0 then return 0 e
nd if;\n" }{MPLTEXT 1 202 21 "      inner_mon(x,y)\n" }{MPLTEXT 1 202 
12 "    end if;\n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 
10 "end proc:\n" }{MPLTEXT 1 202 86 "#################################
####################################################\n" }{MPLTEXT 1 
202 2 "#\n" }{MPLTEXT 1 202 76 "# innerM implements the inner product \+
for monomial symmetric function bases\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 86 "###################################################
##################################\n" }{MPLTEXT 1 202 16 "innerM:=proc
(x)\n" }{MPLTEXT 1 202 16 "   local y,lst;\n" }{MPLTEXT 1 202 36 "   i
f nargs=1 then return x end if;\n" }{MPLTEXT 1 202 19 "   if nargs>2 t
hen\n" }{MPLTEXT 1 202 17 "     y:=args[2];\n" }{MPLTEXT 1 202 23 "   \+
  lst:=args[3..-1];\n" }{MPLTEXT 1 202 50 "     return procname(expand
(procname(x,y)),lst); \n" }{MPLTEXT 1 202 8 "   else\n" }{MPLTEXT 1 
202 17 "     y:=args[2];\n" }{MPLTEXT 1 202 42 "     p_to_m(innerP(m_t
o_p(x),m_to_p(y)));\n" }{MPLTEXT 1 202 11 "   end if;\n" }{MPLTEXT 1 
202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 80 "# cin
ner_mon is the inner coproduct on monomials, it is the Schur-Hall dual
 of \n" }{MPLTEXT 1 202 80 "#            the inner product of Schur fu
nctions and is computed by using that\n" }{MPLTEXT 1 202 30 "#        \+
    particular fact.\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 23 "ci
nner_mon:=proc(sfkt)\n" }{MPLTEXT 1 202 85 "  option `Copyright (c) B.
 Fauser & R. Ablamowicz 2004-2009. All rights reserved.`; \n" }
{MPLTEXT 1 202 23 "  local n1,n2,prt,lst;\n" }{MPLTEXT 1 202 34 "  if \+
sfkt=0 then return 0 end if;\n" }{MPLTEXT 1 202 19 "  lst:=[op(sfkt)];
\n" }{MPLTEXT 1 202 49 "  if sfkt=s[0] then return &t(s[0],s[0]) end i
f;\n" }{MPLTEXT 1 202 20 "  n1:=`+`(op(lst));\n" }{MPLTEXT 1 202 32 " \+
 prt:=SchurFkt:-PartNM(n1,n1);\n" }{MPLTEXT 1 202 54 "  add(&t(s[op(i)
],inner(s[op(i)],s[op(lst)])),i=prt);\n" }{MPLTEXT 1 202 10 "end proc:
\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 45 "# cinner is the linear
 version of cinner_mon\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 16 "
cinner:=proc(x)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Faus
er & R. Ablamowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 
202 12 "  remember;\n" }{MPLTEXT 1 202 32 "  local cf,tm,n1,plst1,plst
2,i;\n" }{MPLTEXT 1 202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 202 
28 "    return map(procname,x);\n" }{MPLTEXT 1 202 25 "  elif type(x,`
*`) then \n" }{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,x,sfktmo
nom);\n" }{MPLTEXT 1 202 27 "    return cf*procname(tm)\n" }{MPLTEXT 
1 202 7 "  else\n" }{MPLTEXT 1 202 21 "    cinner_mon(x);  \n" }
{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 65 "# counitInnerS computes the
 counit of the inner coporduct in the\n" }{MPLTEXT 1 202 30 "#        \+
Schur function basis\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 22 "co
unitInnerS:=proc(x)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. \+
Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 
1 202 12 "  remember;\n" }{MPLTEXT 1 202 15 "  local cf,tm;\n" }
{MPLTEXT 1 202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 202 36 "    r
eturn map(procname,x,serName);\n" }{MPLTEXT 1 202 25 "  elif type(x,`*
`) then \n" }{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,x,sfktmon
om);\n" }{MPLTEXT 1 202 35 "    return cf*procname(tm,serName)\n" }
{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 42 "    subs(s[0]=1,Scalar
(x,s[`+`(op(x))]));\n" }{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 
202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 65 "# inn
erP_mon computer the inner product of power sum functions. \n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 32 "innerP_mon := proc(pfkt1,pf
kt2)\n" }{MPLTEXT 1 202 85 "  option `Copyright (c) B. Fauser & R. Abl
amowicz 2004-2009. All rights reserved.`; \n" }{MPLTEXT 1 202 30 "  lo
cal n1,n2,bool,lst1,lst2;\n" }{MPLTEXT 1 202 22 "  n1:=`+`(op(pfkt1));
\n" }{MPLTEXT 1 202 22 "  n2:=`+`(op(pfkt2));\n" }{MPLTEXT 1 202 34 " \+
 if n1<>n2 then return 0 end if;\n" }{MPLTEXT 1 202 92 "  bool:=map(x-
>if x=0 then true else false end if,zip((x,y)->x-y,[op(pfkt1)],[op(pfk
t2)]));\n" }{MPLTEXT 1 202 35 "  if convert(bool,set)=\{true\} then\n"
 }{MPLTEXT 1 202 35 "    return zee([op(pfkt1)])*pfkt1;\n" }{MPLTEXT 
1 202 8 "  else \n" }{MPLTEXT 1 202 14 "    return 0;\n" }{MPLTEXT 1 
202 11 "  end if; \n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 
202 2 "#\n" }{MPLTEXT 1 202 76 "# innerP is the multilinear version of
 the inner product in power sum basis\n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 16 "innerP:=proc(x)\n" }{MPLTEXT 1 202 84 "  option `Co
pyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`
,\n" }{MPLTEXT 1 202 12 "  remember;\n" }{MPLTEXT 1 202 25 "  local cf
,tm,p1,p2,y,f;\n" }{MPLTEXT 1 202 35 "  if nargs=1 then return x end i
f;\n" }{MPLTEXT 1 202 14 "  y:=args[2];\n" }{MPLTEXT 1 202 38 "  if x=
0 or y=0 then return 0 end if;\n" }{MPLTEXT 1 202 77 "  if nargs>2 the
n return procname(expand(procname(x,y)),args[3..-1]) end if;\n" }
{MPLTEXT 1 202 94 "  if not(type(x,pfktpolynom) and type(args[2],pfktp
olynom)) then error \"wrong type\\n\" end if;\n" }{MPLTEXT 1 202 23 " \+
 if type(x,`+`) then \n" }{MPLTEXT 1 202 30 "    return map(procname,x
,y);\n" }{MPLTEXT 1 202 25 "  elif type(x,`*`) then \n" }{MPLTEXT 1 
202 43 "    tm,cf:=selectremove(type,x,pfktmonom);\n" }{MPLTEXT 1 202 
29 "    return cf*procname(tm,y)\n" }{MPLTEXT 1 202 7 "  else\n" }
{MPLTEXT 1 202 25 "    if type(y,`+`) then \n" }{MPLTEXT 1 202 33 "   \+
   return map2(procname,x,y);\n" }{MPLTEXT 1 202 26 "    elif type(y,`
*`) then\n" }{MPLTEXT 1 202 45 "      tm,cf:=selectremove(type,y,pfktm
onom);\n" }{MPLTEXT 1 202 31 "      return cf*procname(x,tm)\n" }
{MPLTEXT 1 202 9 "    else\n" }{MPLTEXT 1 202 23 "      innerP_mon(x,y
);\n" }{MPLTEXT 1 202 12 "    end if;\n" }{MPLTEXT 1 202 10 "  end if;
\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT
 1 202 73 "# cinnerP_mon computes the inner coproduct on monomials in \+
the power sum\n" }{MPLTEXT 1 202 71 "#             basis, this coprodu
ct is grouplike on all basis elements\n" }{MPLTEXT 1 202 31 "#        \+
     x |-->  &t(x,x) \n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 21 "c
innerP_mon:=proc(x)\n" }{MPLTEXT 1 202 11 "  &t(x,x);\n" }{MPLTEXT 1 
202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 71 "# cin
nerP linear version of the inner coproduct in the power sum basis\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 17 "cin
nerP:=proc(x)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fauser
 & R. Ablamowicz 2004-2008. All rights reserved.`,\n" }{MPLTEXT 1 202 
12 "  remember;\n" }{MPLTEXT 1 202 15 "  local cf,tm;\n" }{MPLTEXT 1 
202 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 202 28 "    return map(p
rocname,x);\n" }{MPLTEXT 1 202 25 "  elif type(x,`*`) then \n" }
{MPLTEXT 1 202 43 "    tm,cf:=selectremove(type,x,pfktmonom);\n" }
{MPLTEXT 1 202 27 "    return cf*procname(tm)\n" }{MPLTEXT 1 202 7 "  \+
else\n" }{MPLTEXT 1 202 20 "    cinnerP_mon(x);\n" }{MPLTEXT 1 202 10 
"  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n"
 }{MPLTEXT 1 202 71 "# cinnerP linear version of the inner coproduct i
n the power sum basis\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#
\n" }{MPLTEXT 1 202 22 "counitInnerP:=proc(x)\n" }{MPLTEXT 1 202 84 " \+
 option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2008. All rights
 reserved.`,\n" }{MPLTEXT 1 202 12 "  remember;\n" }{MPLTEXT 1 202 15 
"  local cf,tm;\n" }{MPLTEXT 1 202 23 "  if type(x,`+`) then \n" }
{MPLTEXT 1 202 28 "    return map(procname,x);\n" }{MPLTEXT 1 202 25 "
  elif type(x,`*`) then \n" }{MPLTEXT 1 202 43 "    tm,cf:=selectremov
e(type,x,sfktmonom);\n" }{MPLTEXT 1 202 27 "    return cf*procname(tm)
\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 1 202 14 "    return 1;\n" 
}{MPLTEXT 1 202 10 "  end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }
{MPLTEXT 1 202 66 "###################################################
##############\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 67 "#  cdiag
 implements the diagonalization coproduc in all 5 standard\n" }
{MPLTEXT 1 202 64 "#        bases the default basis is the 'p-basis' o
f power sums\n" }{MPLTEXT 1 202 66 "#        This implements (if based
 on power sums) effectively the\n" }{MPLTEXT 1 202 26 "#        inner \+
coproduct.\n" }{MPLTEXT 1 202 64 "#  NOTE: The cdiag(x,TYPE) functions
 are _different_ if another\n" }{MPLTEXT 1 202 57 "#        basis is c
hosen. cdiag(x,s) <> cdiag(x,m) etc. \n" }{MPLTEXT 1 202 2 "#\n" }
{MPLTEXT 1 202 66 "###################################################
##############\n" }{MPLTEXT 1 202 15 "cdiag:=proc(x)\n" }{MPLTEXT 1 
202 84 "  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2006. A
ll rights reserved.`;\n" }{MPLTEXT 1 202 22 "  local cf,term,TYPE;\n" 
}{MPLTEXT 1 202 18 "  if nargs=2 then\n" }{MPLTEXT 1 202 19 "    TYPE:
=args[2];\n" }{MPLTEXT 1 202 43 "    if not member(TYPE,\{s,p,m,h,f,e
\}) then\n" }{MPLTEXT 1 202 100 "      error \"You picked a type '%1' \+
which is not in my list of known types\\n 's,p,m,h,f,e' !\",TYPE;\n" }
{MPLTEXT 1 202 12 "    end if;\n" }{MPLTEXT 1 202 8 "  else \n" }
{MPLTEXT 1 202 15 "    TYPE:='p';\n" }{MPLTEXT 1 202 10 "  end if;\n" 
}{MPLTEXT 1 202 32 "  if x=0 then return 0; end if;\n" }{MPLTEXT 1 
202 39 "  if type(x,cat(TYPE,fktpolynom)) then\n" }{MPLTEXT 1 202 24 "
    if type(x,`+`) then\n" }{MPLTEXT 1 202 35 "      return map(procna
me,x,TYPE);\n" }{MPLTEXT 1 202 26 "    elif type(x,`*`) then\n" }
{MPLTEXT 1 202 56 "      term,cf:=selectremove(type,x,cat(TYPE,fktmono
m));\n" }{MPLTEXT 1 202 37 "      return cf*procname(term,TYPE);\n" }
{MPLTEXT 1 202 9 "    else\n" }{MPLTEXT 1 202 22 "      return &t(x,x)
;\n" }{MPLTEXT 1 202 12 "    end if;\n" }{MPLTEXT 1 202 7 "  else\n" }
{MPLTEXT 1 202 91 "    error \"No basis monom of type `%1` found, allo
wed types are in \{s,p,h,m,e,f\}!\\n\",TYPE;\n" }{MPLTEXT 1 202 10 "  \+
end if;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 85 "######
######################################################################
########\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 12 "# Plethysms\n"
 }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 85 "#########################
###########################################################\n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 77 "# list_divisors(n::posint) \+
-> a list of all natrural numbers which divide n \n" }{MPLTEXT 1 202 
2 "#\n" }{MPLTEXT 1 202 23 "list_divisors:=proc(x)\n" }{MPLTEXT 1 202 
85 "  option `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All r
ights reserved.`; \n" }{MPLTEXT 1 202 17 "  local i,t,res;\n" }
{MPLTEXT 1 202 33 "  if x=1 then return [1] end if;\n" }{MPLTEXT 1 
202 11 "  res:=[];\n" }{MPLTEXT 1 202 32 "  for i from 1 to floor(x/2)
 do\n" }{MPLTEXT 1 202 18 "    t:=irem(x,i);\n" }{MPLTEXT 1 202 18 "  \+
  if t = 0 then\n" }{MPLTEXT 1 202 24 "      res:=[op(res),i];\n" }
{MPLTEXT 1 202 12 "    end if;\n" }{MPLTEXT 1 202 12 "  end do;  \n" }
{MPLTEXT 1 202 15 "  [op(res),x];\n" }{MPLTEXT 1 202 5 "end:\n" }
{MPLTEXT 1 202 85 "###################################################
#################################\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT
 1 202 49 "# plethysm coproduct of a single part power sum \n" }
{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 85 "###########################
#########################################################\n" }{MPLTEXT
 1 202 26 "plethPsingleP:=proc(pfkt)\n" }{MPLTEXT 1 202 86 "   option \+
`Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserve
d.`; \n" }{MPLTEXT 1 202 18 "   local part,ld;\n" }{MPLTEXT 1 202 21 "
   part:=[op(pfkt)];\n" }{MPLTEXT 1 202 32 "   ld:=list_divisors(op(pa
rt));\n" }{MPLTEXT 1 202 37 "   add(&t(p[i],p[op(part)/i]),i=ld);\n" }
{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 
202 79 "# plethP_mon computes the plethysm between two power sum basis
 monoms. We have\n" }{MPLTEXT 1 202 26 "#       -- p_0[p\\mu]=p[0]\n" 
}{MPLTEXT 1 202 26 "#       -- p_\\mu[p_0]=p_0\n" }{MPLTEXT 1 202 26 "
#       -- p_n[p_m]=p_n.m\n" }{MPLTEXT 1 202 42 "#       -- p_n[p_mu]=
p_\\mu[p_n] and hence\n" }{MPLTEXT 1 202 54 "#       -- p_\\mu[p_\\nu]
 = \\prod_(i,j) p_[\\mu_i.\\nu_j]\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT
 1 202 77 "# NOTE: THIS VERSION SEEMS TO BE SLOWER THAN THE BELOW GIVE
N BY A FACTOR 1.5\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 23 "#plet
hP_mon:=proc(x,y)\n" }{MPLTEXT 1 202 85 "#  option `Copyright (c) B. F
auser & R. Ablamowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 
1 202 20 "#         remember;\n" }{MPLTEXT 1 202 16 "#  local p1,p2;\n
" }{MPLTEXT 1 202 27 "#  p1,p2:=[op(x)],[op(y)];\n" }{MPLTEXT 1 202 
48 "#  if p1=[0] or p2=[0] then return p[0] end if;\n" }{MPLTEXT 1 
202 22 "#  if nops(p1)=1 then\n" }{MPLTEXT 1 202 24 "#    if nops(p2)=
1 then\n" }{MPLTEXT 1 202 32 "#       return p[op(p1)*op(p2)]\n" }
{MPLTEXT 1 202 10 "#    else\n" }{MPLTEXT 1 202 42 "#       return p[o
p(map(x->op(p1)*x,p2))]\n" }{MPLTEXT 1 202 12 "#    end if\n" }
{MPLTEXT 1 202 8 "#  else\n" }{MPLTEXT 1 202 44 "#    outerP(seq(procn
ame(p[l],y),l in p1));\n" }{MPLTEXT 1 202 11 "#  end if;\n" }{MPLTEXT 
1 202 11 "#end proc:\n" }{MPLTEXT 1 202 83 "##########################
########################################################\n" }{MPLTEXT 
1 202 79 "# plethP_mon is the plethysm product on power sum symmetric \+
monomial functions\n" }{MPLTEXT 1 202 28 "#   -- nonrecursive version
\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 
30 "plethP_mon:=proc(pfkt1,pfkt2)\n" }{MPLTEXT 1 202 84 "  option `Cop
yright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;
\n" }{MPLTEXT 1 202 21 "  local part1,part2;\n" }{MPLTEXT 1 202 22 "  \+
part1:=[op(pfkt1)];\n" }{MPLTEXT 1 202 22 "  part2:=[op(pfkt2)];\n" }
{MPLTEXT 1 202 16 "     p[op(sort(\n" }{MPLTEXT 1 202 74 "         [se
q(seq(part1[i]*part2[j],i=1..nops(part1)),j=1..nops(part2))],\n" }
{MPLTEXT 1 202 51 "         (i,j)->if i>j then true else false end if
\n" }{MPLTEXT 1 202 16 "           ))];\n" }{MPLTEXT 1 202 10 "end pro
c:\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 40 "# plethysm of power \+
sum polynomials ...\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 21 "# p
lethP(P,Q) = P[Q]\n" }{MPLTEXT 1 202 43 "#  -- linear in P   (P1+P2)[Q
]=P1[Q]+P2[Q]\n" }{MPLTEXT 1 202 31 "#  -- not linear in Q, that is\n"
 }{MPLTEXT 1 202 95 "#  -- P[Q1+Q2]=P_(1)[Q1].P_(2)[Q2]  where \\Delta
(P)=P_(1) \\otimes P_(2) is the outer coproduct\n" }{MPLTEXT 1 202 95 
"#  -- P[Q1.Q2]=P_[1][Q1].P_[2][Q2]  where \\delta(P)=P_[1] \\otimes P
_[2] is the inner corpoduct\n" }{MPLTEXT 1 202 71 "#                  \+
                 (this case is trated in plethP_mon\n" }{MPLTEXT 1 
202 91 "#  -- P[-Q]=(antipP(P))[Q]          hence we need to split Q i
n to a positive and negative\n" }{MPLTEXT 1 202 41 "#                 \+
                  part\n" }{MPLTEXT 1 202 2 "#\n" }{MPLTEXT 1 202 18 "
plethP:=proc(x,y)\n" }{MPLTEXT 1 202 84 "  option `Copyright (c) B. Fa
user & R. Ablamowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 
202 19 "         remember;\n" }{MPLTEXT 1 202 42 "  local cf,term,term
2,cout,sgn,f0,f1,a,b;\n" }{MPLTEXT 1 202 28 "  if type(x,pfktmonom) th
en\n" }{MPLTEXT 1 202 39 "    if x=p[0] then return p[0] end if;\n" }
{MPLTEXT 1 202 36 "    if x=p[1] then return y end if;\n" }{MPLTEXT 1 
202 30 "    if type(y,pfktmonom) then\n" }{MPLTEXT 1 202 41 "      if \+
y=p[0] then return p[0] end if;\n" }{MPLTEXT 1 202 38 "      if y=p[1]
 then return x end if;\n" }{MPLTEXT 1 202 29 "      return plethP_mon(
x,y)\n" }{MPLTEXT 1 202 26 "    elif type(y,`*`) then\n" }{MPLTEXT 1 
202 68 "#  -- note that cf*term = term+term+...+term is the additive c
ase!!\n" }{MPLTEXT 1 202 47 "      term,cf:=selectremove(type,y,pfktmo
nom);\n" }{MPLTEXT 1 202 31 "      if type(cf,integer) then\n" }
{MPLTEXT 1 202 21 "        if cf<0 then\n" }{MPLTEXT 1 202 58 "       \+
   return (-1)^nops([op(x)])*procname(x,-cf*term);\n" }{MPLTEXT 1 202 
16 "        end if;\n" }{MPLTEXT 1 202 77 "#  -- put a bracket [cf-1] \+
to prevent linear expansion in the tensor &t(...)\n" }{MPLTEXT 1 202 
43 "        cout:=&t(couterP(x),[cf-1],term); \n" }{MPLTEXT 1 202 62 "
        f0:=(u,v,c,t)->outerP(plethP(u,t),plethP(v,op(c)*t));\n" }
{MPLTEXT 1 202 41 "        return eval(subs(`&t`=f0,cout));\n" }
{MPLTEXT 1 202 11 "      else\n" }{MPLTEXT 1 202 75 "#  -- put a brack
et [cf] to prevent linear expansion in the tensor &t(...)\n" }{MPLTEXT
 1 202 58 "   #  -- works but is slower than a direct computation...\n
" }{MPLTEXT 1 202 41 "   #     cout:=&t(cinnerP(x),[cf],term);\n" }
{MPLTEXT 1 202 69 "   #     f1:=(x1,x2,cf,term)->dimGLP(x1,op(cf))*ple
thP_mon(x2,term);\n" }{MPLTEXT 1 202 43 "   #     return eval(subs(`&t
`=f1,cout ));\n" }{MPLTEXT 1 202 95 "   #     error(\"2nd argument nee
d to be a polynomial over the integers but received: %1\\n\",y);\n" }
{MPLTEXT 1 202 52 "        return cf^nops([op(x)])*plethP_mon(x,term);
\n" }{MPLTEXT 1 202 14 "      end if;\n" }{MPLTEXT 1 202 9 "    else\n
" }{MPLTEXT 1 202 21 "      cout:=[op(y)];\n" }{MPLTEXT 1 202 32 "    \+
  a,b:=cout[1],cout[2..-1];\n" }{MPLTEXT 1 202 34 "      cout:=&t(cout
erP(x),[a],b);\n" }{MPLTEXT 1 202 67 "      f0:=(u,v,c,t)->outerP(plet
hP(u,op(c)),plethP(v,`+`(op(t)))):\n" }{MPLTEXT 1 202 45 "         ret
urn eval(subs(`&t`=f0,cout));   \n" }{MPLTEXT 1 202 12 "    end if;\n"
 }{MPLTEXT 1 202 24 "  elif type(x,`*`) then\n" }{MPLTEXT 1 202 45 "  \+
  term,cf:=selectremove(type,x,pfktmonom);\n" }{MPLTEXT 1 202 32 "    \+
return cf*procname(term,y);\n" }{MPLTEXT 1 202 7 "  else\n" }{MPLTEXT 
1 202 30 "    return map(procname,x,y);\n" }{MPLTEXT 1 202 10 "  end i
f;\n" }{MPLTEXT 1 202 10 "end proc:\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT
 1 0 61 "# cplethP is the plethystic coproduct on power sum functions
\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 20 "cple
thP:=proc(pfkt)\n" }{MPLTEXT 1 0 84 "  option `Copyright (c) B. Fauser
 & R. Ablamowicz 2004-2009. All rights reserved.`;\n" }{MPLTEXT 1 0 
44 "  local cf,term,llst,dlst,res,i,Npi,pi,dPi;\n" }{MPLTEXT 1 0 3 "##
\n" }{MPLTEXT 1 0 26 "  if type(pfkt,`+`) then \n" }{MPLTEXT 1 0 30 " \+
   return map(procname,pfkt)\n" }{MPLTEXT 1 0 27 "  elif type(pfkt,`*`
) then\n" }{MPLTEXT 1 0 48 "    term,cf:=selectremove(type,pfkt,pfktmo
nom);\n" }{MPLTEXT 1 0 29 "    return cf*procname(term)\n" }{MPLTEXT 
1 0 7 "  else\n" }{MPLTEXT 1 0 9 "  ######\n" }{MPLTEXT 1 0 20 "    pi
:=[op(pfkt)];\n" }{MPLTEXT 1 0 22 "    Npi:=`+`(op(pi));\n" }{MPLTEXT 
1 0 29 "    dPi:=list_divisors(Npi);\n" }{MPLTEXT 1 0 12 "    res:=0;
\n" }{MPLTEXT 1 0 20 "    for i in dPi do\n" }{MPLTEXT 1 0 26 "       \+
llst:=PartNM(i,i);\n" }{MPLTEXT 1 0 34 "       dlst:=PartNM(Npi/i,Npi/
i);\n" }{MPLTEXT 1 0 17 "       res:=res+\n" }{MPLTEXT 1 0 18 "       \+
  add(add(\n" }{MPLTEXT 1 0 30 "            1/(zee(l)*zee(d))\n" }
{MPLTEXT 1 0 80 "            *ScalarP(p[op(pi)],plethP(p[op(l)],p[op(d
)]))*&t(p[op(l)],p[op(d)])\n" }{MPLTEXT 1 0 30 "            ,l=llst),d
=dlst);\n" }{MPLTEXT 1 0 12 "    end do;\n" }{MPLTEXT 1 0 9 "    res;
\n" }{MPLTEXT 1 0 9 "  ######\n" }{MPLTEXT 1 0 11 "  end if; \n" }
{MPLTEXT 1 0 10 "end proc:\n" }{MPLTEXT 1 0 82 "######################
###########################################################\n" }
{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 25 "#    SFunction PLETHYSMS\n" }
{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 82 "###############################
##################################################\n" }{MPLTEXT 1 0 2 
"#\n" }{MPLTEXT 1 0 61 "# plethysm of two complete symmetric functions
 aka s[n],s[m]\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 95 "#   -- we us
e the notation P[Q]=pleth(P,Q), hence the plethysm is linear in P (fir
st variable)\n" }{MPLTEXT 1 0 90 "#   -- the plethysm is not linear in
 the second variable Q, it distributes with the inner\n" }{MPLTEXT 1 
0 47 "#   -- coproduct over the the second argument:\n" }{MPLTEXT 1 0 
40 "#   -- P[Q1.Q2]=P_\{[1]\}[Q1].P_\{[2]\}[Q2]\n" }{MPLTEXT 1 0 92 "#
   -- if P is given in a power sum basis, then \\delta P = P_[1]\\otim
es P_[2] = P \\otimes P\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 34 "#  \+
+++ plethsp(sfkt,pfkt) -> sfkt\n" }{MPLTEXT 1 0 90 "#   --         thi
s function is based on the transition s_to_p and the power sum plethys
m\n" }{MPLTEXT 1 0 84 "#   --         of pfktmonomials, followed by a \+
transformation back into sfunctions!\n" }{MPLTEXT 1 0 67 "#   --      \+
   plethP_mon computes pfktmonom[pfktmonom] plethysms \n" }{MPLTEXT 1 
0 89 "#   --         Since x=s[n] is a one row sfkt (complete function
), the characters in the\n" }{MPLTEXT 1 0 72 "#   --         expansion
s are all 1 and dissapear from the computation.\n" }{MPLTEXT 1 0 2 "#
\n" }{MPLTEXT 1 0 19 "plethsp:=proc(x,y)\n" }{MPLTEXT 1 0 84 "  option
 `Copyright (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserv
ed.`,\n" }{MPLTEXT 1 0 12 "  remember;\n" }{MPLTEXT 1 0 11 "  local n;
\n" }{MPLTEXT 1 0 12 "  n:=op(x);\n" }{MPLTEXT 1 0 61 "  p_to_s(add(1/
zee(i)*plethP(y,p[op(i)]),i in PartNM(n,n)));\n" }{MPLTEXT 1 0 10 "end
 proc:\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 34 "# +++ plethSnm(sfkt,
sfkt) -> sfkt\n" }{MPLTEXT 1 0 86 "#  --      this function expands th
e outer one row Sfunction into power sums (without\n" }{MPLTEXT 1 0 
78 "#  --      characters as in plethsp above) and uses afterwards the
 fact that \n" }{MPLTEXT 1 0 87 "#  --      p_n[Q] = Q[p_n] for one pa
rt (primitive) power sum functions. The remaining\n" }{MPLTEXT 1 0 85 
"#  --      plethysms are of the form s_n[p_k] which can be computed v
ia the function\n" }{MPLTEXT 1 0 34 "#  --      plethsp defined above.
\n" }{MPLTEXT 1 0 83 "#  --      This function does not make use of a \+
possible cancellation of terms due\n" }{MPLTEXT 1 0 66 "#  --      to \+
the finiteness of dimenions (the alphabet involved)\n" }{MPLTEXT 1 0 
79 "#  --      This function is by fare not optimal (see Axel Kohnert'
s algorithm)\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 20 "plethSnm:=proc
(x,y)\n" }{MPLTEXT 1 0 84 "  option `Copyright (c) B. Fauser & R. Abla
mowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 0 12 "  rememb
er;\n" }{MPLTEXT 1 0 13 "  local n,m;\n" }{MPLTEXT 1 0 20 "  n,m:=op(x
),op(y);\n" }{MPLTEXT 1 0 15 "  if n=0 then \n" }{MPLTEXT 1 0 16 "    \+
return s[0]\n" }{MPLTEXT 1 0 17 "  elif m=0 then \n" }{MPLTEXT 1 0 16 
"    return s[0]\n" }{MPLTEXT 1 0 16 "  elif n=1 then\n" }{MPLTEXT 1 
0 13 "    return y\n" }{MPLTEXT 1 0 17 "  elif m=1 then \n" }{MPLTEXT 
1 0 13 "    return x\n" }{MPLTEXT 1 0 11 "  end if; \n" }{MPLTEXT 1 0 
83 "  add(1/zee(i)*outer(op(map((k)->plethsp(s[m],p[k]),[op(i)]))) ,i \+
in PartNM(n,n));\n" }{MPLTEXT 1 0 10 "end proc:\n" }{MPLTEXT 1 0 2 "#
\n" }{MPLTEXT 1 0 32 "# plethSP: sfkt x pfkt --> sfkt\n" }{MPLTEXT 1 
0 86 "# +++   plethSP realized the pletysm of an Sfucntion monom by a \+
pfktmonom for general\n" }{MPLTEXT 1 0 82 "#  --   partitions \\lambda
,\\mu. This time we need to insert the characters of the\n" }{MPLTEXT 
1 0 68 "#  --   s_to_p transition computed via the Murnaghan Nakayama \+
rule.\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 27 "#  ++   plethSP shows
 that\n" }{MPLTEXT 1 0 34 "#  ++   plethSP(s[n],p[0]) = s[0]\n" }
{MPLTEXT 1 0 59 "#  ++   plethSP(s[lambda],p[0]) = 0  for \\length(lam
bda)>1\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 19 "plethSP:=proc(x,y)\n
" }{MPLTEXT 1 0 84 "  option `Copyright (c) B. Fauser & R. Ablamowicz \+
2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 0 12 "  remember;\n" 
}{MPLTEXT 1 0 13 "  local i,n;\n" }{MPLTEXT 1 0 17 "  n:=`+`(op(x));\n
" }{MPLTEXT 1 0 79 "  p_to_s(add(1/zee(i)*MurNak(i,[op(x)])*plethP(y,p
[op(i)]),i in PartNM(n,n)));\n" }{MPLTEXT 1 0 10 "end proc:\n" }
{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 36 "# plethS_
mon : sfkt x sfkt --> sfkt\n" }{MPLTEXT 1 0 86 "# +++ plethS_mon compu
tes the pletysm of two SFunction monoms. It uses the expansion \n" }
{MPLTEXT 1 0 87 "#  -- s_to_p and thereby the Murnaghan Nakayama coeff
icients. The second step is once \n" }{MPLTEXT 1 0 82 "#  -- more to u
se p_n[s_\\lambda] = s_\\lambda[p_n] and compute these plethysms via\n
" }{MPLTEXT 1 0 14 "#  -- plethSP\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 
1 0 22 "plethS_mon:=proc(x,y)\n" }{MPLTEXT 1 0 84 "  option `Copyright
 (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n" }
{MPLTEXT 1 0 19 "         remember;\n" }{MPLTEXT 1 0 15 "  local n,m,i
;\n" }{MPLTEXT 1 0 30 "  n,m:=`+`(op(x)),`+`(op(y));\n" }{MPLTEXT 1 0 
15 "  if n=0 then \n" }{MPLTEXT 1 0 16 "    return s[0]\n" }{MPLTEXT 
1 0 16 "  elif m=0 then\n" }{MPLTEXT 1 0 52 "    # -- according to SCH
UR (and plethSP see above)\n" }{MPLTEXT 1 0 34 "    # -- plethS(s[n],s
[0]) = s[0]\n" }{MPLTEXT 1 0 56 "    # -- plethS(s[lambda],s[0]) = 0 i
f length(lambda)>1\n" }{MPLTEXT 1 0 32 "    if nops([op(x)]) > 1 then \+
 \n" }{MPLTEXT 1 0 15 "      return 0\n" }{MPLTEXT 1 0 9 "    else\n" 
}{MPLTEXT 1 0 18 "      return s[0]\n" }{MPLTEXT 1 0 12 "    end if;\n
" }{MPLTEXT 1 0 16 "  elif n=1 then\n" }{MPLTEXT 1 0 13 "    return y
\n" }{MPLTEXT 1 0 17 "  elif m=1 then \n" }{MPLTEXT 1 0 13 "    return
 x\n" }{MPLTEXT 1 0 11 "  end if; \n" }{MPLTEXT 1 0 10 "  expand(\n" }
{MPLTEXT 1 0 82 "     add(1/zee(i)*MurNak(i,[op(x)])*outer(op(map((k)-
>plethSP(y,p[k]),[op(i)]))) \n" }{MPLTEXT 1 0 32 "         ,i in PartN
M(n,n))  );\n" }{MPLTEXT 1 0 10 "end proc:\n" }{MPLTEXT 1 0 73 "######
##################################################################\n" 
}{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 66 "# plethSAxNB computes the plet
hysm of a Schur function A with the\n" }{MPLTEXT 1 0 67 "#    n-fold m
ultiple of a Schur function B  A[n.B] using the inner\n" }{MPLTEXT 1 
0 65 "#    coproduct. This can be used to produce q-deformed symmetric
\n" }{MPLTEXT 1 0 71 "#    functions [see Francesco Brenti, A Class of
 q-Symmetric Functions\n" }{MPLTEXT 1 0 70 "#    Arising from Plethysm
, J. Comb.Theor. Series A 91, 2000:137-170]\n" }{MPLTEXT 1 0 2 "#\n" }
{MPLTEXT 1 0 73 "#####################################################
###################\n" }{MPLTEXT 1 0 32 "plethSAxNB:=proc(sfkta,sfktb,
N)\n" }{MPLTEXT 1 0 84 "  option `Copyright (c) B. Fauser & R. Ablamow
icz 2004-2009. All rights reserved.`;\n" }{MPLTEXT 1 0 11 "  local f;
\n" }{MPLTEXT 1 0 49 "  if N=1 then return plethS(sfkta,sfktb) end if;
\n" }{MPLTEXT 1 0 31 "  if N=0 then return 0 end if;\n" }{MPLTEXT 1 0 
46 "  f:=(x,y,n,sb)->dimGL(x,op(n))*plethS(y,sb):\n" }{MPLTEXT 1 0 54 
"  eval(subs(`&t`=f,  &t(cinner(sfkta),[N],sfktb)  ));\n" }{MPLTEXT 1 
0 10 "end proc:\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 43 "#  X[Y] is \+
linear in X and not linear in Y\n" }{MPLTEXT 1 0 29 "#  -- (X+Y)[Z] = \+
X[Z] + Y[Z]\n" }{MPLTEXT 1 0 74 "#  -- X[Y+Z] = X(1)[Y] . X(2)[Z]   wh
ere . = outer, couter(X)=X(1) x X(2)\n" }{MPLTEXT 1 0 67 "#  -- X[YZ] \+
= X[1] . X[2]  where . = outer, cinner(X) =X[1] x X[2]\n" }{MPLTEXT 1 
0 75 "#  --         this case does not appear in the function, since u
nevaluated\n" }{MPLTEXT 1 0 47 "#  --         outer products YZ do not
 appear.\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 18 "plethS:=proc(x,y)
\n" }{MPLTEXT 1 0 84 "  option `Copyright (c) B. Fauser & R. Ablamowic
z 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 0 19 "         reme
mber;\n" }{MPLTEXT 1 0 27 "  local cf,tm,p1,p2,a,b,f;\n" }{MPLTEXT 1 
0 19 "# ++ special cases\n" }{MPLTEXT 1 0 33 "# -- one argument numeri
cal zero\n" }{MPLTEXT 1 0 15 "  if x=0 then \n" }{MPLTEXT 1 0 14 "    \+
 return 0\n" }{MPLTEXT 1 0 17 "  elif y=0 then \n" }{MPLTEXT 1 0 14 " \+
    return 0\n" }{MPLTEXT 1 0 10 "  end if;\n" }{MPLTEXT 1 0 15 "# ++ \+
typecheck\n" }{MPLTEXT 1 0 60 "  if not(type(x,sfktpolynom) and type(y
,sfktpolynom)) then \n" }{MPLTEXT 1 0 27 "     error \"wrong type\\n\"
 \n" }{MPLTEXT 1 0 10 "  end if;\n" }{MPLTEXT 1 0 18 "  if x=s[0] then
 \n" }{MPLTEXT 1 0 47 "  #-- s_(0)[s_(lambda)] = s_(0) for all lambda
\n" }{MPLTEXT 1 0 16 "    return s[0]\n" }{MPLTEXT 1 0 60 "  # -- the \+
case y=s[0] needs a more sophisticated treatment\n" }{MPLTEXT 1 0 35 "
  # -- which is done in plethS_mon\n" }{MPLTEXT 1 0 45 "  # ++ s[1] is
 left and right unit of plethS\n" }{MPLTEXT 1 0 19 "  elif x=s[1] then
\n" }{MPLTEXT 1 0 13 "    return y\n" }{MPLTEXT 1 0 19 "  elif y=s[1] \+
then\n" }{MPLTEXT 1 0 13 "    return x\n" }{MPLTEXT 1 0 10 "  end if;
\n" }{MPLTEXT 1 0 27 "## -- end of special cases\n" }{MPLTEXT 1 0 50 "
## -- plethS is linear in x but _not_ linear in y\n" }{MPLTEXT 1 0 22 
"## ++ linearity in x \n" }{MPLTEXT 1 0 23 "  if type(x,`+`) then \n" 
}{MPLTEXT 1 0 30 "    return map(procname,x,y);\n" }{MPLTEXT 1 0 25 " \+
 elif type(x,`*`) then \n" }{MPLTEXT 1 0 43 "    tm,cf:=selectremove(t
ype,x,sfktmonom);\n" }{MPLTEXT 1 0 29 "    return cf*procname(tm,y)\n"
 }{MPLTEXT 1 0 7 "  else\n" }{MPLTEXT 1 0 50 "## -- the y argument dis
tributes using coproducts\n" }{MPLTEXT 1 0 61 "## -- outer roducts do \+
not happen, so we need to distinguish\n" }{MPLTEXT 1 0 59 "## -- two t
ypes of additive terms y = a+b and y = a+a = 2a\n" }{MPLTEXT 1 0 36 "#
# -- different terms have type `+`\n" }{MPLTEXT 1 0 3 "##\n" }{MPLTEXT
 1 0 70 "## -- the following code cures a subtle error in the plethysm
 routine\n" }{MPLTEXT 1 0 53 "## -- found via computing a problem of R
alf Holtkamp\n" }{MPLTEXT 1 0 68 "## -- one needs to make sure that th
e `+`(op(b_)) is only evaluated\n" }{MPLTEXT 1 0 43 "## -- after the e
xpansion has taken place!\n" }{MPLTEXT 1 0 69 "## -- change this part \+
of teh code only with care and severe checkig\n" }{MPLTEXT 1 0 44 "## \+
-- of at least 3 summand entries for x,y\n" }{MPLTEXT 1 0 25 "    if t
ype(y,`+`) then \n" }{MPLTEXT 1 0 18 "      b:=[op(y)];\n" }{MPLTEXT 
1 0 40 "      a:=&t(couter(x),[b[1]],b[2..-1]);\n" }{MPLTEXT 1 0 85 " \+
     f:=(x_,y_,a_,b_)->outer( plethS(x_,op(a_)),expand( plethS(y_,`+`(
op(b_))) ) );\n" }{MPLTEXT 1 0 35 "      return eval(subs(`&t`=f,a));
\n" }{MPLTEXT 1 0 43 "## -- numerical multiples of the same term\n" }
{MPLTEXT 1 0 26 "    elif type(y,`*`) then\n" }{MPLTEXT 1 0 45 "      \+
tm,cf:=selectremove(type,y,sfktmonom);\n" }{MPLTEXT 1 0 70 "##//// her
e we could use plethSAxNB to allow even symbolic prefactors\n" }
{MPLTEXT 1 0 35 "      if not type(cf,integer) then\n" }{MPLTEXT 1 0 
45 "         return expand(plethSAxNB(x,tm,cf));\n" }{MPLTEXT 1 0 53 "
##//// we do not put this error message any longer  \n" }{MPLTEXT 1 0 
88 "##       error \"Second input must be a polynomial over the intege
rs, but received \",y; \n" }{MPLTEXT 1 0 14 "      end if;\n" }
{MPLTEXT 1 0 19 "      if cf>0 then\n" }{MPLTEXT 1 0 44 "        retur
n expand(plethSAxNB(x,tm,cf));\n" }{MPLTEXT 1 0 26 "        #-- obsole
te code\n" }{MPLTEXT 1 0 39 "        #--a:=&t(couter(x),tm,[cf-1]);\n"
 }{MPLTEXT 1 0 76 "        #--f:=(x_,y_,a_,b_)->outer(plethS_mon(x_,a_
),plethS(y_,op(b_)*a_));\n" }{MPLTEXT 1 0 40 "        #--return eval(s
ubs(`&t`=f,a));\n" }{MPLTEXT 1 0 11 "      else\n" }{MPLTEXT 1 0 39 " \+
       return procname(antipS(x),-y);\n" }{MPLTEXT 1 0 14 "      end i
f;\n" }{MPLTEXT 1 0 9 "    else\n" }{MPLTEXT 1 0 77 "## ++ if neither \+
x nor y has type `+` or `*` then we have tow sfktmonomials \n" }
{MPLTEXT 1 0 22 "      plethS_mon(x,y)\n" }{MPLTEXT 1 0 12 "    end if
;\n" }{MPLTEXT 1 0 10 "  end if;\n" }{MPLTEXT 1 0 10 "end proc:\n" }
{MPLTEXT 1 0 76 "#####################################################
######################\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 55 "# cp
lethS_mon is the plethysm coproduct of a sfktmonom\n" }{MPLTEXT 1 0 
85 "#    -- the plethysm coproduct is obtained by dualizing the plethy
sm operation w.r.t\n" }{MPLTEXT 1 0 39 "#    -- the Schur-Hall scalar \+
product:\n" }{MPLTEXT 1 0 61 "#    -- cplethS(x) = \\sum_(y,z)  < x ,p
lethS(y,z) > (y &t z)\n" }{MPLTEXT 1 0 81 "#    -- where <,> is teh sc
alar product and plethS is the pelthysm of sfunctions\n" }{MPLTEXT 1 
0 85 "#    -- note that this is a noncocommutative operation and the o
rder of y,z matters.\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 21 "cpleth
S_mon:=proc(x)\n" }{MPLTEXT 1 0 26 "  local n,divx,prta,prtb;\n" }
{MPLTEXT 1 0 17 "  n:=`+`(op(x));\n" }{MPLTEXT 1 0 26 "  divx:=list_di
visors(n);\n" }{MPLTEXT 1 0 15 "  add(add(add(\n" }{MPLTEXT 1 0 84 "  \+
   eval(subs(s[0]=1,Scalar(x,plethS(s[op(a)],s[op(b)]))))*&t(s[op(a)],
s[op(b)]), \n" }{MPLTEXT 1 0 58 "    b in PartNM(n/i,n/i)), a in PartN
M(i,i)), i in divx);\n" }{MPLTEXT 1 0 10 "end proc:\n" }{MPLTEXT 1 0 
2 "#\n" }{MPLTEXT 1 0 87 "# cplethS is the linear version of cplethS_m
on establishing the plethysm coproduct of \n" }{MPLTEXT 1 0 22 "#    -
- SFunctions.  \n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 2 "#\n" }
{MPLTEXT 1 0 17 "cplethS:=proc(x)\n" }{MPLTEXT 1 0 84 "  option `Copyr
ight (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n
" }{MPLTEXT 1 0 12 "  remember;\n" }{MPLTEXT 1 0 32 "  local cf,tm,n1,
plst1,plst2,i;\n" }{MPLTEXT 1 0 31 "  if x=0 then return 0 end if;\n" 
}{MPLTEXT 1 0 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 0 28 "    retu
rn map(procname,x);\n" }{MPLTEXT 1 0 25 "  elif type(x,`*`) then \n" }
{MPLTEXT 1 0 43 "    tm,cf:=selectremove(type,x,sfktmonom);\n" }
{MPLTEXT 1 0 27 "    return cf*procname(tm)\n" }{MPLTEXT 1 0 7 "  else
\n" }{MPLTEXT 1 0 48 "    if x=s[0] then return &t(s[0],s[0]) end if;
\n" }{MPLTEXT 1 0 22 "    cplethS_mon(x);  \n" }{MPLTEXT 1 0 10 "  end
 if;\n" }{MPLTEXT 1 0 10 "end proc:\n" }{MPLTEXT 1 0 76 "#############
##############################################################\n" }
{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 10 "#########
\n" }{MPLTEXT 1 0 34 "######### Orthogonal Hopf algebra\n" }{MPLTEXT 
1 0 10 "#########\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 75 "# outerON
_monom outer product on s-function monoms of the orthogonal group\n" }
{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 25 "outerON_m
onom:=proc(x,y)\n" }{MPLTEXT 1 0 84 "  option `Copyright (c) B. Fauser
 & R. Ablamowicz 2004-2009. All rights reserved.`;\n" }{MPLTEXT 1 0 
15 "  local N,prt;\n" }{MPLTEXT 1 0 33 "  N:=min(`+`(op(x)),`+`(op(y))
);\n" }{MPLTEXT 1 0 66 "  prt:=[s[0],op(map(x->s[op(x)],[seq(op(PartNM
(i,i)),i=1..N)]))];\n" }{MPLTEXT 1 0 55 "  add(outer(skew(x,s[op(i)]),
skew(y,s[op(i)])),i=prt);\n" }{MPLTEXT 1 0 10 "end proc:\n" }{MPLTEXT 
1 0 2 "#\n" }{MPLTEXT 1 0 69 "# outerON outer product of s-function po
lynoms fro orthogonal groups\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 2 
"#\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 17 "outerON:=proc(x)\n" }
{MPLTEXT 1 0 84 "  option `Copyright (c) B. Fauser & R. Ablamowicz 200
4-2009. All rights reserved.`,\n" }{MPLTEXT 1 0 12 "  remember;\n" }
{MPLTEXT 1 0 25 "  local cf,tm,p1,p2,y,f;\n" }{MPLTEXT 1 0 35 "  if na
rgs=1 then return x end if;\n" }{MPLTEXT 1 0 14 "  y:=args[2];\n" }
{MPLTEXT 1 0 38 "  if x=0 or y=0 then return 0 end if;\n" }{MPLTEXT 1 
0 77 "  if nargs>2 then return procname(expand(procname(x,y)),args[3..
-1]) end if;\n" }{MPLTEXT 1 0 94 "  if not(type(x,sfktpolynom) and typ
e(args[2],sfktpolynom)) then error \"wrong type\\n\" end if;\n" }
{MPLTEXT 1 0 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 0 30 "    retur
n map(procname,x,y);\n" }{MPLTEXT 1 0 25 "  elif type(x,`*`) then \n" 
}{MPLTEXT 1 0 43 "    tm,cf:=selectremove(type,x,sfktmonom);\n" }
{MPLTEXT 1 0 29 "    return cf*procname(tm,y)\n" }{MPLTEXT 1 0 7 "  el
se\n" }{MPLTEXT 1 0 25 "    if type(y,`+`) then \n" }{MPLTEXT 1 0 33 "
      return map2(procname,x,y);\n" }{MPLTEXT 1 0 26 "    elif type(y,
`*`) then\n" }{MPLTEXT 1 0 45 "      tm,cf:=selectremove(type,y,sfktmo
nom);\n" }{MPLTEXT 1 0 31 "      return cf*procname(x,tm)\n" }{MPLTEXT
 1 0 9 "    else\n" }{MPLTEXT 1 0 26 "      outerON_monom(x,y);\n" }
{MPLTEXT 1 0 12 "    end if;\n" }{MPLTEXT 1 0 10 "  end if;\n" }
{MPLTEXT 1 0 10 "end proc:\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 81 "
# couterON_monom outer coproduct of s-function monoms for the orthogon
al groups \n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 
0 24 "couterON_monom:=proc(x)\n" }{MPLTEXT 1 0 84 "  option `Copyright
 (c) B. Fauser & R. Ablamowicz 2004-2009. All rights reserved.`;\n" }
{MPLTEXT 1 0 18 "  local prt, del;\n" }{MPLTEXT 1 0 51 "  prt:=[[0],se
q(op(PartNM(i,i)),i=1..`+`(op(x)))];\n" }{MPLTEXT 1 0 72 "  del:=map(x
->2*x,[[0],seq(op(PartNM(i,i)),i=1..floor(`+`(op(x)))/2)]);\n" }
{MPLTEXT 1 0 72 "  add(&t(skew(x,outer(add(s[op(k)],k=del),s[op(i)])),
s[op(i)]),i=prt); \n" }{MPLTEXT 1 0 10 "end proc:\n" }{MPLTEXT 1 0 2 "
#\n" }{MPLTEXT 1 0 76 "# couterON outer coproduct of sfunction polynom
s for the orthogonal groups \n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 
18 "couterON:=proc(x)\n" }{MPLTEXT 1 0 84 "  option `Copyright (c) B. \+
Fauser & R. Ablamowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 
1 0 19 "         remember;\n" }{MPLTEXT 1 0 15 "  local cf,tm;\n" }
{MPLTEXT 1 0 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 0 28 "    retur
n map(procname,x);\n" }{MPLTEXT 1 0 25 "  elif type(x,`*`) then \n" }
{MPLTEXT 1 0 43 "    tm,cf:=selectremove(type,x,sfktmonom);\n" }
{MPLTEXT 1 0 27 "    return cf*procname(tm)\n" }{MPLTEXT 1 0 7 "  else
\n" }{MPLTEXT 1 0 25 "    couterON_monom(x);  \n" }{MPLTEXT 1 0 10 "  \+
end if;\n" }{MPLTEXT 1 0 10 "end proc:\n" }{MPLTEXT 1 0 89 "##########
######################################################################
########\n" }{MPLTEXT 1 0 3 "##\n" }{MPLTEXT 1 0 32 "## S-function Ser
ies facilities\n" }{MPLTEXT 1 0 3 "##\n" }{MPLTEXT 1 0 89 "###########
######################################################################
#######\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 79 "#  getSfktSeries re
turns a sum of S-functions of a known Schur function series\n" }
{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 43 "#  -- currently known series ar
e M,L,D,B,F\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 26 "getSfktSeries:=
proc(name)\n" }{MPLTEXT 1 0 85 "   option `Copyright (c) B. Fauser & R
. Ablamowicz 2004-2009. All rights reserved.`,\n" }{MPLTEXT 1 0 20 "  \+
        remember;\n" }{MPLTEXT 1 0 34 "   local N,prt,serFlag,t,f,m,i,
j;\n" }{MPLTEXT 1 0 19 "   if nargs=1 then\n" }{MPLTEXT 1 0 31 "      \+
if args[1]='names' then \n" }{MPLTEXT 1 0 52 "        return \"Known S
eries are: A,B,C,D,E,F,L,M\";\n" }{MPLTEXT 1 0 11 "      else\n" }
{MPLTEXT 1 0 91 "        error \"Usage: either give one argument 'name
s' or [2|3] arguments, see help page\";\n" }{MPLTEXT 1 0 14 "      end
 if;\n" }{MPLTEXT 1 0 12 "   end if; \n" }{MPLTEXT 1 0 39 "   if nargs
>=2 then N:=args[2] end if;\n" }{MPLTEXT 1 0 73 "   if nargs=3 then se
rFlag:=true; t:=args[3] else serFlag:=false end if;\n" }{MPLTEXT 1 0 
34 "   ## ///////////////////////////\n" }{MPLTEXT 1 0 30 "   ## M-ser
ies = \\sum \{m\} t^m\n" }{MPLTEXT 1 0 6 "   ##\n" }{MPLTEXT 1 0 20 " \+
  if name='M' then\n" }{MPLTEXT 1 0 28 "      if serFlag=false then\n"
 }{MPLTEXT 1 0 36 "         return [seq(s[m],m=0..N)];\n" }{MPLTEXT 1 
0 11 "      else\n" }{MPLTEXT 1 0 31 "         add(s[m]*t^m,m=0..N);\n
" }{MPLTEXT 1 0 14 "      end if;\n" }{MPLTEXT 1 0 34 "   ## /////////
//////////////////\n" }{MPLTEXT 1 0 39 "   ## L-series = \\sum (-1)^m \+
\{1^m\} t^m\n" }{MPLTEXT 1 0 6 "   ##\n" }{MPLTEXT 1 0 40 "   ## (spec
ial care for zero partition)\n" }{MPLTEXT 1 0 6 "   ##\n" }{MPLTEXT 1 
0 22 "   elif name='L' then\n" }{MPLTEXT 1 0 28 "      if serFlag=fals
e then\n" }{MPLTEXT 1 0 43 "         return [seq((-1)^m*s[m],m=0..N)];
\n" }{MPLTEXT 1 0 11 "      else\n" }{MPLTEXT 1 0 46 "         f:=m->i
f m=0 then 0 else 1$m end if:\n" }{MPLTEXT 1 0 41 "         add((-1)^m
*s[f(m)]*t^m,m=0..N);\n" }{MPLTEXT 1 0 14 "      end if;\n" }{MPLTEXT 
1 0 34 "   ## ///////////////////////////\n" }{MPLTEXT 1 0 51 "   ## C
-series = \\sum \{\} (inverse of the D series)\n" }{MPLTEXT 1 0 6 "   \+
##\n" }{MPLTEXT 1 0 39 "   ## (we scale the parameter t also!)\n" }
{MPLTEXT 1 0 22 "   elif name='C' then\n" }{MPLTEXT 1 0 21 "      prt:
=[s[0],op(\n" }{MPLTEXT 1 0 79 "              map(x->if \{1\}=\{op(zip
((i,j)->i-j,op(part2Frob([op(x)]))))\} then \n" }{MPLTEXT 1 0 79 "    \+
              (-1)^(`+`(op(x))/2)*x else   NULL end if,procname(F,N)) \+
 )];\n" }{MPLTEXT 1 0 28 "      if serFlag=false then\n" }{MPLTEXT 1 
0 21 "         return prt;\n" }{MPLTEXT 1 0 11 "      else\n" }
{MPLTEXT 1 0 37 "        ## --- take care of the sign\n" }{MPLTEXT 1 
0 21 "        f:=proc(x,t)\n" }{MPLTEXT 1 0 26 "           local cf,te
rm;\n" }{MPLTEXT 1 0 18 "           cf:=1:\n" }{MPLTEXT 1 0 31 "      \+
     if type(x,`*`) then\n" }{MPLTEXT 1 0 54 "             term,cf:=se
lectremove(type,x,sfktmonom);\n" }{MPLTEXT 1 0 43 "             return
 (cf*t)^(`+`(op(term)))\n" }{MPLTEXT 1 0 16 "           else\n" }
{MPLTEXT 1 0 40 "             return (cf*t)^(`+`(op(x)))\n" }{MPLTEXT 
1 0 19 "           end if;\n" }{MPLTEXT 1 0 19 "         end proc:\n" 
}{MPLTEXT 1 0 24 "         ## ---        \n" }{MPLTEXT 1 0 30 "       \+
  add(i*f(i,t),i=prt);\n" }{MPLTEXT 1 0 14 "      end if;\n" }{MPLTEXT
 1 0 34 "   ## ///////////////////////////\n" }{MPLTEXT 1 0 54 "   ## \+
D-series = \\sum \{delta\}   delta=even parts only\n" }{MPLTEXT 1 0 6 
"   ##\n" }{MPLTEXT 1 0 39 "   ## (we scale the parameter t also!)\n" 
}{MPLTEXT 1 0 22 "   elif name='D' then\n" }{MPLTEXT 1 0 67 "      prt
:=map(x->2*x,[[0],seq(op(PartNM(i,i)),i=1..floor(N/2))]);\n" }{MPLTEXT
 1 0 28 "      if serFlag=false then\n" }{MPLTEXT 1 0 38 "         ret
urn map(x->s[op(x)],prt);\n" }{MPLTEXT 1 0 11 "      else\n" }{MPLTEXT
 1 0 45 "         add(s[op(i)]*t^(`+`(op(i))),i=prt);\n" }{MPLTEXT 1 
0 14 "      end if;\n" }{MPLTEXT 1 0 37 "   ## ///////////////////////
////   \n" }{MPLTEXT 1 0 62 "   ## B-series = \\sum \{beta\}   conjpar
t(beta)=even parts only\n" }{MPLTEXT 1 0 6 "   ##\n" }{MPLTEXT 1 0 39 
"   ## (we scale the parameter t also!)\n" }{MPLTEXT 1 0 22 "   elif n
ame='B' then\n" }{MPLTEXT 1 0 67 "      prt:=map(x->2*x,[[0],seq(op(Pa
rtNM(i,i)),i=1..floor(N/2))]);\n" }{MPLTEXT 1 0 36 "      prt:=map(x->
conjpart(x),prt);\n" }{MPLTEXT 1 0 28 "      if serFlag=false then\n" 
}{MPLTEXT 1 0 38 "         return map(x->s[op(x)],prt);\n" }{MPLTEXT 
1 0 11 "      else\n" }{MPLTEXT 1 0 45 "         add(s[op(i)]*t^(`+`(o
p(i))),i=prt);\n" }{MPLTEXT 1 0 14 "      end if;\n" }{MPLTEXT 1 0 34 
"   ## ///////////////////////////\n" }{MPLTEXT 1 0 17 "   ## A-series
  \n" }{MPLTEXT 1 0 6 "   ##\n" }{MPLTEXT 1 0 23 "   elif name='A' the
n \n" }{MPLTEXT 1 0 21 "      prt:=[s[0],op(\n" }{MPLTEXT 1 0 79 "    \+
          map(x->if \{1\}=\{op(zip((i,j)->j-i,op(part2Frob([op(x)]))))
\} then \n" }{MPLTEXT 1 0 79 "                  (-1)^(`+`(op(x))/2)*x \+
else   NULL end if,procname(F,N))  )];\n" }{MPLTEXT 1 0 28 "      if s
erFlag=false then\n" }{MPLTEXT 1 0 21 "         return prt;\n" }
{MPLTEXT 1 0 11 "      else\n" }{MPLTEXT 1 0 37 "        ## --- take c
are of the sign\n" }{MPLTEXT 1 0 21 "        f:=proc(x,t)\n" }{MPLTEXT
 1 0 26 "           local cf,term;\n" }{MPLTEXT 1 0 18 "           cf:
=1:\n" }{MPLTEXT 1 0 31 "           if type(x,`*`) then\n" }{MPLTEXT 
1 0 54 "             term,cf:=selectremove(type,x,sfktmonom);\n" }
{MPLTEXT 1 0 43 "             return (cf*t)^(`+`(op(term)))\n" }
{MPLTEXT 1 0 16 "           else\n" }{MPLTEXT 1 0 40 "             ret
urn (cf*t)^(`+`(op(x)))\n" }{MPLTEXT 1 0 19 "           end if;\n" }
{MPLTEXT 1 0 19 "         end proc:\n" }{MPLTEXT 1 0 24 "         ## -
--        \n" }{MPLTEXT 1 0 30 "         add(i*f(i,t),i=prt);\n" }
{MPLTEXT 1 0 14 "      end if;\n" }{MPLTEXT 1 0 34 "   ## ////////////
///////////////\n" }{MPLTEXT 1 0 58 "   ## E-series  = \\sum_self conj
 part (-)^(|x|+r) *s[prt]\n" }{MPLTEXT 1 0 55 "   ##              r = \+
Frobenius rank of the partition\n" }{MPLTEXT 1 0 6 "   ##\n" }{MPLTEXT
 1 0 23 "   elif name='E' then \n" }{MPLTEXT 1 0 21 "      prt:=[s[0],
op(\n" }{MPLTEXT 1 0 79 "              map(x->if \{0\}=\{op(zip((i,j)-
>j-i,op(part2Frob([op(x)]))))\} then \n" }{MPLTEXT 1 0 60 "           \+
          x else NULL end if,procname(F,N))  )];\n" }{MPLTEXT 1 0 28 "
      if serFlag=false then\n" }{MPLTEXT 1 0 82 "         return map(x
->(-1)^((`+`(op(x))+nops(part2Frob([op(x)])[1]))/2)*x ,prt);\n" }
{MPLTEXT 1 0 11 "      else\n" }{MPLTEXT 1 0 65 "         add((-1)^((`
+`(op(i))+nops(part2Frob([op(i)])[1]))/2)*i\n" }{MPLTEXT 1 0 37 "     \+
        *t^(`+`(op(i))),i=prt);\n" }{MPLTEXT 1 0 14 "      end if;\n" 
}{MPLTEXT 1 0 34 "   ## ///////////////////////////\n" }{MPLTEXT 1 0 
46 "   ## F-series = \\sum \{zeta\}  all partitions \n" }{MPLTEXT 1 0 
6 "   ##\n" }{MPLTEXT 1 0 22 "   elif name='F' then\n" }{MPLTEXT 1 0 
46 "      prt:=[[0],seq(op(PartNM(i,i)),i=1..N)];\n" }{MPLTEXT 1 0 28 
"      if serFlag=false then\n" }{MPLTEXT 1 0 38 "         return map(
x->s[op(x)],prt);\n" }{MPLTEXT 1 0 11 "      else\n" }{MPLTEXT 1 0 45 
"         add(s[op(i)]*t^(`+`(op(i))),i=prt);\n" }{MPLTEXT 1 0 14 "   \+
   end if;\n" }{MPLTEXT 1 0 9 "    else\n" }{MPLTEXT 1 0 96 "      err
or \"unrecognized series name: use getSfktSeries(names) to see which n
ames are known!\";\n" }{MPLTEXT 1 0 11 "   end if;\n" }{MPLTEXT 1 0 
10 "end proc:\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 58 "# branch_mono
m internal function for branchings on monoms\n" }{MPLTEXT 1 0 2 "#\n" 
}{MPLTEXT 1 0 60 "# +++ !!!! this function should be already multiline
ar !!!!\n" }{MPLTEXT 1 0 54 "# +++ remove branch and rename this one a
fter a test!\n" }{MPLTEXT 1 0 30 "branch_monom:=proc(x,serName)\n" }
{MPLTEXT 1 0 85 "   option `Copyright (c) B. Fauser & R. Ablamowicz 20
04-2009. All rights reserved.`;\n" }{MPLTEXT 1 0 13 "  local ser;\n" }
{MPLTEXT 1 0 40 "  ser:=getSeries(serName,`+`(op(x)),1);\n" }{MPLTEXT 
1 0 15 "  skew(x,ser);\n" }{MPLTEXT 1 0 10 "end proc:\n" }{MPLTEXT 1 
0 2 "#\n" }{MPLTEXT 1 0 75 "# branch computes the reduction of inducti
on of characters with respect to\n" }{MPLTEXT 1 0 35 "#        certain
 S-function series\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 24 "branch:=
proc(x,serName)\n" }{MPLTEXT 1 0 84 "  option `Copyright (c) B. Fauser
 & R. Ablamowicz 2004-2006. All rights reserved.`,\n" }{MPLTEXT 1 0 
12 "  remember;\n" }{MPLTEXT 1 0 36 "  local ser,cf,tm,n1,plst1,plst2,
i;\n" }{MPLTEXT 1 0 23 "  if type(x,`+`) then \n" }{MPLTEXT 1 0 36 "  \+
  return map(procname,x,serName);\n" }{MPLTEXT 1 0 25 "  elif type(x,`
*`) then \n" }{MPLTEXT 1 0 43 "    tm,cf:=selectremove(type,x,sfktmono
m);\n" }{MPLTEXT 1 0 35 "    return cf*procname(tm,serName)\n" }
{MPLTEXT 1 0 7 "  else\n" }{MPLTEXT 1 0 56 "    ser:=SchurFkt:-getSfkt
Series(serName,`+`(op(x)),1);\n" }{MPLTEXT 1 0 19 "    skew(x,ser);  \+
\n" }{MPLTEXT 1 0 10 "  end if;\n" }{MPLTEXT 1 0 10 "end proc:\n" }
{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 202 12 "end module:\n" }{MPLTEXT 1 
202 2 "##" }}{PARA 6 "" 1 "" {TEXT 211 50 "SchurFkt Version 1.0.4 (2 x
i 2009) at your service" }{TEXT 211 59 "\n(c) 2003-2009 BF&RA, no warr
anty, no fitness for anything!" }{TEXT 211 84 "\nIncrease verbosity by
 infolevel[`function`]=val -- use online help > ?Bigebra[help]" }}}
{EXCHG {PARA 206 "> " 0 "" {MPLTEXT 1 201 57 "libname:=\"/usr/local/ma
ple/maple13/Cliffordlib\",libname;\n" }{MPLTEXT 1 201 20 "savelib('Sch
urFkt');" }}{PARA 11 "" 1 "" {XPPMATH 20 "6'QE/usr/local/maple/maple13
/Cliffordlib6\"F#F#Q@/usr/local/maple/maple13/FGblibF$Q=/usr/local/map
le/maple13/libF$" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "restart
:restart:" }}{PARA 6 "" 1 "" {TEXT 211 41 "SchurFkt Version 1.0.4 says
 'Good bye...'" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "restart:w
ith(SchurFkt);nops(%);" }}{PARA 6 "" 1 "" {TEXT 211 50 "SchurFkt Versi
on 1.0.4 (2 xi 2009) at your service" }{TEXT 211 59 "\n(c) 2003-2009 B
F&RA, no warranty, no fitness for anything!" }{TEXT 211 84 "\nIncrease
 verbosity by infolevel[`function`]=val -- use online help > ?Bigebra[
help]" }}{PARA 11 "" 1 "" {XPPMATH 20 "7grI)AlexCompG6\"I)CharHookGF$I
'CompNMGF$I)DescentsGF$I%FLATGF$I*Frob2partGF$I-GesselThetaPGF$I-Gesse
lThetaSGF$I)KostkaPCGF$I,KostkaTableGF$I'LP_monGF$I)LaplaceMGF$I*Lapla
ceM2GF$I-LaplaceM_monGF$I-LaplaceTableGF$I%MLINGF$I'MurNakGF$I(MurNak2
GF$I'PartNMGF$I'ScalarGF$I)ScalarHMGF$I)ScalarMHGF$I(ScalarPGF$I'antip
EGF$I'antipHGF$I'antipMGF$I(antipMCGF$I'antipPGF$I'antipSGF$I'branchGF
$I&cdiagGF$I'cinnerGF$I(cinnerPGF$I)cmp2partGF$I,cmp2prtMultGF$I-colle
ct_sfktGF$I(concatMGF$I)conjpartGF$I-counitInnerPGF$I-counitInnerSGF$I
'couterGF$I(couterEGF$I(couterHGF$I(couterMGF$I)couterONGF$I(couterPGF
$I(cplethPGF$I(cplethSGF$I&dimGLGF$I'dimGLEGF$I'dimGLHGF$I'dimGLMGF$I'
dimGLPGF$I&dimSNGF$I'dimSNEGF$I'dimSNHGF$I'dimSNMGF$I'dimSNPGF$I'e_to_
hGF$I'e_to_mGF$I'e_to_sGF$I6evalJacobiTrudiMatrixGF$I1fallingFactorial
GF$I.getSfktSeriesGF$I+grAlexCompGF$I'h_to_mGF$I'h_to_pGF$I'h_to_sGF$I
&innerG%*protectedGI'innerHGF$I'innerMGF$I'innerPGF$I*isLatticeGF$I8le
hmerCodeToPermutationGF$I5lehmerCodeToSchurFktGF$I'm_to_eGF$I'm_to_hGF
$I'm_to_pGF$I*m_to_pMatGF$I'm_to_sGF$I0maxlengthSymFktGF$I*mset2partGF
$I&outerGF$I'outerEGF$I'outerHGF$I(outerLSGF$I'outerMGF$I(outerONGF$I'
outerPGF$I'outerSGF$I'p_to_mGF$I'p_to_sGF$I*part2FrobGF$I*part2msetGF$
I2partitionsInShapeGF$I8permutationToLehmerCodeGF$I'plethPGF$I'plethSG
F$I+plethSAxNBGF$I)plethSnmGF$I0risingFactorialGF$I's_to_eGF$I's_to_hG
F$I)s_to_hJTGF$I*s_to_hMatGF$I*s_to_hmatGF$I's_to_mGF$I's_to_pGF$I's_t
o_xGF$I2schurToLehmerCodeGF$I3schurToLehmerCode1GF$I+sfkt_termsGF$I%sk
ewGF$I'skewLRGF$I'skewLSGF$I1skewToLehmerCodeGF$I)sq_coeffGF$I+transit
ionGF$I)truncLENGF$I*truncPARTGF$I(truncWTGF$I'x_to_sGF$I$zeeGF$" }}
{PARA 11 "" 1 "" {XPPMATH 20 "\"$B\"" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 16 "&t(s[2],s[1,1]);" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#-
%#&tG6$&%\"sG6#\"\"#&%\"sG6$\"\"\"\"\"\"" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 19 "basS:=PartNM(4,4);\n" }{MPLTEXT 1 0 34 "matrix(nops(b
asS)+1,nops(basS)+1,\n" }{MPLTEXT 1 0 105 "  (i,j)->if i=1 and j=1 the
n \"MurNak\" elif i=1 then s[op(basS[j-1])] elif j=1 then s[op(basS[i-
1])] else\n" }{MPLTEXT 1 0 46 "         MurNak(basS[j-1],basS[i-1]) en
d if); " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 11 "" 1 "" 
{XPPMATH 20 "6#>%%basSG7'7#\"\"%7$\"\"$\"\"\"7$\"\"#\"\"#7%\"\"#\"\"\"
\"\"\"7&\"\"\"\"\"\"\"\"\"\"\"\"" }}{PARA 11 "" 1 "" {XPPMATH 20 "-I%m
rowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I(mfencedGF$6&-F#6
#-I'mtableGF$6:-I$mtrGF$6+-I$mtdGF$6(-I#msGF$6#Q'MurNakF'/%)rowalignGQ
!F'/%,columnalignGF?/%+groupalignGF?/%(rowspanGQ\"1F'/%+columnspanGFF-
F76(-I%msubGF$6%-I#miGF$6%Q\"sF'/%'italicGQ%trueF'/%,mathvariantGQ'ita
licF'-F#6#-I#mnGF$6$Q\"4F'/FVQ'normalF'/%/subscriptshiftGQ\"0F'F=F@FBF
DFG-F76(-FL6%FN-F#6%-Fen6$Q\"3F'Fhn-I#moGF$6-Q\",F'Fhn/%&fenceGQ&false
F'/%*separatorGFT/%)stretchyGF\\p/%*symmetricGF\\p/%(largeopGF\\p/%.mo
vablelimitsGF\\p/%'accentGF\\p/%'lspaceGQ&0.0emF'/%'rspaceGQ,0.3333333
emF'-Fen6$FFFhnFjnF=F@FBFDFG-F76(-FL6%FN-F#6%-Fen6$Q\"2F'FhnFfoFgqFjnF
=F@FBFDFG-F76(-FL6%FN-F#6'FgqFfoF_qFfoF_qFjnF=F@FBFDFG-F76(-FL6%FN-F#6
)F_qFfoF_qFfoF_qFfoF_qFjnF=F@FBFDFGF=F@FB-F46+FI-F76(F_qF=F@FBFDFGFhrF
hrFhrFhrF=F@FB-F46+F]o-F76(-F#6$-Fgo6-Q*&uminus0;F'FhnFjo/F^pF\\pF_pFa
pFcpFepFgp/FjpQ,0.2222222emF'/F]qFesF_qF=F@FBFDFG-F76(-Fen6$F\\oFhnF=F
@FBFDFGF\\sFhr-F76(FcoF=F@FBFDFGF=F@FB-F46+FaqFgsF\\s-F76(FgqF=F@FBFDF
GFgsF_tF=F@FB-F46+FjqFhrFgsF\\sF\\sF[tF=F@FB-F46+F`rF\\sFhrFhrF\\sFhrF
=F@FB/%&alignGQ%axisF'/F>Q)baselineF'/FAQ'centerF'/FCQ'|frleft|hrF'/%/
alignmentscopeGFT/%,columnwidthGQ%autoF'/%&widthGFbu/%+rowspacingGQ&1.
0exF'/%.columnspacingGQ&0.8emF'/%)rowlinesGQ%noneF'/%,columnlinesGF]v/
%&frameGF]v/%-framespacingGQ,0.4em~0.5exF'/%*equalrowsGF\\p/%-equalcol
umnsGF\\p/%-displaystyleGF\\p/%%sideGQ&rightF'/%0minlabelspacingGFjuFh
n/%%openGQ\"[F'/%&closeGQ\"]F'" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 
1 0 19 "basS:=PartNM(4,4);\n" }{MPLTEXT 1 0 34 "matrix(nops(basS)+1,no
ps(basS)+1,\n" }{MPLTEXT 1 0 100 "  (i,j)->if i=1 and j=1 then \"*\" e
lif i=1 then s[op(basS[j-1])] elif j=1 then s[op(basS[i-1])] else\n" }
{MPLTEXT 1 0 58 "         inner(s[op(basS[j-1])],s[op(basS[i-1])]) end
 if);" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#>%%basSG7'7#\"\"%7$\"\"$\"\"
\"7$\"\"#\"\"#7%\"\"#\"\"\"\"\"\"7&\"\"\"\"\"\"\"\"\"\"\"\"" }}{PARA 
11 "" 1 "" {XPPMATH 20 "-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_sy
slibGF'6#-I(mfencedGF$6&-F#6#-I'mtableGF$6:-I$mtrGF$6+-I$mtdGF$6(-I#ms
GF$6#Q\"*F'/%)rowalignGQ!F'/%,columnalignGF?/%+groupalignGF?/%(rowspan
GQ\"1F'/%+columnspanGFF-F76(-I%msubGF$6%-I#miGF$6%Q\"sF'/%'italicGQ%tr
ueF'/%,mathvariantGQ'italicF'-F#6#-I#mnGF$6$Q\"4F'/FVQ'normalF'/%/subs
criptshiftGQ\"0F'F=F@FBFDFG-F76(-FL6%FN-F#6%-Fen6$Q\"3F'Fhn-I#moGF$6-Q
\",F'Fhn/%&fenceGQ&falseF'/%*separatorGFT/%)stretchyGF\\p/%*symmetricG
F\\p/%(largeopGF\\p/%.movablelimitsGF\\p/%'accentGF\\p/%'lspaceGQ&0.0e
mF'/%'rspaceGQ,0.3333333emF'-Fen6$FFFhnFjnF=F@FBFDFG-F76(-FL6%FN-F#6%-
Fen6$Q\"2F'FhnFfoFgqFjnF=F@FBFDFG-F76(-FL6%FN-F#6'FgqFfoF_qFfoF_qFjnF=
F@FBFDFG-F76(-FL6%FN-F#6)F_qFfoF_qFfoF_qFfoF_qFjnF=F@FBFDFGF=F@FB-F46+
FIFIF]oFaqFjqF`rF=F@FB-F46+F]oF]o-F76(-F#6)FK-Fgo6-Q\"+F'FhnFjo/F^pF
\\pF_pFapFcpFepFgp/FjpQ,0.2222222emF'/F]qFcsF_oF^sFcqF^sF\\rF=F@FBFDFG
-F76(-F#6%F_oF^sF\\rF=F@FBFDFG-F76(-F#6)F_oF^sFcqF^sF\\rF^sFbrF=F@FBFD
FGFjqF=F@FB-F46+FaqFaqFes-F76(-F#6'FKF^sFcqF^sFbrF=F@FBFDFGFesFaqF=F@F
B-F46+FjqFjqFisFesFjrF]oF=F@FB-F46+F`rF`rFjqFaqF]oFIF=F@FB/%&alignGQ%a
xisF'/F>Q)baselineF'/FAQ'centerF'/FCQ'|frleft|hrF'/%/alignmentscopeGFT
/%,columnwidthGQ%autoF'/%&widthGFdu/%+rowspacingGQ&1.0exF'/%.columnspa
cingGQ&0.8emF'/%)rowlinesGQ%noneF'/%,columnlinesGF_v/%&frameGF_v/%-fra
mespacingGQ,0.4em~0.5exF'/%*equalrowsGF\\p/%-equalcolumnsGF\\p/%-displ
aystyleGF\\p/%%sideGQ&rightF'/%0minlabelspacingGF\\vFhn/%%openGQ\"[F'/
%&closeGQ\"]F'" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "KostkaTab
le(4);" }}{PARA 11 "" 1 "" {XPPMATH 20 "-I%mrowG6#/I+modulenameG6\"I,T
ypesettingGI(_syslibGF'6#-F#6%-I#miGF$6%Q(Kostka4F'/%'italicGQ%trueF'/
%,mathvariantGQ'italicF'-I#moGF$6-Q\"=F'/F5Q'normalF'/%&fenceGQ&falseF
'/%*separatorGF?/%)stretchyGF?/%*symmetricGF?/%(largeopGF?/%.movableli
mitsGF?/%'accentGF?/%'lspaceGQ,0.2777778emF'/%'rspaceGFN-I(mfencedGF$6
&-F#6#-I'mtableGF$69-I$mtrGF$6*-I$mtdGF$6(-I#mnGF$6$Q\"1F'F;/%)rowalig
nGQ!F'/%,columnalignGF_o/%+groupalignGF_o/%(rowspanGF\\o/%+columnspanG
F\\oFfnFfnFfnFfnF]oF`oFbo-FZ6*-Fgn6(-Fjn6$Q\"0F'F;F]oF`oFboFdoFfoFfnFf
n-Fgn6(-Fjn6$Q\"2F'F;F]oF`oFboFdoFfo-Fgn6(-Fjn6$Q\"3F'F;F]oF`oFboFdoFf
oF]oF`oFbo-FZ6*FjoFjoFfnFfnF_pF]oF`oFbo-FZ6*FjoFjoFjoFfnFdpF]oF`oFbo-F
Z6*FjoFjoFjoFjoFfnF]oF`oFbo/%&alignGQ%axisF'/F^oQ)baselineF'/FaoQ&righ
tF'/FcoQ'|frleft|hrF'/%/alignmentscopeGF3/%,columnwidthGQ%autoF'/%&wid
thGF\\r/%+rowspacingGQ&1.0exF'/%.columnspacingGQ&0.8emF'/%)rowlinesGQ%
noneF'/%,columnlinesGFgr/%&frameGFgr/%-framespacingGQ,0.4em~0.5exF'/%*
equalrowsGF?/%-equalcolumnsGF?/%-displaystyleGF?/%%sideGFeq/%0minlabel
spacingGFdrF;/%%openGQ\"[F'/%&closeGQ\"]F'" }}}{EXCHG {PARA 0 "> " 0 "
" {MPLTEXT 1 0 18 "LaplaceTable(4,6);" }}{PARA 11 "" 1 "" {XPPMATH 20 
"-I%mrowG6#/I+modulenameG6\"I,TypesettingGI(_syslibGF'6#-I(mfencedGF$6
&-F#6#-I'mtableGF$6:-I$mtrGF$61-I$mtdGF$6(-I#miGF$6%Q&<x|gry>F'/%'ital
icGQ%trueF'/%,mathvariantGQ'italicF'/%)rowalignGQ!F'/%,columnalignGFE/
%+groupalignGFE/%(rowspanGQ\"1F'/%+columnspanGFL-F76(-F,6&-F#6#-I#mnGF
$6$Q\"6F'/FAQ'normalF'FY/%%openGQ\"[F'/%&closeGQ\"]F'FCFFFHFJFM-F76(-F
,6&-F#6%-FV6$Q\"5F'FY-I#moGF$6-Q\",F'FY/%&fenceGQ&falseF'/%*separatorG
F?/%)stretchyGFjo/%*symmetricGFjo/%(largeopGFjo/%.movablelimitsGFjo/%'
accentGFjo/%'lspaceGQ&0.0emF'/%'rspaceGQ,0.3333333emF'-FV6$FLFYFYFenFh
nFCFFFHFJFM-F76(-F,6&-F#6%-FV6$Q\"4F'FYFdo-FV6$Q\"2F'FYFYFenFhnFCFFFHF
JFM-F76(-F,6&-F#6'FeqFdoF]qFdoF]qFYFenFhnFCFFFHFJFM-F76(-F,6&-F#6%-FV6
$Q\"3F'FYFdoFgrFYFenFhnFCFFFHFJFM-F76(-F,6&-F#6'FgrFdoFhqFdoF]qFYFenFh
nFCFFFHFJFM-F76(-F,6&-F#6)FgrFdoF]qFdoF]qFdoF]qFYFenFhnFCFFFHFJFM-F76(
-F,6&-F#6'FhqFdoFhqFdoFhqFYFenFhnFCFFFHFJFM-F76(-F,6&-F#6)FhqFdoFhqFdo
F]qFdoF]qFYFenFhnFCFFFHFJFM-F76(-F,6&-F#6+FhqFdoF]qFdoF]qFdoF]qFdoF]qF
YFenFhnFCFFFHFJFM-F76(-F,6&-F#6-F]qFdoF]qFdoF]qFdoF]qFdoF]qFdoF]qFYFen
FhnFCFFFHFJFMFCFFFH-F461-F76(-F,6&-F#6#FeqFYFenFhnFCFFFHFJFM-F76(-I%ms
ubGF$6%-F:6%Q\"mF'F=F@-F#6#-FV6$Q#10F'FY/%/subscriptshiftGQ\"0F'FCFFFH
FJFM-F76(-FV6$FevFYFCFFFHFJFMFfvFfvFfvFfvFfvFfvFfvFfvFfvFCFFFH-F461-F7
6(-F,6&-F#6%FgrFdoF]qFYFenFhnFCFFFHFJFMFfv-F76(-F#6%-Fiu6%F[v-F#6%-FV6
$Q\"8F'FYFdoFhqFcv-Feo6-Q\"+F'FYFho/F\\pFjoF]pF_pFapFcpFep/FhpQ,0.2222
222emF'/F[qFbx-Fiu6%F[v-F#6%FUFdoFeqFcvFCFFFHFJFM-F76(-F#6%-Fiu6%F[v-F
#6%-FV6$Q\"7F'FYFdoFgrFcvF]x-F#6%Fhq-Feo6-Q1&InvisibleTimes;F'FYFhoF`x
F]pF_pFapFcpFepFgp/F[qFip-Fiu6%F[v-F#6%FaoFdoFaoFcvFCFFFHFJFMFfv-F76(F
dxFCFFFHFJFMFfvFfvFfvFfvFfvFfvFCFFFH-F461-F76(-F,6&-F#6%FhqFdoFhqFYFen
FhnFCFFFHFJFMFfv-F76(F\\yFCFFFHFJFMF]zFfv-F76(FiyFCFFFHFJFMFfvFfvFfvFf
vFfvFfvFCFFFH-F461-F76(-F,6&-F#6'FhqFdoF]qFdoF]qFYFenFhnFCFFFHFJFMFfvF
fvFfv-F76(-F#6%-Fiu6%F[v-F#6'FUFdoFhqFdoFhqFcvF]x-Fiu6%F[v-F#6'FaoFdoF
grFdoFhqFcvFCFFFHFJFMFfv-F76(-F#6'F[\\lF]x-F#6%FhqFey-Fiu6%F[v-F#6'Feq
FdoFeqFdoFhqFcvF]x-F#6%FhqFey-Fiu6%F[v-F#6'FeqFdoFgrFdoFgrFcvFCFFFHFJF
MFfv-F76(F[]lFCFFFHFJFMFfvFfvFfvFCFFFH-F461-F76(-F,6&-F#6)F]qFdoF]qFdo
F]qFdoF]qFYFenFhnFCFFFHFJFMFfvFfvFfvFfvFfvFfv-F76(-Fiu6%F[v-F#6)FeqFdo
FhqFdoFhqFdoFhqFcvFCFFFHFJFMFfv-F76(-Fiu6%F[v-F#6)FgrFdoFgrFdoFhqFdoFh
qFcvFCFFFHFJFMFfvFfvFCFFFH/%&alignGQ%axisF'/FDQ)baselineF'/FGQ'centerF
'/FIQ'|frleft|hrF'/%/alignmentscopeGF?/%,columnwidthGQ%autoF'/%&widthG
Fb_l/%+rowspacingGQ&1.0exF'/%.columnspacingGQ&0.8emF'/%)rowlinesGQ%non
eF'/%,columnlinesGF]`l/%&frameGF]`l/%-framespacingGQ,0.4em~0.5exF'/%*e
qualrowsGFjo/%-equalcolumnsGFjo/%-displaystyleGFjo/%%sideGQ&rightF'/%0
minlabelspacingGFj_lFYFenFhn" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 20 "getSfktSeries(E,6);\n" }{MPLTEXT 1 0 33 "collect(getSfktSeries(F
,6,t),t);\n" }{MPLTEXT 1 0 17 "dimSN(expand(%));" }}{PARA 11 "" 1 "" 
{XPPMATH 20 "6#7(&%\"sG6#\"\"!,$&%\"sG6#\"\"\"!\"\"&%\"sG6$\"\"#\"\"\"
,$&%\"sG6$\"\"#\"\"#!\"\",$&%\"sG6%\"\"$\"\"\"\"\"\"!\"\"&%\"sG6%\"\"$
\"\"#\"\"\"" }}{PARA 12 "" 1 "" {XPPMATH 20 "6#,0*&,8&%\"sG6#\"\"'\"\"
\"&%\"sG6$\"\"&\"\"\"\"\"\"&%\"sG6$\"\"%\"\"#\"\"\"&%\"sG6%\"\"%\"\"\"
\"\"\"\"\"\"&%\"sG6$\"\"$\"\"$\"\"\"&%\"sG6%\"\"$\"\"#\"\"\"\"\"\"&%\"
sG6&\"\"$\"\"\"\"\"\"\"\"\"\"\"\"&%\"sG6%\"\"#\"\"#\"\"#\"\"\"&%\"sG6&
\"\"#\"\"#\"\"\"\"\"\"\"\"\"&%\"sG6'\"\"#\"\"\"\"\"\"\"\"\"\"\"\"\"\"
\"&%\"sG6(\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\")%\"tG\"\"'
\"\"\"\"\"\"*&,0&%\"sG6#\"\"&\"\"\"&%\"sG6$\"\"%\"\"\"\"\"\"&%\"sG6$\"
\"$\"\"#\"\"\"&%\"sG6%\"\"$\"\"\"\"\"\"\"\"\"&%\"sG6%\"\"#\"\"#\"\"\"
\"\"\"&%\"sG6&\"\"#\"\"\"\"\"\"\"\"\"\"\"\"&%\"sG6'\"\"\"\"\"\"\"\"\"
\"\"\"\"\"\"\"\"\"\"\"\")%\"tG\"\"&\"\"\"\"\"\"*&,,&%\"sG6#\"\"%\"\"\"
&%\"sG6$\"\"$\"\"\"\"\"\"&%\"sG6$\"\"#\"\"#\"\"\"&%\"sG6%\"\"#\"\"\"\"
\"\"\"\"\"&%\"sG6&\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\")%\"tG\"\"%\"\"
\"\"\"\"*&,(&%\"sG6#\"\"$\"\"\"&%\"sG6$\"\"#\"\"\"\"\"\"&%\"sG6%\"\"\"
\"\"\"\"\"\"\"\"\"\"\"\")%\"tG\"\"$\"\"\"\"\"\"*&,&&%\"sG6#\"\"#\"\"\"
&%\"sG6$\"\"\"\"\"\"\"\"\"\"\"\")%\"tG\"\"#\"\"\"\"\"\"*&&%\"sG6#\"\"
\"\"\"\"%\"tG\"\"\"\"\"\"&%\"sG6#\"\"!\"\"\"" }}{PARA 11 "" 1 "" 
{XPPMATH 20 "6#,.%\"tG\"\"\"*&\"\"#\"\"\")%\"tG\"\"#\"\"\"\"\"\"*&\"\"
%\"\"\")%\"tG\"\"$\"\"\"\"\"\"*&\"#5\"\"\")%\"tG\"\"%\"\"\"\"\"\"*&\"#
E\"\"\")%\"tG\"\"&\"\"\"\"\"\"*&\"#w\"\"\")%\"tG\"\"'\"\"\"\"\"\"" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "" 0 "" {TEXT 212 3 "End" }}}}
{MARK "0 0 0" 0 }{VIEWOPTS 1 1 0 75 100 1802 1 1 1 1 }{PAGENUMBERS 0 
1 2 33 1 1 }